/*
 * Type Definitions for node-gtk (https://github.com/romgrk/node-gtk)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * Gda-5.0
 */

import type libxml2 from './libxml2-2.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';

export namespace Gda {

enum BatchError {
    BATCH_CONFLICTING_PARAMETER_ERROR,
}
enum ConfigError {
    DSN_NOT_FOUND_ERROR,
    PERMISSION_ERROR,
    PROVIDER_NOT_FOUND_ERROR,
    PROVIDER_CREATION_ERROR,
}
enum ConnectionError {
    DSN_NOT_FOUND_ERROR,
    PROVIDER_NOT_FOUND_ERROR,
    PROVIDER_ERROR,
    NO_CNC_SPEC_ERROR,
    NO_PROVIDER_SPEC_ERROR,
    OPEN_ERROR,
    STATEMENT_TYPE_ERROR,
    CANT_LOCK_ERROR,
    TASK_NOT_FOUND_ERROR,
    UNSUPPORTED_THREADS_ERROR,
    CLOSED_ERROR,
    META_DATA_CONTEXT_ERROR,
    UNSUPPORTED_ASYNC_EXEC_ERROR,
}
enum ConnectionEventCode {
    CONSTRAINT_VIOLATION,
    RESTRICT_VIOLATION,
    NOT_NULL_VIOLATION,
    FOREIGN_KEY_VIOLATION,
    UNIQUE_VIOLATION,
    CHECK_VIOLATION,
    INSUFFICIENT_PRIVILEGES,
    UNDEFINED_COLUMN,
    UNDEFINED_FUNCTION,
    UNDEFINED_TABLE,
    DUPLICATE_COLUMN,
    DUPLICATE_DATABASE,
    DUPLICATE_FUNCTION,
    DUPLICATE_SCHEMA,
    DUPLICATE_TABLE,
    DUPLICATE_ALIAS,
    DUPLICATE_OBJECT,
    SYNTAX_ERROR,
    UNKNOWN,
}
enum ConnectionEventType {
    NOTICE,
    WARNING,
    ERROR,
    COMMAND,
}
/**
 * Used in gda_connection_supports_feature() and gda_server_provider_supports_feature() to test if a connection
 * or a database provider supports some specific feature.
 */
enum ConnectionFeature {
    /**
     * test for aggregates support
     */
    AGGREGATES,
    /**
     * test for BLOBS (binary large objects) support
     */
    BLOBS,
    /**
     * test for indexes support
     */
    INDEXES,
    /**
     * test for tables inheritance support
     */
    INHERITANCE,
    /**
     * test for namespaces support
     */
    NAMESPACES,
    /**
     * test for functions support
     */
    PROCEDURES,
    /**
     * test for sequences support
     */
    SEQUENCES,
    /**
     * test for SQL language (even specific to the database) support
     */
    SQL,
    /**
     * test for transactions support
     */
    TRANSACTIONS,
    /**
     * test for savepoints within transactions support
     */
    SAVEPOINTS,
    /**
     * test if savepoints can be removed
     */
    SAVEPOINTS_REMOVE,
    /**
     * test for triggers support
     */
    TRIGGERS,
    /**
     * test for updatable cursors support
     */
    UPDATABLE_CURSOR,
    /**
     * test for users support
     */
    USERS,
    /**
     * test for views support
     */
    VIEWS,
    /**
     * test for distributed transactions support
     */
    XA_TRANSACTIONS,
    /**
     * test for native multi-threading support
     */
    MULTI_THREADING,
    /**
     * test if connection supports asynchronous execution
     */
    ASYNC_EXEC,
    /**
     * not used
     */
    LAST,
}
/**
 * Used with gda_connection_get_meta_store_data() to describe what meta data to extract from
 * a connection's associated #GdaMetaStore.
 */
enum ConnectionMetaType {
    /**
     * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_NAMESPACES">namespaces</link> (or schemas for PostgreSQL)
     */
    NAMESPACES,
    /**
     * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_TYPES">database types</link>
     */
    TYPES,
    /**
     * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_TABLES">tables</link>
     */
    TABLES,
    /**
     * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_VIEWS">views</link>
     */
    VIEWS,
    /**
     * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_FIELDS">table's or view's fields</link>
     */
    FIELDS,
    /**
     * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_INDEXES">table's indexes</link>
     */
    INDEXES,
}
enum DataComparatorError {
    MISSING_DATA_MODEL_ERROR,
    COLUMN_TYPES_MISMATCH_ERROR,
    MODEL_ACCESS_ERROR,
    USER_CANCELLED_ERROR,
}
enum DataModelError {
    ROW_OUT_OF_RANGE_ERROR,
    COLUMN_OUT_OF_RANGE_ERROR,
    VALUES_LIST_ERROR,
    VALUE_TYPE_ERROR,
    ROW_NOT_FOUND_ERROR,
    ACCESS_ERROR,
    FEATURE_NON_SUPPORTED_ERROR,
    FILE_EXIST_ERROR,
    XML_FORMAT_ERROR,
    TRUNCATED_ERROR,
    OTHER_ERROR,
}
enum DataModelHint {
    START_BATCH_UPDATE,
    END_BATCH_UPDATE,
    REFRESH,
}
/**
 * Format to use when exporting a data model, see gda_data_model_export_to_string() and gda_data_model_export_to_file()
 */
enum DataModelIOFormat {
    /**
     * data is exported as an XML structure
     */
    DATA_ARRAY_XML,
    /**
     * data is exported as CSV
     */
    TEXT_SEPARATED,
    /**
     * data is exported as a human readable table
     */
    TEXT_TABLE,
}
enum DataModelIterError {
    DATA_MODEL_ITER_COLUMN_OUT_OF_RANGE_ERROR,
}
/**
 * Possible operations for the data fields.
 */
enum DataPivotAggregate {
    AVG,
    COUNT,
    MAX,
    MIN,
    SUM,
}
/**
 * Possible #GdaDataPivot related errors.
 */
enum DataPivotError {
    INTERNAL_ERROR,
    SOURCE_MODEL_ERROR,
    FIELD_FORMAT_ERROR,
    USAGE_ERROR,
    OVERFLOW_ERROR,
}
/**
 * Define types of field to be used when defining a #GdaDataPivot analysis.
 */
enum DataPivotFieldType {
    ROW,
    COLUMN,
}
enum DataProxyError {
    COMMIT_ERROR,
    COMMIT_CANCELLED,
    READ_ONLY_VALUE,
    READ_ONLY_ROW,
    FILTER_ERROR,
}
/**
 * Defines what criteria gda_data_select_compute_modification_statements_ext() uses
 * to uniquely identify a single row in a table when creating modification statements.
 */
enum DataSelectConditionType {
    /**
     * only primary key fields are used
     */
    PK,
    /**
     * all the columns of the tables are used
     */
    ALL_COLUMNS,
}
enum DataSelectError {
    MODIFICATION_STATEMENT_ERROR,
    MISSING_MODIFICATION_STATEMENT_ERROR,
    CONNECTION_ERROR,
    ACCESS_ERROR,
    SQL_ERROR,
    SAFETY_LOCKED_ERROR,
}
enum DiffType {
    ADD_ROW,
    REMOVE_ROW,
    MODIFY_ROW,
}
enum HolderError {
    STRING_CONVERSION_ERROR,
    VALUE_TYPE_ERROR,
    VALUE_NULL_ERROR,
}
/**
 * Defines the search scope of an LDAP search command, relative to the base object.
 */
enum LdapSearchScope {
    /**
     * search of the base object only
     */
    BASE,
    /**
     * search of immediate children of the base object, but does not include the base object itself
     */
    ONELEVEL,
    /**
     * search of the base object and the entire subtree below the base object
     */
    SUBTREE,
}
/**
 * Type of database object which can be handled as a #GdaMetaDbObject
 */
enum MetaDbObjectType {
    /**
     * unknown type
     */
    UNKNOWN,
    /**
     * represents a table
     */
    TABLE,
    /**
     * represents a view
     */
    VIEW,
}
/**
 * Defines the filtering policy of a foreign key when invoked on an UPDATE
 * or DELETE operation.
 */
enum MetaForeignKeyPolicy {
    /**
     * unspecified policy
     */
    UNKNOWN,
    /**
     * not enforced policy
     */
    NONE,
    /**
     * return an error, no action taken
     */
    NO_ACTION,
    /**
     * same as `GDA_META_FOREIGN_KEY_NO_ACTION,` not deferrable
     */
    RESTRICT,
    /**
     * policy is to delete any rows referencing the deleted row, or update the value of the referencing column to the new value of the referenced column, respectively
     */
    CASCADE,
    /**
     * policy is to set the referencing column to NULL
     */
    SET_NULL,
    /**
     * policy is to set the referencing column to its default value
     */
    SET_DEFAULT,
}
/**
 * Types of sorting
 */
enum MetaSortType {
    /**
     * sort alphabetically
     */
    ALHAPETICAL,
    /**
     * sort by dependencies
     */
    DEPENDENCIES,
}
enum MetaStoreChangeType {
    ADD,
    REMOVE,
    MODIFY,
}
enum MetaStoreError {
    INCORRECT_SCHEMA_ERROR,
    UNSUPPORTED_PROVIDER_ERROR,
    INTERNAL_ERROR,
    META_CONTEXT_ERROR,
    MODIFY_CONTENTS_ERROR,
    EXTRACT_SQL_ERROR,
    ATTRIBUTE_NOT_FOUND_ERROR,
    ATTRIBUTE_ERROR,
    SCHEMA_OBJECT_NOT_FOUND_ERROR,
    SCHEMA_OBJECT_CONFLICT_ERROR,
    SCHEMA_OBJECT_DESCR_ERROR,
    TRANSACTION_ALREADY_STARTED_ERROR,
}
enum MetaStructError {
    UNKNOWN_OBJECT_ERROR,
    DUPLICATE_OBJECT_ERROR,
    INCOHERENCE_ERROR,
    XML_ERROR,
}
enum ServerOperationError {
    OBJECT_NAME_ERROR,
    INCORRECT_VALUE_ERROR,
    XML_ERROR,
}
enum ServerOperationNodeStatus {
    OPTIONAL,
    REQUIRED,
    UNKNOWN,
}
enum ServerOperationNodeType {
    PARAMLIST,
    DATA_MODEL,
    PARAM,
    SEQUENCE,
    SEQUENCE_ITEM,
    DATA_MODEL_COLUMN,
    UNKNOWN,
}
enum ServerOperationType {
    CREATE_DB,
    DROP_DB,
    CREATE_TABLE,
    DROP_TABLE,
    RENAME_TABLE,
    ADD_COLUMN,
    DROP_COLUMN,
    CREATE_INDEX,
    DROP_INDEX,
    CREATE_VIEW,
    DROP_VIEW,
    COMMENT_TABLE,
    COMMENT_COLUMN,
    CREATE_USER,
    ALTER_USER,
    DROP_USER,
    LAST,
}
enum ServerProviderError {
    METHOD_NON_IMPLEMENTED_ERROR,
    PREPARE_STMT_ERROR,
    EMPTY_STMT_ERROR,
    MISSING_PARAM_ERROR,
    STATEMENT_EXEC_ERROR,
    OPERATION_ERROR,
    INTERNAL_ERROR,
    BUSY_ERROR,
    NON_SUPPORTED_ERROR,
    SERVER_VERSION_ERROR,
    DATA_ERROR,
    DEFAULT_VALUE_HANDLING_ERROR,
    MISUSE_ERROR,
    FILE_NOT_FOUND_ERROR,
}
enum SetError {
    XML_SPEC_ERROR,
    HOLDER_NOT_FOUND_ERROR,
    INVALID_ERROR,
    READ_ONLY_ERROR,
    IMPLEMENTATION_ERROR,
}
enum SqlBuilderError {
    WRONG_TYPE_ERROR,
    MISUSE_ERROR,
}
enum SqlError {
    STRUCTURE_CONTENTS_ERROR,
    MALFORMED_IDENTIFIER_ERROR,
    MISSING_IDENTIFIER_ERROR,
    VALIDATION_ERROR,
}
enum SqlOperatorType {
    AND,
    OR,
    EQ,
    IS,
    LIKE,
    BETWEEN,
    GT,
    LT,
    GEQ,
    LEQ,
    DIFF,
    REGEXP,
    REGEXP_CI,
    NOT_REGEXP,
    NOT_REGEXP_CI,
    SIMILAR,
    ISNULL,
    ISNOTNULL,
    NOT,
    IN,
    NOTIN,
    CONCAT,
    PLUS,
    MINUS,
    STAR,
    DIV,
    REM,
    BITAND,
    BITOR,
    BITNOT,
    ILIKE,
    NOTLIKE,
    NOTILIKE,
    GLOB,
}
enum SqlParserError {
    SYNTAX_ERROR,
    OVERFLOW_ERROR,
    EMPTY_SQL_ERROR,
}
enum SqlParserFlavour {
    STANDARD,
    SQLITE,
    MYSQL,
    ORACLE,
    POSTGRESQL,
}
enum SqlParserMode {
    PARSE,
    DELIMIT,
}
enum SqlSelectJoinType {
    CROSS,
    NATURAL,
    INNER,
    LEFT,
    RIGHT,
    FULL,
}
enum SqlStatementCompoundType {
    UNION,
    UNION_ALL,
    INTERSECT,
    INTERSECT_ALL,
    EXCEPT,
    EXCEPT_ALL,
}
/**
 * Known types of statements
 */
enum SqlStatementType {
    /**
     * a SELECT statement
     */
    SELECT,
    /**
     * an INSERT statement
     */
    INSERT,
    /**
     * an UPDATE statement
     */
    UPDATE,
    /**
     * a DELETE statement
     */
    DELETE,
    /**
     * a compound statement: multiple SELECT statements grouped together using an operator
     */
    COMPOUND,
    /**
     * start of transaction statement
     */
    BEGIN,
    /**
     * transaction abort statement
     */
    ROLLBACK,
    /**
     * transaction commit statement
     */
    COMMIT,
    /**
     * new savepoint definition statement
     */
    SAVEPOINT,
    /**
     * return to savepoint statement
     */
    ROLLBACK_SAVEPOINT,
    /**
     * savepoint deletion statement
     */
    DELETE_SAVEPOINT,
    /**
     * unknown statement, only identifies variables
     */
    UNKNOWN,
    /**
     * not used
     */
    NONE,
}
enum StatementError {
    PARSE_ERROR,
    SYNTAX_ERROR,
    NO_CNC_ERROR,
    CNC_CLOSED_ERROR,
    EXEC_ERROR,
    PARAM_TYPE_ERROR,
    PARAM_ERROR,
}
/**
 * Defines the kind of notification which can be obtained when reading from te #GIOChannel
 * returned by gda_thread_wrapper_get_io_channel().
 */
enum ThreadNotificationType {
    /**
     * the notification regards a job finished
     */
    JOB,
    /**
     * the notification regards a signal
     */
    SIGNAL,
}
enum ThreadWrapperError {
    THREAD_WRAPPER_UNKNOWN_ERROR,
}
enum TransactionIsolation {
    UNKNOWN,
    READ_COMMITTED,
    READ_UNCOMMITTED,
    REPEATABLE_READ,
    SERIALIZABLE,
}
enum TransactionStatusEventType {
    SAVEPOINT,
    SQL,
    SUB_TRANSACTION,
}
enum TransactionStatusState {
    OK,
    FAILED,
}
enum TreeError {
    TREE_UNKNOWN_ERROR,
}
enum TreeManagerError {
    TREE_MANAGER_UNKNOWN_ERROR,
}
enum TreeNodeError {
    TREE_NODE_UNKNOWN_ERROR,
}
enum XaTransactionError {
    ALREADY_REGISTERED_ERROR,
    DTP_NOT_SUPPORTED_ERROR,
    CONNECTION_BRANCH_LENGTH_ERROR,
}
/**
 * Specifies some aspects of a connection when opening it.
 * 
 * Additional information about the GDA_CONNECTION_OPTIONS_SQL_IDENTIFIERS_CASE_SENSITIVE flag:
 * <itemizedlist>
 *   <listitem><para>For example without this flag, if the table
 *       name specified in a #GdaServerOperation to create a table is
 *       <emphasis>MyTable</emphasis>, then usually the database will create a table named
 *       <emphasis>mytable</emphasis>, whereas with this flag, the table will be created
 *       as <emphasis>MyTable</emphasis> (note that in the end the database may still decide
 *       to name the table <emphasis>mytable</emphasis> or differently if it can't do
 *       otherwise).</para></listitem>
 *   <listitem><para>Libgda will not apply this rule when parsing SQL code, the SQL code being parsed
 *       has to be conform to the database it will be used with</para></listitem>
 * </itemizedlist>
 * 
 * Additional information about the GDA_CONNECTION_OPTIONS_THREAD_SAFE and GDA_CONNECTION_OPTIONS_THREAD_ISOLATED flags:
 * The GDA_CONNECTION_OPTIONS_THREAD_SAFE flag specifies that it has to be able to use the returned connection object from
 * several threads at once (locking is ensured by the #GdaConnection itself). Depending on the database provider's
 * implementation and on the native libraries it uses, the "normal" connection object might not respect this requirement,
 * and in this case a specific thread is started and used as the unique thread which will manipulate the actual connection,
 * while a "wrapper connection" is actually returned and used by the caller (that wrapper connection passes method calls
 * from the calling thread to the actual connection's specific thread, and gets the results back).
 * 
 * The GDA_CONNECTION_OPTIONS_THREAD_ISOLATED forces using a specific thread and a "wrapper connection" even if the
 * "normal" connection would itself be thread safe; this is useful for example to be sure the asynchronous API can
 * always be used (see gda_connection_async_statement_execute()).
 * 
 * Having a specific thread and a "wrapper connection" definitely has an impact on the performances (because it involves
 * messages passing between threads for every method call), so using the
 * GDA_CONNECTION_OPTIONS_THREAD_SAFE or GDA_CONNECTION_OPTIONS_THREAD_ISOLATED flags should be carefully considered.
 * 
 * Note about the `GDA_CONNECTION_OPTIONS_AUTO_META_DATA` flag:
 * <itemizedlist>
 *  <listitem><para>Every time a DDL statement is successfully executed, the associated meta data, if
 *               defined, will be updated, which has a impact on performances</para></listitem>
 *  <listitem><para>If a transaction is started and some DDL statements are executed and the transaction
 *            is not rolled back or committed, then the meta data may end up being wrong</para></listitem>
 * </itemizedlist>
 */
enum ConnectionOptions {
    /**
     * no specific aspect
     */
    NONE,
    /**
     * this flag specifies that the connection to open should be in a read-only mode
     *                                    (this policy is not correctly enforced at the moment)
     */
    READ_ONLY,
    /**
     * this flag specifies that SQL identifiers submitted as input
     *                                    to Libgda have to keep their case sensitivity.
     */
    SQL_IDENTIFIERS_CASE_SENSITIVE,
    /**
     * this flag specifies that the connection to open will be used
     *                                     by several threads at once so it has to be thread safe
     */
    THREAD_SAFE,
    /**
     * this flag specifies that the connection to open will be used
     *                                     by several threads at once and requests that the real connection be used
     *                                     only in a sub thread created specifically for it
     */
    THREAD_ISOLATED,
    /**
     * this flags specifies that if a #GdaMetaStore has been associated
     *                                     to the connection, then it is kept up to date with the evolutions in the
     *                                     database's structure. Be aware however that there are some drawbacks
     *                                     explained below.
     */
    AUTO_META_DATA,
}
enum DataModelAccessFlags {
    RANDOM,
    CURSOR_FORWARD,
    CURSOR_BACKWARD,
    CURSOR,
    INSERT,
    UPDATE,
    DELETE,
    WRITE,
}
enum MetaGraphInfo {
    META_GRAPH_COLUMNS,
}
/**
 * Controls which features are computed about database objects.
 */
enum MetaStructFeature {
    /**
     * database objects only have their own attributes
     */
    NONE,
    /**
     * foreign keys are computed for tables
     */
    FOREIGN_KEYS,
    /**
     * for views, the tables they use are also computed
     */
    VIEW_DEPENDENCIES,
    /**
     * all the features are computed
     */
    ALL,
}
enum ServerOperationCreateTableFlag {
    NOTHING_FLAG,
    PKEY_FLAG,
    NOT_NULL_FLAG,
    UNIQUE_FLAG,
    AUTOINC_FLAG,
    FKEY_FLAG,
    PKEY_AUTOINC_FLAG,
}
/**
 * Specifies how SQL identifiers are represented by a specific database
 */
enum SqlIdentifierStyle {
    /**
     * case insensitive SQL identifiers are represented in lower case (meaning that any SQL identifier which has a non lower case character is case sensitive)
     */
    LOWER_CASE,
    /**
     * case insensitive SQL identifiers are represented in upper case (meaning that any SQL identifier which has a non upper case character is case sensitive)
     */
    UPPER_CASE,
}
/**
 * These flags specify how the #GdaDataModel returned when executing a #GdaStatement will be used
 */
enum StatementModelUsage {
    /**
     * access to the data model will be random (usually this will result in a data model completely stored in memory)
     */
    RANDOM_ACCESS,
    /**
     * access to the data model will be done using a cursor moving forward
     */
    CURSOR_FORWARD,
    /**
     * access to the data model will be done using a cursor moving backward
     */
    CURSOR_BACKWARD,
    /**
     * access to the data model will be done using a cursor (moving both forward and backward)
     */
    CURSOR,
    /**
     * specifies that the data model should be executed even if some parameters required to execute it are invalid (in this case the data model will have no row, and will automatically be re-run when the missing parameters are once again valid)
     */
    ALLOW_NOPARAM,
    /**
     * specifies that the data model's contents will be fully loaded into the client side (the memory of the process using Libgda), not requiring the server any more to access the data (the default behaviour is to access the server any time data is to be read, and data is cached in memory). This flag is useful only if used in conjunction with the GDA_STATEMENT_MODEL_RANDOM_ACCESS flag (otherwise an error will be returned).
     */
    OFFLINE,
}
/**
 * Specifies rendering options
 */
enum StatementSqlFlag {
    /**
     * rendering will replace parameters with their values
     */
    PARAMS_AS_VALUES,
    /**
     * rendering will include newlines and indentation to make it easy to read
     */
    PRETTY,
    /**
     * parameters will be rendered using the "/&ast; name:&lt;param_name&gt; ... &ast;/" syntax
     */
    PARAMS_LONG,
    /**
     * parameters will be rendered using the "##&lt;param_name&gt;..." syntax
     */
    PARAMS_SHORT,
    /**
     * parameters will be rendered using the ":&lt;param_name&gt;" syntax
     */
    PARAMS_AS_COLON,
    /**
     * parameters will be rendered using the "$&lt;param_number&gt;" syntax where parameters are numbered starting from 1
     */
    PARAMS_AS_DOLLAR,
    /**
     * parameters will be rendered using the "?&lt;param_number&gt;" syntax where parameters are numbered starting from 1
     */
    PARAMS_AS_QMARK,
    /**
     * parameters will be rendered using the "?" syntax
     */
    PARAMS_AS_UQMARK,
    /**
     * time and timestamp with a timezone information are converted to GMT before rendering, and rendering does not show the timezone information
     */
    TIMEZONE_TO_GMT,
}
enum ValueAttribute {
    NONE,
    IS_NULL,
    CAN_BE_NULL,
    IS_DEFAULT,
    CAN_BE_DEFAULT,
    IS_UNCHANGED,
    ACTIONS_SHOWN,
    DATA_NON_VALID,
    HAS_VALUE_ORIG,
    NO_MODIF,
    UNUSED,
}
/**
 * The corresponding attribute specifies if the object it refers to is auto incremented (value has a G_TYPE_BOOLEAN type).
 */
const ATTRIBUTE_AUTO_INCREMENT: string
/**
 * The corresponding attribute is the description of the object it refers to (value has a G_TYPE_STRING type).
 */
const ATTRIBUTE_DESCRIPTION: string
/**
 * The corresponding attribute specifies if the object it refers to has its value to default (value has a G_TYPE_BOOLEAN type).
 */
const ATTRIBUTE_IS_DEFAULT: string
/**
 * The corresponding attribute is the name of the object it refers to (value has a G_TYPE_STRING type).
 */
const ATTRIBUTE_NAME: string
/**
 * The corresponding attribute is the number of significant digits of the object it refers to (value has a G_TYPE_INT type).
 */
const ATTRIBUTE_NUMERIC_PRECISION: string
/**
 * The corresponding attribute is the number of significant digits to the right of the decimal point of the object it refers to (value has a G_TYPE_INT type).
 */
const ATTRIBUTE_NUMERIC_SCALE: string
/**
 * This attribute, if %TRUE specifies that a tree node may or may not have any children nodes (value has a G_TYPE_BOOLEAN type).
 */
const ATTRIBUTE_TREE_NODE_UNKNOWN_CHILDREN: string
const EXTRA_AUTO_INCREMENT: string
const SQLSTATE_GENERAL_ERROR: string
const SQLSTATE_NO_ERROR: string
const TIMEZONE_INVALID: number
function alphanumToText(text: string): string
function binaryCopy(boxed?: object | null): object | null
function binaryFree(boxed?: object | null): void
function blobCopy(boxed?: object | null): object | null
function blobFree(boxed?: object | null): void
function completionListGet(cnc: Connection, sql: string, start: number, end: number): string[] | null
function computeDmlStatements(cnc: Connection, selectStmt: Statement, requirePk: boolean, insertStmt?: Statement | null, updateStmt?: Statement | null, deleteStmt?: Statement | null): boolean
function dataHandlerGetDefault(forType: GObject.Type): DataHandler
function dataModelErrorQuark(): GLib.Quark
function defaultEscapeString(string: string): string
function defaultUnescapeString(string: string): string
function dsnSplit(string: string, outDsn: string, outUsername: string, outPassword: string): void
function gTypeFromString(str: string): GObject.Type
function gTypeToString(type: GObject.Type): string
function geometricpointCopy(boxed?: object | null): object | null
function geometricpointFree(boxed?: object | null): void
function getApplicationExecPath(appName: string): string
function identifierEqual(id1: string, id2: string): boolean
function identifierHash(id: string): number
function init(): void
function localeChanged(): void
function logDisable(): void
function logEnable(): void
function logIsEnabled(): boolean
function mutexFree(mutex: Mutex): void
function mutexLock(mutex: Mutex): void
function mutexTrylock(mutex: Mutex): boolean
function mutexUnlock(mutex: Mutex): void
function parseFormattedDate(gdate: GLib.Date, value: string, first: GLib.DateDMY, second: GLib.DateDMY, third: GLib.DateDMY, sep: number): boolean
function parseFormattedTime(timegda: Time, value: string, sep: number): boolean
function parseFormattedTimestamp(timestamp: Timestamp, value: string, first: GLib.DateDMY, second: GLib.DateDMY, third: GLib.DateDMY, sep: number): boolean
function parseIso8601Date(gdate: GLib.Date, value: string): boolean
function parseIso8601Time(timegda: Time, value: string): boolean
function parseIso8601Timestamp(timestamp: Timestamp, value: string): boolean
function rewriteStatementForNullParameters(stmt: Statement, params: Set, outStmt?: Statement | null): boolean
function rfc1738Decode(string: string): boolean
function rfc1738Encode(string: string): string
function selectAlterSelectForEmpty(stmt: Statement): Statement
function sqlErrorQuark(): GLib.Quark
function sqlIdentifierQuote(id: string, cnc: Connection | null, prov: ServerProvider | null, metaStoreConvention: boolean, forceQuotes: boolean): string
function sqlIdentifierSplit(id: string): string[] | null
function sqlOperationOperatorFromString(op: string): SqlOperatorType
function sqlOperationOperatorToString(op: SqlOperatorType): string
function sqlSelectJoinTypeToString(type: SqlSelectJoinType): string
function stringToBinary(str?: string | null): Binary
function stringToBlob(str: string): Blob
function textToAlphanum(text: string): string
function timeCopy(boxed?: object | null): object | null
function timeFree(boxed?: object | null): void
function timestampCopy(boxed?: object | null): object | null
function timestampFree(boxed?: object | null): void
function utilityCheckDataModel(model: DataModel, types: GObject.Type[]): boolean
function utilityDataModelDumpDataToXml(model: DataModel, parent: libxml2.NodePtr, cols: number[] | null, rows: number[] | null, useColIds: boolean): boolean
function utilityDataModelFindColumnDescription(model: DataSelect, fieldName: string): string
function utilityHolderLoadAttributes(holder: Holder, node: libxml2.NodePtr, sources: DataModel[]): boolean
function valueCompare(value1: any, value2: any): number
function valueDiffer(value1: any, value2: any): number
function valueStringify(value: any): string
interface AttributesManagerFunc {
    (attName: string, value: any, data?: object | null): void
}
interface AttributesManagerSignal {
    (obj: GObject.Object, attName: string, value: any, data?: object | null): void
}
/**
 * Function to be called by Libgda when the associated asynchronous method invoked finishes.
 */
interface ServerProviderAsyncCallback {
    (provider: ServerProvider, cnc: Connection, taskId: number, resultStatus: boolean, error: GLib.Error, data?: object | null): void
}
/**
 * Function to be called by Libgda when the associated asynchronous method invoked finishes
 */
interface ServerProviderExecCallback {
    (provider: ServerProvider, cnc: Connection, taskId: number, resultObj: GObject.Object, error: GLib.Error, data?: object | null): void
}
/**
 * Rendering function type to render a #GValue
 */
interface SqlRenderingValue {
    (value: any, context: SqlRenderingContext): string
}
interface SqlReservedKeywordsFunc {
    (word: string): boolean
}
/**
 * Specifies the type of function to be passed to gda_thread_wrapper_connect_raw()
 */
interface ThreadWrapperCallback {
    (wrapper: ThreadWrapper, instance: object | null, signame: string, nParamValues: number, paramValues: any, gdaReserved?: object | null, data?: object | null): void
}
/**
 * Specifies the type of function to be passed to gda_thread_wrapper_execute().
 */
interface ThreadWrapperFunc {
    (arg?: object | null): object | null
}
/**
 * Specifies the type of function to be passed to gda_thread_wrapper_execute_void().
 */
interface ThreadWrapperVoidFunc {
    (arg?: object | null): void
}
class DataHandler {
    /* Methods of Gda-5.0.Gda.DataHandler */
    /**
     * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
     * @param type a #GType
     */
    acceptsGType(type: GObject.Type): boolean
    /**
     * Get a short description of the GdaDataHandler
     */
    getDescr(): string
    /**
     * Creates a new GValue which holds a sane initial value to be used if no value is specifically
     * provided. For example for a simple string, this would return a new value containing the "" string.
     * @param type a #GType
     */
    getSaneInitValue(type: GObject.Type): any | null
    /**
     * Creates a new string which is an SQL representation of the given value, the returned string
     * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
     * the returned string will be correctly quoted. Note however that it is a better practice
     * to use variables in statements instead of value literals, see
     * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
     * 
     * If the value is NULL or is of type GDA_TYPE_NULL,
     * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
     * @param value the value to be converted to a string, or %NULL
     */
    getSqlFromValue(value?: any | null): string
    /**
     * Creates a new string which is a "user friendly" representation of the given value
     * (in the user's locale, specially for the dates). If the value is
     * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
     * 
     * Note: the returned value will be in the current locale representation.
     * @param value the value to be converted to a string, or %NULL
     */
    getStrFromValue(value?: any | null): string
    /**
     * Creates a new GValue which represents the SQL value given as argument. This is
     * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `sql` string does not correspond to a valid SQL string for the requested type, then
     * the %NULL is returned.
     * @param sql an SQL string, or %NULL
     * @param type a GType
     */
    getValueFromSql(sql: string | null, type: GObject.Type): any
    /**
     * Creates a new GValue which represents the `str` value given as argument. This is
     * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `str` string does not correspond to a valid string for the requested type, then
     * %NULL is returned.
     * 
     * Note: the `str` string must be in the current locale representation
     * @param str a string or %NULL
     * @param type a GType
     */
    getValueFromStr(str: string | null, type: GObject.Type): any
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     * 
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param forType a #GType type
     */
    static getDefault(forType: GObject.Type): DataHandler
}
class DataModel {
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    static name: string
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
}
class Lockable {
    /* Methods of Gda-5.0.Gda.Lockable */
    /**
     * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
     * by the other thread.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    lock(): void
    /**
     * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
     * it locks `lockable`.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    trylock(): boolean
    /**
     * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
     * used gda_lockable_lock() or gda_lockable_trylock()).
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     */
    unlock(): void
    static name: string
}
interface Batch_ConstructProps extends GObject.Object_ConstructProps {
}
class Batch {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Batch */
    /**
     * Add `stmt` to the list of statements managed by `batch`. A #GdaStatement object can be
     * added multiple times to a #GdaBatch object.
     * @param stmt a statement to add to `batch'`s statements list
     */
    addStatement(stmt: Statement): void
    /**
     * Copy constructor
     */
    copy(): Batch
    /**
     * Get a new #GdaSet object which groups all the execution parameters
     * which `batch` needs for all the statements it includes.
     * This new object is returned though `out_params`.
     * 
     * Note that if `batch` does not need any parameter, then `out_params` is set to %NULL.
     */
    getParameters(): [ /* returnType */ boolean, /* outParams */ Set | null ]
    /**
     * Get a list of the #GdaStatement objects contained in `batch`
     */
    getStatements(): Statement[]
    /**
     * Removes `stmt` from the list of statements managed by `batch`. If `stmt` is present several
     * times in `batch'`s statements' list, then only the first one is removed.
     * @param stmt a statement to remove from `batch'`s statements list
     */
    removeStatement(stmt: Statement): void
    /**
     * Creates a string representing the contents of `batch`.
     */
    serialize(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.Batch */
    /**
     * Gets emitted whenever a #GdaStatement in the `batch` object changes
     * @param changedStmt the statement which has been changed
     */
    connect(sigName: "changed", callback: ((changedStmt: GObject.Object) => void)): number
    on(sigName: "changed", callback: (changedStmt: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: (changedStmt: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: (changedStmt: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "changed", changedStmt: GObject.Object): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Batch_ConstructProps)
    _init (config?: Batch_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Batch
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface BlobOp_ConstructProps extends GObject.Object_ConstructProps {
}
class BlobOp {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.BlobOp */
    getLength(): number
    /**
     * Reads a chunk of bytes from the BLOB accessible through `op` into `blob`.
     * @param blob a #GdaBlob to read data to
     * @param offset offset to read from the start of the blob (starts at 0)
     * @param size maximum number of bytes to read.
     */
    read(blob: Blob, offset: number, size: number): number
    /**
     * Reads the whole contents of the blob manipulated by `op` into `blob`
     * @param blob a #GdaBlob to read data to
     */
    readAll(blob: Blob): boolean
    /**
     * Writes a chunk of bytes from a `blob` to the BLOB accessible through `op,` `blob` is unchanged after
     * this call.
     * 
     * If `blob` has an associated #GdaBlobOp (ie. if `blob->`op is not %NULL) then the data to be written
     * using `op` is the data fetched using `blob->`op.
     * @param blob a #GdaBlob which contains the data to write
     * @param offset offset to write from the start of the blob (starts at 0)
     */
    write(blob: Blob, offset: number): number
    /**
     * Writes the whole contents of `blob` into the blob manipulated by `op`. If necessary the resulting
     * blob is truncated from its previous length.
     * @param blob a #GdaBlob which contains the data to write
     */
    writeAll(blob: Blob): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BlobOp_ConstructProps)
    _init (config?: BlobOp_ConstructProps): void
    static $gtype: GObject.Type
}
interface Column_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.Column */
    id?: string
}
class Column {
    /* Properties of Gda-5.0.Gda.Column */
    id: string
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Column */
    /**
     * Creates a new #GdaColumn object from an existing one.
     */
    copy(): Column
    /**
     * Gets the 'allow null' flag of the given column.
     */
    getAllowNull(): boolean
    /**
     * Get the value associated to a named attribute.
     * 
     * Attributes can have any name, but Libgda proposes some default names, see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
     * @param attribute attribute name as a string
     */
    getAttribute(attribute: string): any
    getAutoIncrement(): boolean
    getDbmsType(): string
    getDefaultValue(): any | null
    getDescription(): string
    getGType(): GObject.Type
    getName(): string
    getPosition(): number
    /**
     * Sets the 'allow null' flag of the given column.
     * @param allow whether the given column should allows null values or not.
     */
    setAllowNull(allow: boolean): void
    /**
     * Set the value associated to a named attribute. The `attribute` string is 'stolen' by this method, and
     * the memory it uses will be freed using the `destroy` function when no longer needed (if `destroy` is %NULL,
     * then the string will not be freed at all).
     * 
     * Attributes can have any name, but Libgda proposes some default names,
     * see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
     * 
     * If there is already an attribute named `attribute` set, then its value is replaced with the new value (`value` is
     * copied), except if `value` is %NULL, in which case the attribute is removed.
     * 
     * For example one would use it as:
     * 
     * <code>
     * gda_column_set_attribute (holder, g_strdup (my_attribute), g_free, my_value);
     * gda_column_set_attribute (holder, GDA_ATTRIBUTE_NAME, NULL, my_value);
     * </code>
     * 
     * Note: this method does not modify in any way the contents of the data model for which `column` is a column (nor
     * does it modify the table definition of the tables used by a SELECT statement is the model was created from a
     * SELECT statement).
     * @param attribute attribute name as a static string
     * @param value a #GValue, or %NULL
     * @param destroy a function to be called when `attribute` is not needed anymore, or %NULL
     */
    setAttribute(attribute: string, value?: any | null, destroy?: GLib.DestroyNotify | null): void
    /**
     * Sets the auto increment flag for the given column.
     * @param isAuto auto increment status.
     */
    setAutoIncrement(isAuto: boolean): void
    /**
     * Defines `column'`s database type
     * @param dbmsType a string
     */
    setDbmsType(dbmsType: string): void
    /**
     * Sets `column'`s default #GValue.
     * @param defaultValue default #GValue for the column
     */
    setDefaultValue(defaultValue?: any | null): void
    /**
     * Sets the column's description
     * @param title title name.
     */
    setDescription(title: string): void
    /**
     * Sets the type of `column` to `type`.
     * @param type the new type of `column`.
     */
    setGType(type: GObject.Type): void
    /**
     * Sets the name of `column` to `name`.
     * @param name the new name of `column`.
     */
    setName(name: string): void
    /**
     * Sets the position of the column refer to in the containing
     * data model.
     * @param position the wanted position of the column in the containing data model.
     */
    setPosition(position: number): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.Column */
    /**
     * Gets emitted whenever `column'`s type has been changed
     * @param oldType the column's previous type
     * @param newType the column's new type
     */
    connect(sigName: "g-type-changed", callback: ((oldType: GObject.Type, newType: GObject.Type) => void)): number
    on(sigName: "g-type-changed", callback: (oldType: GObject.Type, newType: GObject.Type) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "g-type-changed", callback: (oldType: GObject.Type, newType: GObject.Type) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "g-type-changed", callback: (oldType: GObject.Type, newType: GObject.Type) => void): NodeJS.EventEmitter
    emit(sigName: "g-type-changed", oldType: GObject.Type, newType: GObject.Type): void
    /**
     * Gets emitted whenever `column'`s name has been changed
     * @param oldName the column's previous name
     */
    connect(sigName: "name-changed", callback: ((oldName: string) => void)): number
    on(sigName: "name-changed", callback: (oldName: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "name-changed", callback: (oldName: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "name-changed", callback: (oldName: string) => void): NodeJS.EventEmitter
    emit(sigName: "name-changed", oldName: string): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Column_ConstructProps)
    _init (config?: Column_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Column
    static $gtype: GObject.Type
}
interface Config_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.Config */
    /**
     * File to use for system-wide DSN list. When changed, the whole list of DSN will be reloaded.
     */
    systemFilename?: string
    /**
     * File to use for per-user DSN list. When changed, the whole list of DSN will be reloaded.
     */
    userFilename?: string
}
class Config {
    /* Properties of Gda-5.0.Gda.Config */
    /**
     * File to use for system-wide DSN list. When changed, the whole list of DSN will be reloaded.
     */
    systemFilename: string
    /**
     * File to use for per-user DSN list. When changed, the whole list of DSN will be reloaded.
     */
    userFilename: string
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.Config */
    /**
     * Gets emitted whenever a new DSN has been defined
     * @param newDsn a #GdaDsnInfo
     */
    connect(sigName: "dsn-added", callback: ((newDsn?: object | null) => void)): number
    on(sigName: "dsn-added", callback: (newDsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "dsn-added", callback: (newDsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "dsn-added", callback: (newDsn?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "dsn-added", newDsn?: object | null): void
    /**
     * Gets emitted whenever a DSN's definition has been changed
     * @param dsn a #GdaDsnInfo
     */
    connect(sigName: "dsn-changed", callback: ((dsn?: object | null) => void)): number
    on(sigName: "dsn-changed", callback: (dsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "dsn-changed", callback: (dsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "dsn-changed", callback: (dsn?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "dsn-changed", dsn?: object | null): void
    /**
     * Gets emitted whenever a DSN has been removed
     * @param oldDsn a #GdaDsnInfo
     */
    connect(sigName: "dsn-removed", callback: ((oldDsn?: object | null) => void)): number
    on(sigName: "dsn-removed", callback: (oldDsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "dsn-removed", callback: (oldDsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "dsn-removed", callback: (oldDsn?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "dsn-removed", oldDsn?: object | null): void
    /**
     * Gets emitted whenever a DSN is about to be removed
     * @param oldDsn a #GdaDsnInfo
     */
    connect(sigName: "dsn-to-be-removed", callback: ((oldDsn?: object | null) => void)): number
    on(sigName: "dsn-to-be-removed", callback: (oldDsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "dsn-to-be-removed", callback: (oldDsn?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "dsn-to-be-removed", callback: (oldDsn?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "dsn-to-be-removed", oldDsn?: object | null): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::system-filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::system-filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::system-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::system-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::system-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::user-filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::user-filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::user-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::user-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::user-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Config_ConstructProps)
    _init (config?: Config_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Tells if the global (system) configuration can be modified (considering
     * system permissions and settings)
     */
    static canModifySystemConfig(): boolean
    /**
     * Add or update a DSN from the definition in `info`.
     * 
     * This method may fail with a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
     * @param info a pointer to a filled GdaDsnInfo structure
     */
    static defineDsn(info: DsnInfo): boolean
    /**
     * Tells if the data source identified as `dsn_name` needs any authentication. If a &lt;username&gt;
     * and optionally a &lt;password&gt; are specified, they are ignored.
     * @param dsnName the name of a DSN, in the "[&lt;username&gt;[:&lt;password&gt;]`]`&lt;DSN&gt;" format
     */
    static dsnNeedsAuthentication(dsnName: string): boolean
    static errorQuark(): GLib.Quark
    /**
     * Get a pointer to the global (unique) #GdaConfig object. This functions increments
     * the reference count of the object, so you need to call g_object_unref() on it once finished.
     */
    static get(): Config
    /**
     * Get information about the DSN named `dsn_name`.
     * 
     * `dsn_name'`s format is "[&lt;username&gt;[:&lt;password&gt;]`]`&lt;DSN&gt;" (if &lt;username&gt;
     * and optionally &lt;password&gt; are provided, they are ignored). Also see the gda_dsn_split() utility
     * function.
     * @param dsnName the name of the DSN to look for
     */
    static getDsnInfo(dsnName: string): DsnInfo
    /**
     * Get a pointer to a read-only #GdaDsnInfo at the `index` position
     * @param index an index
     */
    static getDsnInfoAtIndex(index: number): DsnInfo
    /**
     * Get the index (starting at 0) of the DSN named `dsn_name`
     * @param dsnName a DSN
     */
    static getDsnInfoIndex(dsnName: string): number
    /**
     * Get the number of defined DSN
     */
    static getNbDsn(): number
    /**
     * Get a pointer to the session-wide #GdaServerProvider for the
     * provider named `provider_name`. The caller must not call g_object_unref() on the
     * returned object.
     * 
     * This method may fail with a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
     * @param providerName a database provider
     */
    static getProvider(providerName: string): ServerProvider
    /**
     * Get some information about the a database provider (adapter) named
     * @param providerName a database provider
     */
    static getProviderInfo(providerName: string): ProviderInfo
    /**
     * Get a #GdaDataModel representing all the configured DSN, and keeping itself up to date with
     * the changes in the declared DSN.
     * 
     * The returned data model is composed of the following columns:
     * <itemizedlist>
     *  <listitem><para>DSN name</para></listitem>
     *  <listitem><para>Provider name</para></listitem>
     *  <listitem><para>Description</para></listitem>
     *  <listitem><para>Connection string</para></listitem>
     *  <listitem><para>Username if it exists</para></listitem>
     * </itemizedlist>
     */
    static listDsn(): DataModel
    /**
     * Get a #GdaDataModel representing all the installed database providers.
     * 
     * The returned data model is composed of the following columns:
     * <itemizedlist>
     *  <listitem><para>Provider name</para></listitem>
     *  <listitem><para>Description</para></listitem>
     *  <listitem><para>DSN parameters</para></listitem>
     *  <listitem><para>Authentication parameters</para></listitem>
     *  <listitem><para>File name of the plugin</para></listitem>
     * </itemizedlist>
     */
    static listProviders(): DataModel
    /**
     * Remove the DSN named `dsn_name`.
     * 
     * This method may fail with a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
     * @param dsnName the name of the DSN to remove
     */
    static removeDsn(dsnName: string): boolean
    static $gtype: GObject.Type
}
interface Connection_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.Connection */
    authString?: string
    cncString?: string
    dsn?: string
    /**
     * Defines the number of #GdaConnectionEvent objects kept in memory which can
     * be fetched using gda_connection_get_events().
     */
    eventsHistorySize?: number
    /**
     * Artificially slows down the execution of queries. This property can be used to
     * debug some problems. If non zero, this value is the number of microseconds waited before actually
     * executing each query.
     */
    executionSlowdown?: number
    /**
     * Computes execution times for each statement executed.
     */
    executionTimer?: boolean
    /**
     * This property, if set to %TRUE, specifies that the connection is not a real connection, but rather
     * a #GdaConnection object which "proxies" all the calls to another connection which executes in a sub
     * thread.
     * 
     * Note: this property is used internally by Libgda and should not be directly used by any programs. Setting
     * this property has no effect, reading it is supported, though.
     */
    isWrapper?: boolean
    metaStore?: MetaStore
    /**
     * Useful only when there is a mainloop and when the connection acts as a thread wrapper around another connection,
     * it sets up a timeout to handle signals coming from the wrapped connection.
     * 
     * If the connection is not a thread wrapper, then this property has no effect.
     */
    monitorWrappedInMainloop?: boolean
    provider?: ServerProvider
    threadOwner?: object
}
class Connection {
    /* Properties of Gda-5.0.Gda.Connection */
    authString: string
    cncString: string
    dsn: string
    /**
     * Defines the number of #GdaConnectionEvent objects kept in memory which can
     * be fetched using gda_connection_get_events().
     */
    eventsHistorySize: number
    /**
     * Artificially slows down the execution of queries. This property can be used to
     * debug some problems. If non zero, this value is the number of microseconds waited before actually
     * executing each query.
     */
    executionSlowdown: number
    /**
     * Computes execution times for each statement executed.
     */
    executionTimer: boolean
    /**
     * This property, if set to %TRUE, specifies that the connection is not a real connection, but rather
     * a #GdaConnection object which "proxies" all the calls to another connection which executes in a sub
     * thread.
     * 
     * Note: this property is used internally by Libgda and should not be directly used by any programs. Setting
     * this property has no effect, reading it is supported, though.
     */
    isWrapper: boolean
    metaStore: MetaStore
    /**
     * Useful only when there is a mainloop and when the connection acts as a thread wrapper around another connection,
     * it sets up a timeout to handle signals coming from the wrapped connection.
     * 
     * If the connection is not a thread wrapper, then this property has no effect.
     */
    monitorWrappedInMainloop: boolean
    provider: ServerProvider
    threadOwner: object
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Connection */
    /**
     * Adds an event to the given connection. This function is usually
     * called by providers, to inform clients of events that happened
     * during some operation.
     * 
     * As soon as a provider (or a client, it does not matter) calls this
     * function with an `event` object which is an error,
     * the connection object emits the "error" signal, to which clients can connect to be
     * informed of events.
     * 
     * WARNING: the reference to the `event` object is stolen by this function!
     * @param event is stored internally, so you don't need to unref it.
     */
    addEvent(event: ConnectionEvent): void
    /**
     * Declares that `prepared_stmt` is a prepared statement object associated to `gda_stmt` within the connection
     * (meaning the connection increments the reference counter of `prepared_stmt)`.
     * 
     * If `gda_stmt` changes or is destroyed, the the association will be lost and the connection will lose the
     * reference it has on `prepared_stmt`.
     * @param gdaStmt a #GdaStatement object
     * @param preparedStmt a prepared statement object (as a #GdaPStmt object, or more likely a descendant)
     */
    addPreparedStatement(gdaStmt: Statement, preparedStmt: PStmt): void
    /**
     * Adds a SAVEPOINT named `name`.
     * @param name name of the savepoint to add
     */
    addSavepoint(name?: string | null): boolean
    /**
     * Requests that a task be cancelled. This operation may of may not have any effect
     * depending on the task's status, even if it returns %TRUE. If it returns %FALSE,
     * then the task has not been cancelled.
     * @param taskId a task ID returned by gda_connection_async_statement_execute()
     */
    asyncCancel(taskId: number): boolean
    /**
     * Use this method to obtain the result of the execution of a statement which has been executed asynchronously by
     * calling gda_connection_async_statement_execute(). This function is non locking and will return %NULL (and no
     * error will be set) if the statement has not been executed yet.
     * 
     * If the statement has been executed, this method returns the same value as gda_connection_statement_execute()
     * would have if the statement had been
     * executed synchronously.
     * @param taskId a task ID returned by gda_connection_async_statement_execute()
     */
    asyncFetchResult(taskId: number): [ /* returnType */ GObject.Object, /* lastInsertRow */ Set | null ]
    /**
     * This method is similar to gda_connection_statement_execute() but is asynchronous as it method returns
     * immediately with a task ID. It's up to the caller to use gda_connection_async_fetch_result() regularly to check
     * if the statement's execution is finished.
     * 
     * It is possible to call the method several times to request several statements to be executed asynchronously, the
     * statements will be executed in the order in which they were requested.
     * 
     * The parameters, if present, are copied and can be discarded or modified before the statement is actually executed.
     * The `stmt` object is not copied but simply referenced (for performance reasons), and if it is modified before
     * it is actually executed, then its execution will not occur. It is however safe to call g_object_unref() on it if
     * it's not needed anymore.
     * 
     * The execution failure of any statement has no impact on the execution of other statements except for example if
     * the connection has a transaction started and the failure invalidates the transaction (as decided by the database
     * server).
     * 
     * Note that for asynchronous calls to succeed, it is gererally necessary to specify the
     * %GDA_CONNECTION_OPTIONS_THREAD_ISOLATED flag when opening the connection to be sure it is opened in a separate thread
     * in which asynchronous calls are made (failing to use this flag make the asynchronous call dependant on the database
     * provider implementation and at the moment none support this feature).
     * @param stmt a #GdaStatement object
     * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
     * @param modelUsage in the case where `stmt` is a SELECT statement, specifies how the returned data model will be used
     * @param colTypes an array of GType to request each returned #GdaDataModel's column's GType, terminated with the G_TYPE_NONE
     * @param needLastInsertRow TRUE if the values of the last interted row must be computed
     */
    asyncStatementExecute(stmt: Statement, params: Set | null, modelUsage: StatementModelUsage, colTypes: GObject.Type[] | null, needLastInsertRow: boolean): number
    /**
     * Executes all the statements contained in `batch` (in the order in which they were added to `batch)`, and
     * returns a list of #GObject objects, at most one #GObject for each statement; see gda_connection_statement_execute()
     * for details about the returned objects.
     * 
     * If one of the statement fails, then none of the subsequent statement will be executed, and the method returns
     * the list of #GObject created by the correct execution of the previous statements. If a transaction is required,
     * then it should be started before calling this method.
     * @param batch a #GdaBatch object which contains all the statements to execute
     * @param params a #GdaSet object (which can be obtained using gda_batch_get_parameters()), or %NULL
     * @param modelUsage specifies how the returned data model(s) will be used, as a #GdaStatementModelUsage enum
     */
    batchExecute(batch: Batch, params: Set | null, modelUsage: StatementModelUsage): GObject.Object[]
    /**
     * Starts a transaction on the data source, identified by the
     * `name` parameter.
     * 
     * Before starting a transaction, you can check whether the underlying
     * provider does support transactions or not by using the
     * gda_connection_supports_feature() function.
     * @param name the name of the transation to start, or %NULL
     * @param level the requested transaction level (%GDA_TRANSACTION_ISOLATION_UNKNOWN if not specified)
     */
    beginTransaction(name: string | null, level: TransactionIsolation): boolean
    /**
     * This function lets you clear the list of #GdaConnectionEvent's of the
     * given connection.
     */
    clearEventsList(): void
    /**
     * Closes the connection to the underlying data source, but first emits the
     * "conn-to-close" signal.
     */
    close(): void
    /**
     * Closes the connection to the underlying data source, without emiting any warning signal.
     */
    closeNoWarning(): void
    /**
     * Commits the given transaction to the backend database. You need to call
     * gda_connection_begin_transaction() first.
     * @param name the name of the transation to commit, or %NULL
     */
    commitTransaction(name?: string | null): boolean
    /**
     * Creates a new #GdaServerOperation object which can be modified in order
     * to perform the type type of action. It is a wrapper around the gda_server_provider_create_operation()
     * method.
     * @param type the type of operation requested
     * @param options an optional list of parameters
     */
    createOperation(type: ServerOperationType, options?: Set | null): ServerOperation
    /**
     * Creates a new parser object able to parse the SQL dialect understood by `cnc`.
     * If the #GdaServerProvider object internally used by `cnc` does not have its own parser,
     * then %NULL is returned, and a general SQL parser can be obtained
     * using gda_sql_parser_new().
     */
    createParser(): SqlParser
    /**
     * Removes any prepared statement associated to `gda_stmt` in `cnc:` this undoes what
     * gda_connection_add_prepared_statement() does.
     * @param gdaStmt a #GdaStatement object
     */
    delPreparedStatement(gdaStmt: Statement): void
    /**
     * This is a convenience function, which creates a DELETE statement and executes it using the values
     * provided. It internally relies on variables which makes it immune to SQL injection problems.
     * 
     * The equivalent SQL command is: DELETE FROM &lt;table&gt; WHERE &lt;condition_column_name&gt; = &lt;condition_value&gt;.
     * @param table the table's name with the row's values to be updated
     * @param conditionColumnName the name of the column to used in the WHERE condition clause
     * @param conditionValue the `condition_column_type'`s GType
     */
    deleteRowFromTable(table: string, conditionColumnName: string, conditionValue: any): boolean
    /**
     * Delete the SAVEPOINT named `name` when not used anymore.
     * @param name name of the savepoint to delete
     */
    deleteSavepoint(name?: string | null): boolean
    /**
     * This is a convenience function to execute a SQL command over the opened connection. For the
     * returned value, see gda_connection_statement_execute_non_select()'s documentation.
     * @param sql a query statement that must not begin with "SELECT"
     */
    executeNonSelectCommand(sql: string): number
    /**
     * Execute a SQL SELECT command over an opened connection.
     * @param sql a query statement that must begin with "SELECT"
     */
    executeSelectCommand(sql: string): DataModel
    /**
     * Gets the user name used to open this connection.
     */
    getAuthentication(): string
    /**
     * Gets the connection string used to open this connection.
     * 
     * The connection string is the string sent over to the underlying
     * database provider, which describes the parameters to be used
     * to open a connection on the underlying data source.
     */
    getCncString(): string
    /**
     * This function allows you to determine the actual format for the date values.
     */
    getDateFormat(): [ /* returnType */ boolean, /* outFirst */ GLib.DateDMY | null, /* outSecond */ GLib.DateDMY | null, /* outThird */ GLib.DateDMY | null, /* outSep */ string | null ]
    getDsn(): string
    /**
     * Retrieves a list of the last errors occurred during the connection. The returned list is
     * chronologically ordered such as that the most recent event is the #GdaConnectionEvent of the first node.
     * 
     * Warning: the `cnc` object may change the list if connection events occur
     */
    getEvents(): ConnectionEvent[]
    /**
     * Get or initializes the #GdaMetaStore associated to `cnc`
     */
    getMetaStore(): MetaStore
    /**
     * see #gda_connection_get_meta_store_data
     * @param metaType describes which data to get.
     * @param filters a #GList of #GdaHolder objects
     */
    getMetaStoreDataV(metaType: ConnectionMetaType, filters: Holder[]): DataModel
    /**
     * Gets the #GdaConnectionOptions used to open this connection.
     */
    getOptions(): ConnectionOptions
    /**
     * Retrieves a pointer to an object representing a prepared statement for `gda_stmt` within `cnc`. The
     * association must have been done using gda_connection_add_prepared_statement().
     * @param gdaStmt a #GdaStatement object
     */
    getPreparedStatement(gdaStmt: Statement): PStmt
    /**
     * Gets a pointer to the #GdaServerProvider object used to access the database
     */
    getProvider(): ServerProvider
    /**
     * Gets the name (identifier) of the database provider used by `cnc`
     */
    getProviderName(): string
    /**
     * Get the status of `cnc` regarding transactions. The returned object should not be modified
     * or destroyed; however it may be modified or destroyed by the connection itself.
     * 
     * If %NULL is returned, then no transaction has been associated with `cnc`
     */
    getTransactionStatus(): TransactionStatus
    /**
     * `col_names` and `values` must have length (&gt;= 1).
     * 
     * This is a convenience function, which creates an INSERT statement and executes it using the values
     * provided. It internally relies on variables which makes it immune to SQL injection problems.
     * 
     * The equivalent SQL command is: INSERT INTO &lt;table&gt; (&lt;column_name&gt; [,...]) VALUES (&lt;column_name&gt; = &lt;new_value&gt; [,...]).
     * @param table table's name to insert into
     * @param colNames a list of column names (as const gchar *)
     * @param values a list of values (as #GValue)
     */
    insertRowIntoTableV(table: string, colNames: string[], values: any[]): boolean
    /**
     * Checks whether a connection is open or not.
     */
    isOpened(): boolean
    /**
     * Tries to open the connection.
     */
    open(): boolean
    /**
     * This function helps to parse a SQL string which uses parameters and store them at `params`.
     * @param sql an SQL command to parse, not %NULL
     */
    parseSqlString(sql: string): [ /* returnType */ Statement, /* params */ Set | null ]
    /**
     * Performs the operation described by `op` (which should have been created using
     * gda_connection_create_operation()). It is a wrapper around the gda_server_provider_perform_operation()
     * method.
     * @param op a #GdaServerOperation object
     */
    performOperation(op: ServerOperation): boolean
    /**
     * Use this method to get a pointer to the next available connection event which can then be customized
     * and taken into account using gda_connection_add_event().
     * @param type a #GdaConnectionEventType
     */
    pointAvailableEvent(type: ConnectionEventType): ConnectionEvent
    /**
     * Use this method to get a correctly quoted (if necessary) SQL identifier which can be used
     * in SQL statements, from `id`. If `id` is already correctly quoted for `cnc,` then a copy of `id`
     * may be returned.
     * 
     * This method may add double quotes (or other characters) around `id:`
     * <itemizedlist>
     *  <listitem><para>if `id` is a reserved SQL keyword (such as SELECT, INSERT, ...)</para></listitem>
     *  <listitem><para>if `id` contains non allowed characters such as spaces, or if it starts with a digit</para></listitem>
     *  <listitem><para>in any other event as necessary for `cnc,` depending on the the options passed when opening the `cnc`
     *            connection, and specifically the <link linkend="GDA-CONNECTION-OPTIONS-SQL-IDENTIFIERS-CASE-SENSITIVE:CAPS">
     *            GDA_CONNECTION_OPTIONS_SQL_IDENTIFIERS_CASE_SENSITIVE</link> option.</para></listitem>
     * </itemizedlist>
     * 
     * One can safely pass an already quoted `id` to this method, either with quoting characters allowed by `cnc` or using the
     * double quote (") character.
     * @param id an SQL identifier
     */
    quoteSqlIdentifier(id: string): string
    /**
     * Executes the statement upon which `rstmt` is built. Note that as several statements can actually be executed by this
     * method, it is recommended to be within a transaction.
     * 
     * If `error` is not %NULL and `stop_on_error` is %FALSE, then it may contain the last error which occurred.
     * @param rstmt a #GdaRepetitiveStatement object
     * @param modelUsage specifies how the returned data model will be used as a #GdaStatementModelUsage enum
     * @param colTypes an array of GType to request each returned GdaDataModel's column's GType, see gda_connection_statement_execute_select_full() for more information
     * @param stopOnError set to TRUE if the method has to stop on the first error.
     */
    repetitiveStatementExecute(rstmt: RepetitiveStatement, modelUsage: StatementModelUsage, colTypes: GObject.Type[] | null, stopOnError: boolean): GObject.Object[]
    /**
     * Rollback all the modifications made after the SAVEPOINT named `name`.
     * @param name name of the savepoint to rollback to
     */
    rollbackSavepoint(name?: string | null): boolean
    /**
     * Rollbacks the given transaction. This means that all changes
     * made to the underlying data source since the last call to
     * #gda_connection_begin_transaction() or #gda_connection_commit_transaction()
     * will be discarded.
     * @param name the name of the transation to commit, or %NULL
     */
    rollbackTransaction(name?: string | null): boolean
    /**
     * Executes `stmt`.
     * 
     * As `stmt` can, by design (and if not abused), contain only one SQL statement, the
     * return object will either be:
     * <itemizedlist>
     *   <listitem><para>a #GdaDataSelect object (which is also a #GdaDataModel) if `stmt` is a SELECT statement
     *             (usually a GDA_SQL_STATEMENT_SELECT, see #GdaSqlStatementType)
     *             containing the results of the SELECT. The resulting data model is by default read only, but
     *             modifications can be enabled, see the #GdaDataSelect's documentation for more information.</para></listitem>
     *   <listitem><para>a #GdaSet for any other SQL statement which correctly executed. In this case
     *        (if the provider supports it), then the #GdaSet may contain value holders named:
     *        <itemizedlist>
     *          <listitem><para>a (gint) #GdaHolder named "IMPACTED_ROWS"</para></listitem>
     *          <listitem><para>a (GObject) #GdaHolder named "EVENT" which contains a #GdaConnectionEvent</para></listitem>
     *        </itemizedlist></para></listitem>
     * </itemizedlist>
     * 
     * If `last_insert_row` is not %NULL and `stmt` is an INSERT statement, then it will contain (if the
     * provider used by `cnc` supports it) a new #GdaSet object composed of value holders named "+&lt;column number&gt;"
     * starting at column 0 which contain the actual inserted values. For example if a table is composed of an 'id' column
     * which is auto incremented and a 'name' column then the execution of a "INSERT INTO mytable (name) VALUES ('joe')"
     * query will return a #GdaSet with two holders:
     * <itemizedlist>
     *   <listitem><para>one with the '+0' ID which may for example contain 1 (note that its "name" property should be "id")</para></listitem>
     *   <listitem><para>one with the '+1' ID which will contain 'joe' (note that its "name" property should be "name")</para></listitem>
     * </itemizedlist>
     * 
     * This method may fail with a %GDA_SERVER_PROVIDER_ERROR domain error (see the #GdaServerProviderError error codes).
     * 
     * Note1: If `stmt` is a SELECT statement which has some parameters and  if `params` is %NULL, then the statement can't
     * be executed and this method will return %NULL.
     * 
     * Note2: If `stmt` is a SELECT statement which has some parameters and  if `params` is not %NULL but contains some
     * invalid parameters, then the statement can't be executed and this method will return %NULL, unless the
     * `model_usage` has the GDA_STATEMENT_MODEL_ALLOW_NOPARAM flag.
     * 
     * Note3: If `stmt` is a SELECT statement which has some parameters and  if `params` is not %NULL but contains some
     * invalid parameters and if `model_usage` has the GDA_STATEMENT_MODEL_ALLOW_NOPARAM flag, then the returned
     * data model will contain no row but will have all the correct columns (even though some of the columns might
     * report as GDA_TYPE_NULL). In this case, if (after this method call) any of `params'` parameters change
     * then the resulting data model will re-run itself, see the GdaDataSelect's
     * <link linkend="GdaDataSelect--auto-reset">auto-reset</link> property for more information.
     * 
     * Note4: if `model_usage` does not contain the GDA_STATEMENT_MODEL_RANDOM_ACCESS or
     * GDA_STATEMENT_MODEL_CURSOR_FORWARD flags, then the default will be to return a random access data model
     * 
     * Note5: If `stmt` is a SELECT statement which returns blob values (of type %GDA_TYPE_BLOB), then an implicit
     * transaction will have been started by the database provider, and it's up to the caller to close the transaction
     * (which will then be locked) once all the blob ressources have been
     * liberated (when the returned data model is destroyed). See the section about
     * <link linkend="gen:blobs">Binary large objects (BLOBs)</link> for more information.
     * 
     * Also see the <link linkend="limitations">provider's limitations</link>, and the
     * <link linkend="data-select">Advanced GdaDataSelect usage</link> sections.
     * @param stmt a #GdaStatement object
     * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
     * @param modelUsage in the case where `stmt` is a SELECT statement, specifies how the returned data model will be used
     */
    statementExecute(stmt: Statement, params: Set | null, modelUsage: StatementModelUsage): [ /* returnType */ GObject.Object, /* lastInsertRow */ Set | null ]
    /**
     * Executes a non-selection statement on the given connection.
     * 
     * This function returns the number of rows affected by the execution of `stmt,` or -1
     * if an error occurred, or -2 if the connection's provider does not return the number of rows affected.
     * 
     * This function is just a convenience function around the gda_connection_statement_execute()
     * function.
     * See the documentation of the gda_connection_statement_execute() for information
     * about the `params` list of parameters.
     * 
     * See gda_connection_statement_execute() form more information about `last_insert_row`.
     * @param stmt a #GdaStatement object.
     * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
     */
    statementExecuteNonSelect(stmt: Statement, params?: Set | null): [ /* returnType */ number, /* lastInsertRow */ Set | null ]
    /**
     * Executes a selection command on the given connection.
     * 
     * This function returns a #GdaDataModel resulting from the SELECT statement, or %NULL
     * if an error occurred.
     * 
     * This function is just a convenience function around the gda_connection_statement_execute()
     * function.
     * 
     * See the documentation of the gda_connection_statement_execute() for information
     * about the `params` list of parameters.
     * @param stmt a #GdaStatement object.
     * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
     */
    statementExecuteSelect(stmt: Statement, params?: Set | null): DataModel
    /**
     * Executes a selection command on the given connection.
     * 
     * This function returns a #GdaDataModel resulting from the SELECT statement, or %NULL
     * if an error occurred.
     * 
     * This function is just a convenience function around the gda_connection_statement_execute()
     * function.
     * 
     * See the documentation of the gda_connection_statement_execute() for information
     * about the `params` list of parameters.
     * @param stmt a #GdaStatement object.
     * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
     * @param modelUsage specifies how the returned data model will be used as a #GdaStatementModelUsage enum
     * @param colTypes an array of GType to request each returned #GdaDataModel's column's GType, terminated with the G_TYPE_NONE value. Any value left to 0 will make the database provider determine the real GType. `col_types` can also be %NULL if no column type is specified.
     */
    statementExecuteSelectFull(stmt: Statement, params: Set | null, modelUsage: StatementModelUsage, colTypes?: GObject.Type[] | null): DataModel
    /**
     * Ask the database accessed through the `cnc` connection to prepare the usage of `stmt`. This is only useful
     * if `stmt` will be used more than once (however some database providers may always prepare statements
     * before executing them).
     * 
     * This function is also useful to make sure `stmt` is fully understood by the database before actually executing it.
     * 
     * Note however that it is also possible that gda_connection_statement_prepare() fails when
     * gda_connection_statement_execute() does not fail (this will usually be the case with statements such as
     * <![CDATA["SELECT * FROM ##tablename::string"]]> because database usually don't allow variables to be used in place of a
     * table name).
     * @param stmt a #GdaStatement object
     */
    statementPrepare(stmt: Statement): boolean
    /**
     * Renders `stmt` as an SQL statement, adapted to the SQL dialect used by `cnc`
     * @param stmt a #GdaStatement object
     * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
     * @param flags SQL rendering flags, as #GdaStatementSqlFlag OR'ed values
     */
    statementToSql(stmt: Statement, params: Set | null, flags: StatementSqlFlag): [ /* returnType */ string, /* paramsUsed */ Holder[] | null ]
    /**
     * Asks the underlying provider for if a specific feature is supported.
     * @param feature feature to ask for.
     */
    supportsFeature(feature: ConnectionFeature): boolean
    /**
     * Updates `cnc'`s associated #GdaMetaStore. If `context` is not %NULL, then only the parts described by
     * `context` will be updated, and if it is %NULL, then the complete meta store will be updated. Detailed
     * explanations follow:
     * 
     * In order to keep the meta store's contents in a consistent state, the update process involves updating
     * the contents of all the tables related to one where the contents change. For example the "_columns"
     * table (which lists all the columns of a table) depends on the "_tables" table (which lists all the tables
     * in a schema), so if a row is added, removed or modified in the "_tables", then the "_columns" table's contents
     * needs to be updated as well regarding that row.
     * 
     * If `context` is %NULL, then the update process will simply overwrite any data that was present in all the
     * meta store's tables with new (up to date) data even if nothing has changed, without having to build the
     * tables' dependency tree. This is the recommended way of proceeding when dealing with a meta store which
     * might be outdated.
     * 
     * On the other hand, if `context` is not %NULL, then a tree of the dependencies has to be built (depending on
     * `context)` and only some parts of the meta store are updated following that dependencies tree. Specifying a
     * context may be useful for example in the following situations:
     * <itemizedlist>
     *   <listitem><para>One knows that a database object has changed (for example a table created), and
     *                   may use the `context` to request that only the information about that table be updated
     *             </para></listitem>
     *   <listitem><para>One is only interested in the list of views, and may request that only the information
     *                   about views may be updated</para></listitem>
     * </itemizedlist>
     * 
     * When `context` is not %NULL, and contains specified SQL identifiers (for example the "table_name" of the "_tables"
     * table), then each SQL identifier has to match the convention the #GdaMetaStore has adopted regarding
     * case sensitivity, using gda_connection_quote_sql_identifier() or gda_meta_store_sql_identifier_quote().
     * 
     * see the <link linkend="information_schema:sql_identifiers">
     * meta data section about SQL identifiers</link> for more information, and the documentation about the
     * gda_sql_identifier_quote() function which will be most useful.
     * 
     * Note however that usually <emphasis>more</emphasis> information will be updated than strictly requested by
     * the `context` argument.
     * 
     * For more information, see the <link linkend="information_schema">Database structure</link> section, and
     * the <link linkend="howto-meta2">Update the meta data about a table</link> howto.
     * @param context description of which part of `cnc'`s associated #GdaMetaStore should be updated, or %NULL
     */
    updateMetaStore(context?: MetaContext | null): boolean
    /**
     * `col_names` and `values` must have length (&gt;= 1).
     * 
     * This is a convenience function, which creates an UPDATE statement and executes it using the values
     * provided. It internally relies on variables which makes it immune to SQL injection problems.
     * 
     * The equivalent SQL command is: UPDATE &lt;table&gt; SET &lt;column_name&gt; = &lt;new_value&gt; [,...] WHERE &lt;condition_column_name&gt; = &lt;condition_value&gt;.
     * @param table the table's name with the row's values to be updated
     * @param conditionColumnName the name of the column to used in the WHERE condition clause
     * @param conditionValue the `condition_column_type'`s GType
     * @param colNames a list of column names (as const gchar *)
     * @param values a list of values (as #GValue)
     */
    updateRowInTableV(table: string, conditionColumnName: string, conditionValue: any, colNames: string[], values: any[]): boolean
    /**
     * Produces a fully quoted and escaped string from a GValue
     * @param from #GValue to convert from
     */
    valueToSqlString(from: any): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.Lockable */
    /**
     * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
     * by the other thread.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    lock(): void
    /**
     * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
     * it locks `lockable`.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    trylock(): boolean
    /**
     * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
     * used gda_lockable_lock() or gda_lockable_trylock()).
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     */
    unlock(): void
    /* Signals of Gda-5.0.Gda.Connection */
    /**
     * Gets emitted when the connection to the database has been closed
     */
    connect(sigName: "conn-closed", callback: (() => void)): number
    on(sigName: "conn-closed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "conn-closed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "conn-closed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "conn-closed"): void
    /**
     * Gets emitted when the connection has been opened to the database
     */
    connect(sigName: "conn-opened", callback: (() => void)): number
    on(sigName: "conn-opened", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "conn-opened", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "conn-opened", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "conn-opened"): void
    /**
     * Gets emitted when the connection to the database is about to be closed
     */
    connect(sigName: "conn-to-close", callback: (() => void)): number
    on(sigName: "conn-to-close", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "conn-to-close", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "conn-to-close", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "conn-to-close"): void
    /**
     * Gets emitted when the DSN used by `cnc` has been changed
     */
    connect(sigName: "dsn-changed", callback: (() => void)): number
    on(sigName: "dsn-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "dsn-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "dsn-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "dsn-changed"): void
    /**
     * Gets emitted whenever a connection event occurs. Check the nature of `event` to
     * see if it's an error or a simple notification
     * @param event a #GdaConnectionEvent object
     */
    connect(sigName: "error", callback: ((event: ConnectionEvent) => void)): number
    on(sigName: "error", callback: (event: ConnectionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "error", callback: (event: ConnectionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "error", callback: (event: ConnectionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "error", event: ConnectionEvent): void
    /**
     * Gets emitted when the transaction status of `cnc` has changed (a transaction has been
     * started, rolled back, a savepoint added,...)
     */
    connect(sigName: "transaction-status-changed", callback: (() => void)): number
    on(sigName: "transaction-status-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transaction-status-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transaction-status-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transaction-status-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::auth-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auth-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auth-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auth-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auth-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cnc-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cnc-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cnc-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cnc-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cnc-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::dsn", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dsn", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::dsn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::dsn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::dsn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::events-history-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::events-history-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::events-history-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::events-history-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::events-history-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::execution-slowdown", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::execution-slowdown", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::execution-slowdown", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::execution-slowdown", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::execution-slowdown", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::execution-timer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::execution-timer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::execution-timer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::execution-timer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::execution-timer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::is-wrapper", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-wrapper", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::is-wrapper", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::is-wrapper", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::is-wrapper", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::monitor-wrapped-in-mainloop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::monitor-wrapped-in-mainloop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::monitor-wrapped-in-mainloop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::monitor-wrapped-in-mainloop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::monitor-wrapped-in-mainloop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::thread-owner", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::thread-owner", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::thread-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::thread-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::thread-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Connection_ConstructProps)
    _init (config?: Connection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newFromDsn(dsn: string, authString: string | null, options: ConnectionOptions): Connection
    static newFromString(providerName: string | null, cncString: string, authString: string | null, options: ConnectionOptions): Connection
    static errorQuark(): GLib.Quark
    /**
     * This function is the way of opening database connections with libgda, using a pre-defined data source (DSN),
     * see gda_config_define_dsn() for more information about how to define a DSN. If you don't want to define
     * a DSN, it is possible to use gda_connection_open_from_string() instead of this method.
     * 
     * The `dsn` string must have the following format: "[&lt;username&gt;[:&lt;password&gt;]`]`&lt;DSN&gt;"
     * (if &lt;username&gt; and/or &lt;password&gt; are provided, and `auth_string` is %NULL, then these username
     * and passwords will be used). Note that if provided, &lt;username&gt; and &lt;password&gt;
     * must be encoded as per RFC 1738, see gda_rfc1738_encode() for more information.
     * 
     * The `auth_string` can contain the authentication information for the server
     * to accept the connection. It is a string containing semi-colon seperated named value, usually
     * like "USERNAME=...;PASSWORD=..." where the ... are replaced by actual values. Note that each
     * name and value must be encoded as per RFC 1738, see gda_rfc1738_encode() for more information.
     * 
     * The actual named parameters required depend on the provider being used, and that list is available
     * as the <parameter>auth_params</parameter> member of the #GdaProviderInfo structure for each installed
     * provider (use gda_config_get_provider_info() to get it). Also one can use the "gda-sql-5.0 -L" command to
     * list the possible named parameters.
     * 
     * This method may fail with a GDA_CONNECTION_ERROR domain error (see the #GdaConnectionError error codes)
     * or a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
     * @param dsn data source name.
     * @param authString authentication string, or %NULL
     * @param options options for the connection (see #GdaConnectionOptions).
     */
    static openFromDsn(dsn: string, authString: string | null, options: ConnectionOptions): Connection
    /**
     * Opens a connection given a provider ID and a connection string. This
     * allows applications to open connections without having to create
     * a data source (DSN) in the configuration. The format of `cnc_string` is
     * similar to PostgreSQL and MySQL connection strings. It is a semicolumn-separated
     * series of &lt;key&gt;=&lt;value&gt; pairs, where each key and value are encoded as per RFC 1738,
     * see gda_rfc1738_encode() for more information.
     * 
     * The possible keys depend on the provider, the "gda-sql-5.0 -L" command
     * can be used to list the actual keys for each installed database provider.
     * 
     * For example the connection string to open an SQLite connection to a database
     * file named "my_data.db" in the current directory would be <constant>"DB_DIR=.;DB_NAME=my_data"</constant>.
     * 
     * The `cnc_string` string must have the following format:
     * "[&lt;provider&gt;://][&lt;username&gt;[:&lt;password&gt;]`]`&lt;connection_params&gt;"
     * (if &lt;username&gt; and/or &lt;password&gt; are provided, and `auth_string` is %NULL, then these username
     * and passwords will be used, and if &lt;provider&gt; is provided and `provider_name` is %NULL then this
     * provider will be used). Note that if provided, &lt;username&gt;, &lt;password&gt; and  &lt;provider&gt;
     * must be encoded as per RFC 1738, see gda_rfc1738_encode() for more information.
     * 
     * The `auth_string` must contain the authentication information for the server
     * to accept the connection. It is a string containing semi-colon seperated named values, usually
     * like "USERNAME=...;PASSWORD=..." where the ... are replaced by actual values. Note that each
     * name and value must be encoded as per RFC 1738, see gda_rfc1738_encode() for more information.
     * 
     * The actual named parameters required depend on the provider being used, and that list is available
     * as the <parameter>auth_params</parameter> member of the #GdaProviderInfo structure for each installed
     * provider (use gda_config_get_provider_info() to get it). Similarly to the format of the connection
     * string, use the "gda-sql-5.0 -L" command to list the possible named parameters.
     * 
     * Additionally, it is possible to have the connection string
     * respect the "&lt;provider_name&gt;://&lt;real cnc string&gt;" format, in which case the provider name
     * and the real connection string will be extracted from that string (note that if `provider_name`
     * is not %NULL then it will still be used as the provider ID).\
     * 
     * This method may fail with a GDA_CONNECTION_ERROR domain error (see the #GdaConnectionError error codes)
     * or a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
     * @param providerName provider ID to connect to, or %NULL
     * @param cncString connection string.
     * @param authString authentication string, or %NULL
     * @param options options for the connection (see #GdaConnectionOptions).
     */
    static openFromString(providerName: string | null, cncString: string, authString: string | null, options: ConnectionOptions): Connection
    /**
     * Opens an SQLite connection even if the SQLite provider is not installed,
     * to be used by database providers which need a temporary database to store
     * some information.
     * @param directory the directory the database file will be in, or %NULL for the default TMP directory
     * @param filename the database file name
     * @param autoUnlink if %TRUE, then the database file will be removed afterwards
     */
    static openSqlite(directory: string | null, filename: string, autoUnlink: boolean): Connection
    /**
     * Extract the provider, connection parameters, username and password from `string`.
     * in `string,` the various parts are strings
     * which are expected to be encoded using an RFC 1738 compliant encoding. If they are specified,
     * the returned provider, username and password strings are correctly decoded.
     * 
     * For example all the following connection strings:
     * <programlisting><![CDATA[
     * PostgreSQL://meme:pass`DB_NAME=`mydb;HOST=server
     * PostgreSQL://meme`DB_NAME=`mydb;HOST=server;PASSWORD=pass
     * PostgreSQL://meme`DB_NAME=`mydb;PASSWORD=pass;HOST=server
     * PostgreSQL://meme`PASSWORD=`pass;DB_NAME=mydb;HOST=server
     * PostgreSQL://DB_NAME=mydb;HOST=server;USERNAME=meme;PASSWORD=pass
     * PostgreSQL://DB_NAME=mydb;HOST=server;PASSWORD=pass;USERNAME=meme
     * PostgreSQL://DB_NAME=mydb;USERNAME=meme;PASSWORD=pass;HOST=server
     * PostgreSQL://PASSWORD=pass;USERNAME=meme;DB_NAME=mydb;HOST=server
     * PostgreSQL://:pass`USERNAME=`meme;DB_NAME=mydb;HOST=server
     * PostgreSQL://:pass`DB_NAME=`mydb;HOST=server;USERNAME=meme]]></programlisting>
     * 
     * will return the following new strings (double quotes added here to delimit strings):
     * <programlisting><![CDATA[
     * out_cnc_params: "DB_NAME=mydb;HOST=server"
     * out_provider: "PostgreSQL"
     * out_username: "meme"
     * out_password: "pass"]]></programlisting>
     * @param string a string in the "[&lt;provider&gt;://][&lt;username&gt;[:&lt;password&gt;]`]`&lt;connection_params&gt;" form
     * @param outCncParams a place to store the new string containing the &lt;connection_params&gt; part
     * @param outProvider a place to store the new string containing the &lt;provider&gt; part
     * @param outUsername a place to store the new string containing the &lt;username&gt; part
     * @param outPassword a place to store the new string containing the &lt;password&gt; part, or %NULL
     */
    static stringSplit(string: string, outCncParams: string, outProvider: string, outUsername: string, outPassword?: string | null): void
    static $gtype: GObject.Type
}
interface ConnectionEvent_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.ConnectionEvent */
    type?: number
}
class ConnectionEvent {
    /* Properties of Gda-5.0.Gda.ConnectionEvent */
    type: number
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.ConnectionEvent */
    getCode(): number
    /**
     * Get the description of the event. Note that is `event'`s type is GDA_CONNECTION_EVENT_COMMAND,
     * the the description is the SQL of the command.
     */
    getDescription(): string
    /**
     * Get `event'`s severity (from a simple notice to a fatal event)
     */
    getEventType(): ConnectionEventType
    /**
     * Retrieve the code associated to `event`.
     */
    getGdaCode(): ConnectionEventCode
    getSource(): string
    /**
     * Get the SQLSTATE value of `event`. Even though the SQLSTATE values are specified by ANSI SQL and ODBC,
     * consult each DBMS for the possible values. However, the "00000" (success) value means that there is no error,
     * and the "HY000" (general error) value means an error but no better error code available.
     */
    getSqlstate(): string
    /**
     * Sets `event'`s code: the code is specific to the provider being used.
     * If you want to have a common understanding of the event codes, use
     * gda_connection_event_get_gda_code() instead.
     * 
     * This function should not be called directly
     * @param code a code.
     */
    setCode(code: number): void
    /**
     * Sets `event'`s `description`. This function should not be called directly.
     * @param description a description, or %NULL (to unset current description if any)
     */
    setDescription(description?: string | null): void
    /**
     * Sets `event'`s severity (from a simple notice to a fatal event)
     * This function should not be called directly.
     * @param type the severity of the event
     */
    setEventType(type: ConnectionEventType): void
    /**
     * Sets `event'`s gda code: that code is standardized by the libgda
     * library. If you want to specify the corresponding provider specific code,
     * use gda_connection_event_get_code() or gda_connection_event_get_sqlstate() instead.
     * 
     * This function should not be called directly
     * @param code a code
     */
    setGdaCode(code: ConnectionEventCode): void
    /**
     * Sets `event'`s `source;` this function should not be called directly
     * @param source a source.
     */
    setSource(source: string): void
    /**
     * Changes the SQLSTATE code of `event,` this function should not be called directly
     * 
     * Sets `event'`s SQL state.
     * @param sqlstate SQL state.
     */
    setSqlstate(sqlstate: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ConnectionEvent_ConstructProps)
    _init (config?: ConnectionEvent_ConstructProps): void
    static $gtype: GObject.Type
}
interface DataAccessWrapper_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataAccessWrapper */
    model?: DataModel
}
class DataAccessWrapper {
    /* Properties of Gda-5.0.Gda.DataAccessWrapper */
    readonly model: DataModel
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataAccessWrapper */
    /**
     * `wrapper` will report as many columns as `mapping_size,` and for each value at position 'i' in `mapping,`
     * `wrapper` will report the 'i'th column, mapped to the wrapped data model column at position mapping[i].
     * For example if mapping is {3, 4, 0}, then `wrapper` will report 3 columns, respectively mapped to the 4th,
     * 5th and 1st columns of the wrapped data model (as column numbers start at 0).
     * 
     * If `mapping` is %NULL, then no mapping is done and `wrapper'`s columns will be the same as the wrapped
     * data model.
     * 
     * If a column in `mapping` does not exist in the wrapped data model, then it is simply ignored (no error
     * reported).
     * 
     * Please note that if `wrapper` has already been used and if the wrapped data model offers a cursor forward
     * access mode, then this method will return %FALSE and no action will be done.
     * 
     * If the mapping is applied, then any existing iterator will be invalid, and `wrapper` is reset as if it
     * had just been created.
     * @param mapping an array of #gint which represents the mapping between `wrapper'`s columns and the columns of the wrapped data model
     */
    setMapping(mapping: number[] | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataAccessWrapper_ConstructProps)
    _init (config?: DataAccessWrapper_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataComparator_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataComparator */
    newModel?: DataModel
    oldModel?: DataModel
}
class DataComparator {
    /* Properties of Gda-5.0.Gda.DataComparator */
    newModel: DataModel
    oldModel: DataModel
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataComparator */
    /**
     * Actually computes the differences between the data models for which `comp` is defined.
     * 
     * For each difference computed, stored in a #GdaDiff structure, the "diff-computed" signal is emitted.
     * If one connects to this signal and returns FALSE in the signal handler, then computing differences will be
     * stopped and an error will be returned.
     */
    computeDiff(): boolean
    /**
     * Get a pointer to the #GdaDiff structure representing the difference which number is `pos`
     * @param pos the requested difference number (starting at 0)
     */
    getDiff(pos: number): Diff
    /**
     * Get the number of differences as computed by the last time gda_data_comparator_compute_diff() was called.
     */
    getNDiffs(): number
    /**
     * Defines the columns which will be used as a key when searching data. This is not mandatory but
     * will speed things up as less data will be processed.
     * @param colNumbers an array of `nb_cols` values
     */
    setKeyColumns(colNumbers: number[]): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.DataComparator */
    connect(sigName: "diff-computed", callback: ((object?: object | null) => boolean)): number
    on(sigName: "diff-computed", callback: (object?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "diff-computed", callback: (object?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "diff-computed", callback: (object?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "diff-computed", object?: object | null): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::new-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::new-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::new-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::new-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::new-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::old-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::old-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::old-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::old-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::old-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataComparator_ConstructProps)
    _init (config?: DataComparator_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(oldModel: DataModel, newModel: DataModel): DataComparator
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataModelArray_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataModelArray */
    nColumns?: number
    readOnly?: boolean
}
class DataModelArray {
    /* Properties of Gda-5.0.Gda.DataModelArray */
    nColumns: number
    readOnly: boolean
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataModelArray */
    /**
     * Frees all the rows in `model`.
     */
    clear(): void
    /**
     * Get a pointer to a row in `model`
     * @param row row number (starting from 0)
     */
    getRow(row: number): Row
    /**
     * Sets the number of columns for rows inserted in this model.
     * `cols` must be greated than or equal to 0.
     * 
     * Also clears `model'`s contents.
     * @param cols number of columns for rows this data model should use.
     */
    setNColumns(cols: number): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::n-columns", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-columns", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-columns", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-columns", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-columns", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::read-only", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::read-only", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::read-only", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::read-only", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::read-only", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataModelArray_ConstructProps)
    _init (config?: DataModelArray_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataModelDir_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataModelDir */
    basedir?: string
}
class DataModelDir {
    /* Properties of Gda-5.0.Gda.DataModelDir */
    readonly basedir: string
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataModelDir */
    /**
     * Reset the list of errors which have occurred while using `model`
     */
    cleanErrors(): void
    /**
     * Get the list of errors which have occurred while using `model`
     */
    getErrors(): GLib.Error[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::basedir", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::basedir", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::basedir", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::basedir", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::basedir", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataModelDir_ConstructProps)
    _init (config?: DataModelDir_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataModelImport_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataModelImport */
    /**
     * Data to import, as a string.
     */
    dataString?: string
    /**
     * Name of the file to import.
     */
    filename?: string
    /**
     * Data model options.
     */
    options?: Set
    /**
     * Defines if the data model will be accessed randomly or through a cursor. If set to %FALSE,
     * access will have to be done using a cursor.
     */
    randomAccess?: boolean
    /**
     * Defines the behaviour in case the imported data contains recoverable errors (usually too
     * many or too few data per row). If set to %TRUE, an error will be reported and the import
     * will stop, and if set to %FALSE, then the error will be reported but the import will not stop.
     */
    strict?: boolean
    /**
     * Data to import, as a pointer to an XML node (a #xmlNodePtr).
     */
    xmlNode?: object
}
class DataModelImport {
    /* Properties of Gda-5.0.Gda.DataModelImport */
    /**
     * Data to import, as a string.
     */
    readonly dataString: string
    /**
     * Name of the file to import.
     */
    readonly filename: string
    /**
     * Data model options.
     */
    readonly options: Set
    /**
     * Defines if the data model will be accessed randomly or through a cursor. If set to %FALSE,
     * access will have to be done using a cursor.
     */
    readonly randomAccess: boolean
    /**
     * Defines the behaviour in case the imported data contains recoverable errors (usually too
     * many or too few data per row). If set to %TRUE, an error will be reported and the import
     * will stop, and if set to %FALSE, then the error will be reported but the import will not stop.
     */
    strict: boolean
    /**
     * Data to import, as a pointer to an XML node (a #xmlNodePtr).
     */
    readonly xmlNode: object
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataModelImport */
    /**
     * Clears the history of errors `model` has to report
     */
    cleanErrors(): void
    /**
     * Get the list of errors which `model` has to report. The returned list is a list of
     * #GError structures, and must not be modified
     */
    getErrors(): GLib.Error[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::data-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::data-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::data-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::data-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::data-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::options", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::options", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::options", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::options", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::options", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::random-access", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::random-access", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::random-access", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::random-access", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::random-access", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::strict", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::strict", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::strict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::strict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::strict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::xml-node", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::xml-node", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::xml-node", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::xml-node", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::xml-node", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataModelImport_ConstructProps)
    _init (config?: DataModelImport_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Creates a new #GdaDataModel object which contains the data stored within the `filename` file.
     * 
     * The options are the following ones:
     * <itemizedlist>
     *   <listitem><para>For the CSV format:
     *      <itemizedlist>
     *         <listitem><para>ENCODING (string): specifies the encoding of the data in the file</para></listitem>
     *         <listitem><para>SEPARATOR (string): specifies the CSV separator (comma as default)</para></listitem>
     *         <listitem><para>QUOTE (string): specifies the character used as quote (double quote as default)</para></listitem>
     *         <listitem><para>NAMES_ON_FIRST_LINE (boolean): consider that the first line of the file contains columns' titles (note that the TITLE_AS_FIRST_LINE option is also accepted as a synonym)</para></listitem>
     *         <listitem><para>G_TYPE_&lt;column number&gt; (GType): specifies the type of value expected in column &lt;column number&gt;</para></listitem>
     *      </itemizedlist>
     *   </para></listitem>
     *   <listitem><para>Other formats: no option</para></listitem>
     * </itemizedlist>
     * 
     * Note: after the creation, please use gda_data_model_import_get_errors() to check any error.
     * @param filename the file to import data from
     * @param randomAccess TRUE if random access will be required
     * @param options importing options
     */
    static newFile(filename: string, randomAccess: boolean, options?: Set | null): DataModel
    /**
     * Creates a new #GdaDataModel object which contains the data stored in the `data` string.
     * 
     * Important note: the `data` string is not copied for memory efficiency reasons and should not
     * therefore be altered in any way as long as the returned data model exists.
     * @param data a string containing the data to import
     * @param randomAccess TRUE if random access will be required
     * @param options importing options, see gda_data_model_import_new_file() for more information
     */
    static newMem(data: string, randomAccess: boolean, options?: Set | null): DataModel
    /**
     * Creates a new #GdaDataModel and loads the data in `node`. The resulting data model
     * can be accessed in a random way.
     * @param node an XML node corresponding to a &lt;data-array&gt; tag
     */
    static newXmlNode(node: libxml2.NodePtr): DataModel
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataModelIter_ConstructProps extends Set_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataModelIter */
    currentRow?: number
    dataModel?: DataModel
    forcedModel?: DataModel
    updateModel?: boolean
}
class DataModelIter {
    /* Properties of Gda-5.0.Gda.DataModelIter */
    currentRow: number
    dataModel: DataModel
    forcedModel: DataModel
    updateModel: boolean
    /* Properties of Gda-5.0.Gda.Set */
    description: string
    id: string
    name: string
    /**
     * Defines if the "validate-set" signal gets emitted when
     * any holder in the data set changes. This property also affects the
     * GdaHolder:validate-changes property.
     */
    validateChanges: boolean
    /* Fields of Gda-5.0.Gda.Set */
    object: GObject.Object
    priv: SetPrivate
    /**
     * list of GdaHolder objects
     */
    holders: Holder[]
    /**
     * list of GdaSetNode
     */
    nodesList: SetNode[]
    /**
     * list of GdaSetSource
     */
    sourcesList: SetSource[]
    /**
     * list of GdaSetGroup
     */
    groupsList: SetGroup[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataModelIter */
    /**
     * Get the column number in the #GdaDataModel for which `iter` is an iterator as
     * represented by the `param` parameter
     * @param param a #GdaHolder object, listed in `iter`
     */
    getColumnForParam(param: Holder): number
    /**
     * Fetch a pointer to the #GdaHolder object which is synchronized with data at
     * column `col`
     * @param col the requested column
     */
    getHolderForField(col: number): Holder
    /**
     * Get the row which `iter` represents in the data model
     */
    getRow(): number
    /**
     * Get the value stored at the column `col` in `iter`. The returned value must not be modified.
     * @param col the requested column
     */
    getValueAt(col: number): any | null
    /**
     * Get the value stored at the column `col` in `iter`. The returned value must not be modified.
     * @param col the requested column
     */
    getValueAtE(col: number): any | null
    /**
     * Get the value stored at the column `field_name` in `iter`
     * @param fieldName the requested column name
     */
    getValueForField(fieldName: string): any | null
    /**
     * Declare all the parameters in `iter` invalid, without modifying the
     * #GdaDataModel `iter` is for or changing the row it represents. This method
     * is for internal usage. Note that for gda_data_model_iter_is_valid() to return %FALSE,
     * it is also necessary to set the "current-row" property to -1.
     */
    invalidateContents(): void
    /**
     * Tells if `iter` is a valid iterator (if it actually corresponds to a valid row in the model)
     */
    isValid(): boolean
    /**
     * Moves `iter` one row further than where it already is
     * (synchronizes the values of the parameters in `iter` with the values at the new row).
     * 
     * If the iterator was on the data model's last row, then it can't be moved forward
     * anymore, and the returned value is %FALSE; note also that the "current-row" property
     * is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE)
     * 
     * This function can return %FALSE if it was not allowed to be moved (as it emits the
     * "validate-set" signal before being moved).
     * 
     * When this function returns %TRUE, then `iter` has actually been moved to the next row,
     * but some values may not have been read correctly in the row, in which case the
     * correcsponding #GdaHolder will be left invalid.
     */
    moveNext(): boolean
    /**
     * Moves `iter` one row before where it already is (synchronizes the values of the parameters in `iter`
     * with the values at the new row).
     * 
     * If the iterator was on the data model's first row, then it can't be moved backwards
     * anymore, and the returned value is %FALSE; note also that the "current-row" property
     * is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE).
     * 
     * This function can return %FALSE if it was not allowed to be moved (as it emits the
     * "validate-set" signal before being moved).
     * 
     * When this function returns %TRUE, then `iter` has actually been moved to the next row,
     * but some values may not have been read correctly in the row, in which case the
     * correcsponding #GdaHolder will be left invalid.
     */
    movePrev(): boolean
    /**
     * Synchronizes the values of the parameters in `iter` with the values at the `row` row.
     * 
     * If `row` is not a valid row, then the returned value is %FALSE, and the "current-row"
     * property is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE),
     * with the exception that if `row` is -1, then the returned value is %TRUE.
     * 
     * This function can return %FALSE if it was not allowed to be moved (as it emits the
     * "validate-set" signal before being moved).
     * 
     * When this function returns %TRUE, then `iter` has actually been moved to the next row,
     * but some values may not have been read correctly in the row, in which case the
     * correcsponding #GdaHolder will be left invalid.
     * @param row the row to set `iter` to
     */
    moveToRow(row: number): boolean
    /**
     * Sets a value in `iter,` at the column specified by `col`
     * @param col the column number
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, value: any): boolean
    /* Methods of Gda-5.0.Gda.Set */
    /**
     * Adds `holder` to the list of holders managed within `set`.
     * 
     * NOTE: if `set` already has a #GdaHolder with the same ID as `holder,` then `holder`
     * will not be added to the set (even if `holder'`s type or value is not the same as the
     * one already in `set)`.
     * @param holder a #GdaHolder object
     */
    addHolder(holder: Holder): boolean
    /**
     * Creates a new #GdaSet object, copy of `set`
     */
    copy(): Set
    /**
     * Finds a #GdaSetGroup which lists a  #GdaSetNode containing `holder,`
     * don't modify the returned structure.
     * @param holder a #GdaHolder object
     */
    getGroup(holder: Holder): SetGroup
    /**
     * Finds a #GdaHolder using its ID
     * @param holderId the ID of the requested value holder
     */
    getHolder(holderId: string): Holder
    /**
     * Get the value of the #GdaHolder which ID is `holder_id`
     * @param holderId the ID of the holder to set the value
     */
    getHolderValue(holderId: string): any | null
    /**
     * Finds a #GdaSetNode holding information for `holder,` don't modify the returned structure
     * @param holder a #GdaHolder object
     */
    getNode(holder: Holder): SetNode
    /**
     * Finds a #GdaHolder using its position
     * @param pos the position of the requested #GdaHolder, starting at %0
     */
    getNthHolder(pos: number): Holder
    /**
     * Finds a #GdaSetSource which contains the #GdaDataModel restricting the possible values of
     * `holder,` don't modify the returned structure.
     * @param holder a #GdaHolder object
     */
    getSource(holder: Holder): SetSource
    /**
     * Finds the #GdaSetSource structure used in `set` for which `model` is a
     * the data model (the returned structure should not be modified).
     * @param model a #GdaDataModel object
     */
    getSourceForModel(model: DataModel): SetSource
    /**
     * Add to `set` all the holders of `set_to_merge`.
     * Note1: only the #GdaHolder of `set_to_merge` for which no holder in `set` has the same ID are merged
     * Note2: all the #GdaHolder merged in `set` are still used by `set_to_merge`.
     * @param setToMerge a #GdaSet object
     */
    mergeWithSet(setToMerge: Set): void
    /**
     * Removes a #GdaHolder from the list of holders managed by `set`
     * @param holder the #GdaHolder to remove from `set`
     */
    removeHolder(holder: Holder): void
    /**
     * Replaces `source->`data_model with `model,` which must have the same
     * characteristics as `source->`data_model (same column types)
     * 
     * Also for each #GdaHolder for which `source->`data_model is a source model,
     * this method calls gda_holder_set_source_model() with `model` to replace
     * the source by the new model
     * @param source a pointer to a #GdaSetSource in `set`
     * @param model a #GdaDataModel
     */
    replaceSourceModel(source: SetSource, model: DataModel): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.DataModelIter */
    /**
     * Gets emitted when `iter` has reached the end of available data (which means the previous
     * row it was on was the last one).
     */
    connect(sigName: "end-of-data", callback: (() => void)): number
    on(sigName: "end-of-data", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "end-of-data", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "end-of-data", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "end-of-data"): void
    /**
     * Gets emitted when the row `iter` is currently pointing has changed
     * @param row the new iter's row
     */
    connect(sigName: "row-changed", callback: ((row: number) => void)): number
    on(sigName: "row-changed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-changed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-changed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-changed", row: number): void
    /* Signals of Gda-5.0.Gda.Set */
    /**
     * Gets emitted when an attribute for any of the #GdaHolder objects managed by `set` has changed
     * @param holder the GdaHolder for which an attribute changed
     * @param attrName attribute's name
     * @param attrValue attribute's value
     */
    connect(sigName: "holder-attr-changed", callback: ((holder: Holder, attrName: string, attrValue: any) => void)): number
    on(sigName: "holder-attr-changed", callback: (holder: Holder, attrName: string, attrValue: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "holder-attr-changed", callback: (holder: Holder, attrName: string, attrValue: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "holder-attr-changed", callback: (holder: Holder, attrName: string, attrValue: any) => void): NodeJS.EventEmitter
    emit(sigName: "holder-attr-changed", holder: Holder, attrName: string, attrValue: any): void
    connect(sigName: "holder-changed", callback: ((object: Holder) => void)): number
    on(sigName: "holder-changed", callback: (object: Holder) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "holder-changed", callback: (object: Holder) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "holder-changed", callback: (object: Holder) => void): NodeJS.EventEmitter
    emit(sigName: "holder-changed", object: Holder): void
    /**
     * Gets emitted when `holder` in `set` has its type finally set, in case
     * it was #GDA_TYPE_NULL
     * @param holder the #GdaHolder for which the #GType has been set
     */
    connect(sigName: "holder-type-set", callback: ((holder: Holder) => void)): number
    on(sigName: "holder-type-set", callback: (holder: Holder) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "holder-type-set", callback: (holder: Holder) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "holder-type-set", callback: (holder: Holder) => void): NodeJS.EventEmitter
    emit(sigName: "holder-type-set", holder: Holder): void
    /**
     * Gets emitted when `set'`s public data (#GdaSetNode, #GdaSetGroup or #GdaSetSource values) have changed
     */
    connect(sigName: "public-data-changed", callback: (() => void)): number
    on(sigName: "public-data-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "public-data-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "public-data-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "public-data-changed"): void
    /**
     * Gets emitted when the data model in `source` has changed
     * @param source the #GdaSetSource for which the `data_model` attribute has changed
     */
    connect(sigName: "source-model-changed", callback: ((source?: object | null) => void)): number
    on(sigName: "source-model-changed", callback: (source?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "source-model-changed", callback: (source?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "source-model-changed", callback: (source?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "source-model-changed", source?: object | null): void
    /**
     * Gets emitted when a #GdaHolder's in `set` is going to change its value. One can connect to
     * this signal to control which values `holder` can have (for example to implement some business rules)
     * @param holder the #GdaHolder which is going to change
     * @param newValue the proposed new value for `holder`
     */
    connect(sigName: "validate-holder-change", callback: ((holder: Holder, newValue: any) => GLib.Error)): number
    on(sigName: "validate-holder-change", callback: (holder: Holder, newValue: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "validate-holder-change", callback: (holder: Holder, newValue: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "validate-holder-change", callback: (holder: Holder, newValue: any) => void): NodeJS.EventEmitter
    emit(sigName: "validate-holder-change", holder: Holder, newValue: any): void
    /**
     * Gets emitted when gda_set_is_valid() is called, use
     * this signal to control which combination of values `set'`s holder can have (for example to implement some business rules)
     */
    connect(sigName: "validate-set", callback: (() => GLib.Error)): number
    on(sigName: "validate-set", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "validate-set", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "validate-set", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "validate-set"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::current-row", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-row", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::current-row", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::current-row", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::current-row", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::data-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::data-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::data-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::data-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::data-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::forced-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::forced-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::forced-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::forced-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::forced-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::update-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::update-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::update-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::update-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::update-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::validate-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::validate-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataModelIter_ConstructProps)
    _init (config?: DataModelIter_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataModelLdap_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataModelLdap */
    attributes?: string
    base?: string
    cnc?: Connection
    filter?: string
    scope?: number
}
class DataModelLdap {
    /* Properties of Gda-5.0.Gda.DataModelLdap */
    readonly attributes: string
    readonly base: string
    readonly cnc: Connection
    readonly filter: string
    readonly scope: number
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::attributes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::attributes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::base", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::base", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::base", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::base", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::base", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cnc", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cnc", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cnc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cnc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cnc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scope", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scope", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scope", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scope", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scope", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataModelLdap_ConstructProps)
    _init (config?: DataModelLdap_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newWithConfig(cnc: Connection, baseDn: string | null, filter: string | null, attributes: string | null, scope: LdapSearchScope): DataModelLdap
    /**
     * Computes the #GdaColumn of the data model which would be created using `attributes` when calling
     * gda_data_model_ldap_new().
     * @param cnc a #GdaConnection
     * @param attributes a string describing which LDAP attributes to retreive, or %NULL
     */
    static computeColumns(cnc: Connection, attributes?: string | null): Column[]
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataPivot_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataPivot */
    model?: DataModel
}
class DataPivot {
    /* Properties of Gda-5.0.Gda.DataPivot */
    model: DataModel
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataPivot */
    /**
     * Specifies that `field` has to be included in the analysis.
     * `field` is a field specification with the following accepted syntaxes:
     * <itemizedlist>
     *   <listitem><para>a column name in the source data model (see <link linkend="gda-data-model-get-column-index">gda_data_model_get_column_index()</link>); or</para></listitem>
     *   <listitem><para>an SQL expression involving a column name in the source data model, for examples:
     *   <programlisting>
     * price
     * firstname || ' ' || lastname
     * nb BETWEEN 5 AND 10</programlisting>
     * </para></listitem>
     * </itemizedlist>
     * 
     * It is also possible to specify several fields to be added, while separating them by a comma (in effect
     * still forming a valid SQL syntax).
     * @param aggregateType the type of aggregate operation to perform
     * @param field the field description, see below
     * @param alias the field alias, or %NULL
     */
    addData(aggregateType: DataPivotAggregate, field: string, alias?: string | null): boolean
    /**
     * Specifies that `field` has to be included in the analysis.
     * `field` is a field specification with the following accepted syntaxes:
     * <itemizedlist>
     *   <listitem><para>a column name in the source data model (see <link linkend="gda-data-model-get-column-index">gda_data_model_get_column_index()</link>); or</para></listitem>
     *   <listitem><para>an SQL expression involving a column name in the source data model, for example:
     *   <programlisting>
     * price
     * firstname || ' ' || lastname
     * nb BETWEEN 5 AND 10</programlisting>
     * </para></listitem>
     * </itemizedlist>
     * 
     * It is also possible to specify several fields to be added, while separating them by a comma (in effect
     * still forming a valid SQL syntax).
     * @param fieldType the type of field to add
     * @param field the field description, see below
     * @param alias the field alias, or %NULL
     */
    addField(fieldType: DataPivotFieldType, field: string, alias?: string | null): boolean
    /**
     * Acutally populates `pivot` by analysing the data from the provided data model.
     */
    populate(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataPivot_ConstructProps)
    _init (config?: DataPivot_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataProxy_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataProxy */
    /**
     * Defines how changes kept in the data proxy are handled when the proxied data model
     * is changed (using the "model" property). The default is to silently discard all the
     * changes, but if this property is set to %TRUE, then the changes are cached.
     * 
     * If set to %TRUE, each cached change will be re-applied to a newly set proxied data model if
     * the change's number of columns match the proxied data model's number of columns and based on:
     * <itemizedlist>
     *   <listitem><para>the contents of the proxied data model's modified row for updates and deletes</para></listitem>
     *   <listitem><para>the inserts are always kept</para></listitem>
     * </itemizedlist>
     */
    cacheChanges?: boolean
    deferSync?: boolean
    model?: DataModel
    prependNullEntry?: boolean
    sampleSize?: number
}
class DataProxy {
    /* Properties of Gda-5.0.Gda.DataProxy */
    /**
     * Defines how changes kept in the data proxy are handled when the proxied data model
     * is changed (using the "model" property). The default is to silently discard all the
     * changes, but if this property is set to %TRUE, then the changes are cached.
     * 
     * If set to %TRUE, each cached change will be re-applied to a newly set proxied data model if
     * the change's number of columns match the proxied data model's number of columns and based on:
     * <itemizedlist>
     *   <listitem><para>the contents of the proxied data model's modified row for updates and deletes</para></listitem>
     *   <listitem><para>the inserts are always kept</para></listitem>
     * </itemizedlist>
     */
    cacheChanges: boolean
    deferSync: boolean
    model: DataModel
    prependNullEntry: boolean
    sampleSize: number
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataProxy */
    /**
     * Alters the attributes of the value stored at (proxy_row, col) in `proxy`. the `alter_flags`
     * can only contain the GDA_VALUE_ATTR_IS_NULL, GDA_VALUE_ATTR_IS_DEFAULT and GDA_VALUE_ATTR_IS_UNCHANGED
     * flags (other flags are ignored).
     * @param proxyRow A proxy row number
     * @param col a valid column number
     * @param alterFlags flags to alter the attributes
     */
    alterValueAttributes(proxyRow: number, col: number, alterFlags: ValueAttribute): void
    /**
     * Apply all the changes stored in the proxy to the proxied data model. The changes are done row
     * after row, and if an error
     * occurs, then it is possible that not all the changes to all the rows have been applied.
     */
    applyAllChanges(): boolean
    /**
     * Commits the modified data in the proxy back into the #GdaDataModel.
     * @param proxyRow the row number to commit
     */
    applyRowChanges(proxyRow: number): boolean
    /**
     * Cancel all the changes stored in the proxy (the `proxy` will be reset to its state
     * as it was just after creation). Note that if there are some cached changes (i.e. not applied
     * to the current proxied data model), then these cached changes are not cleared (set the "cache-changes"
     * property to %FALSE for this).
     */
    cancelAllChanges(): boolean
    /**
     * Resets data at the corresponding row and column. If `proxy_row` corresponds to a new row, then
     * that new row is deleted from `proxy`.
     * @param proxyRow the row to cancel changes
     * @param col the column to cancel changes, or less than 0 to cancel any change on the `row` row
     */
    cancelRowChanges(proxyRow: number, col: number): void
    /**
     * Marks the row `proxy_row` to be deleted
     * @param proxyRow A proxy row number
     */
    delete(proxyRow: number): void
    /**
     * Get the current filter expression used by `proxy`.
     */
    getFilterExpr(): string
    /**
     * Get the total number of filtered rows in `proxy` if a filter has been applied. As new rows
     * (rows added to the proxy and not yet added to the proxied data model) and rows to remove
     * (rows marked for removal but not yet removed from the proxied data model) are also filtered,
     * the returned number also contains references to new rows and rows to be removed.
     */
    getFilteredNRows(): number
    /**
     * Get the number of rows which have been modified in the proxy (the sum of rows existing in
     * the proxied data model which have been modified, and new rows).
     */
    getNModifiedRows(): number
    /**
     * Get the number of rows which have been added to `proxy` and which are not part of
     * the proxied data model.
     */
    getNNewRows(): number
    /**
     * Fetch the #GdaDataModel which `proxy` does proxy
     */
    getProxiedModel(): DataModel
    /**
     * Get the number of columns in the proxied data model
     */
    getProxiedModelNCols(): number
    /**
     * Get the number of rows in the proxied data model
     */
    getProxiedModelNRows(): number
    /**
     * Get the `proxy'`s proxied model row corresponding to `proxy_row`
     * @param proxyRow A proxy row number
     */
    getProxiedModelRow(proxyRow: number): number
    /**
     * Get the number of the last row to be available in `proxy` (in reference to the proxied data model)
     */
    getSampleEnd(): number
    /**
     * Get the size of each chunk of data displayed at a time.
     */
    getSampleSize(): number
    /**
     * Get the number of the first row to be available in `proxy` (in reference to the proxied data model)
     */
    getSampleStart(): number
    /**
     * Get the attributes of the value stored at (proxy_row, col) in `proxy,` which
     * is an ORed value of #GdaValueAttribute flags
     * @param proxyRow a proxy row
     * @param col a valid proxy column
     */
    getValueAttributes(proxyRow: number, col: number): ValueAttribute
    /**
     * Retrieve a whole list of values from the `proxy` data model. This function
     * calls gda_data_proxy_get_value()
     * for each column index specified in `cols_index,` and generates a #GSList on the way.
     * @param proxyRow a proxy row
     * @param colsIndex array containing the columns for which the values are requested
     */
    getValues(proxyRow: number, colsIndex: number[]): any[]
    /**
     * Tells if `proxy` contains any modifications not applied to the proxied data model.
     */
    hasChanged(): boolean
    isReadOnly(): boolean
    /**
     * Tells if the row number `proxy_row` has changed
     * @param proxyRow A proxy row number
     */
    rowHasChanged(proxyRow: number): boolean
    /**
     * Tells if the row number `proxy_row` is marked to be deleted.
     * @param proxyRow A proxy row number
     */
    rowIsDeleted(proxyRow: number): boolean
    /**
     * Tells if the row number `proxy_row` is a row which has been inserted in `proxy`
     * (and is thus not in the proxied data model).
     * @param proxyRow A proxy row number
     */
    rowIsInserted(proxyRow: number): boolean
    /**
     * Sets a filter among the rows presented by `proxy`. The filter is defined by a filter expression
     * which can be any SQL valid expression using `proxy'`s columns. For instance if `proxy` has the "id" and
     * "name" columns, then a filter can be "length(name) < 5" to filter only the rows where the length of the
     * name is strictly inferior to 5, or "id >= 1000 and id < 2000 order by name limit 50" to filter only the rows where the id
     * is between 1000 and 2000, ordered by name and limited to 50 rows.
     * 
     * Note about column names: real column names can be used (double quoted if necessary), but columns can also be named
     * "_&lt;column number&gt;" with column numbers starting at 1.
     * 
     * Note that any previous filter expression is replaced with the new `filter_expr` if no error occurs
     * (if an error occurs, then any previous filter is left unchanged).
     * @param filterExpr an SQL based expression which will filter the contents of `proxy,` or %NULL to remove any previous filter
     */
    setFilterExpr(filterExpr?: string | null): boolean
    /**
     * Orders by the `col` column
     * @param col the column number to order from
     */
    setOrderingColumn(col: number): boolean
    /**
     * Sets the size of each chunk of data to display: the maximum number of rows which
     * can be "displayed" at a time (the maximum number of rows which `proxy` pretends to have).
     * The default value is arbitrary 300 as it is big enough to
     * be able to display quite a lot of data, but small enough to avoid too much data
     * displayed at the same time.
     * 
     * Note: the rows which have been added but not yet committed will always be displayed
     * regardless of the current chunk of data, and the modified rows which are not visible
     * when the displayed chunk of data changes are still held as modified rows.
     * 
     * To remove the chunking of the data to display, simply pass `sample_size` the %0 value.
     * @param sampleSize the requested size of a chunk, or 0
     */
    setSampleSize(sampleSize: number): void
    /**
     * Sets the number of the first row to be available in `proxy` (in reference to the proxied data model)
     * @param sampleStart the number of the first row to be displayed
     */
    setSampleStart(sampleStart: number): void
    /**
     * Remove the "to be deleted" mark at the row `proxy_row,` if it existed.
     * @param proxyRow A proxy row number
     */
    undelete(proxyRow: number): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of Gda-5.0.Gda.DataProxy */
    /**
     * Gets emitted when `proxy'`s filter has been changed
     */
    connect(sigName: "filter-changed", callback: (() => void)): number
    on(sigName: "filter-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "filter-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "filter-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "filter-changed"): void
    /**
     * Gets emitted when `proxy` has committed a row change to the proxied data model.
     * @param row the proxy's row
     * @param proxiedRow the proxied data model's row
     */
    connect(sigName: "row-changes-applied", callback: ((row: number, proxiedRow: number) => void)): number
    on(sigName: "row-changes-applied", callback: (row: number, proxiedRow: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-changes-applied", callback: (row: number, proxiedRow: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-changes-applied", callback: (row: number, proxiedRow: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-changes-applied", row: number, proxiedRow: number): void
    /**
     * Gets emitted whenever a row has been marked to be deleted, or has been unmarked to be deleted
     * @param row the concerned `proxy'`s row
     * @param toBeDeleted tells if the `row` is marked to be deleted
     */
    connect(sigName: "row-delete-changed", callback: ((row: number, toBeDeleted: boolean) => void)): number
    on(sigName: "row-delete-changed", callback: (row: number, toBeDeleted: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-delete-changed", callback: (row: number, toBeDeleted: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-delete-changed", callback: (row: number, toBeDeleted: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "row-delete-changed", row: number, toBeDeleted: boolean): void
    /**
     * Gets emitted whenever `proxy'`s sample size has been changed. `sample_start` and `sample_end` are
     * in reference to the proxied data model.
     * @param sampleStart the first row of the sample
     * @param sampleEnd the last row of the sample
     */
    connect(sigName: "sample-changed", callback: ((sampleStart: number, sampleEnd: number) => void)): number
    on(sigName: "sample-changed", callback: (sampleStart: number, sampleEnd: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "sample-changed", callback: (sampleStart: number, sampleEnd: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "sample-changed", callback: (sampleStart: number, sampleEnd: number) => void): NodeJS.EventEmitter
    emit(sigName: "sample-changed", sampleStart: number, sampleEnd: number): void
    /**
     * Gets emitted whenever `proxy'`s sample size has been changed
     * @param sampleSize the new sample size
     */
    connect(sigName: "sample-size-changed", callback: ((sampleSize: number) => void)): number
    on(sigName: "sample-size-changed", callback: (sampleSize: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "sample-size-changed", callback: (sampleSize: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "sample-size-changed", callback: (sampleSize: number) => void): NodeJS.EventEmitter
    emit(sigName: "sample-size-changed", sampleSize: number): void
    /**
     * Gets emitted when `proxy` is about to commit a row change to the proxied data model. If any
     * callback returns a non %NULL value, then the change commit fails with the returned #GError
     * @param row the proxy's row
     * @param proxiedRow the proxied data model's row
     */
    connect(sigName: "validate-row-changes", callback: ((row: number, proxiedRow: number) => GLib.Error)): number
    on(sigName: "validate-row-changes", callback: (row: number, proxiedRow: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "validate-row-changes", callback: (row: number, proxiedRow: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "validate-row-changes", callback: (row: number, proxiedRow: number) => void): NodeJS.EventEmitter
    emit(sigName: "validate-row-changes", row: number, proxiedRow: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::cache-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cache-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cache-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cache-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cache-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::defer-sync", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::defer-sync", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::defer-sync", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::defer-sync", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::defer-sync", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::prepend-null-entry", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prepend-null-entry", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::prepend-null-entry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::prepend-null-entry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::prepend-null-entry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::sample-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sample-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::sample-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::sample-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::sample-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataProxy_ConstructProps)
    _init (config?: DataProxy_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(model: DataModel): DataProxy
    static newWithDataModel(model: DataModel): DataProxy
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface DataSelect_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.DataSelect */
    autoReset?: boolean
    connection?: Connection
    deleteStmt?: Statement
    execParams?: Set
    /**
     * This property stores the execution delay which has been necessary to obtain the data
     */
    executionDelay?: number
    insertStmt?: Statement
    modelUsage?: number
    preparedStmt?: PStmt
    storeAllRows?: boolean
    updateStmt?: Statement
}
class DataSelect {
    /* Properties of Gda-5.0.Gda.DataSelect */
    autoReset: boolean
    readonly connection: Connection
    deleteStmt: Statement
    readonly execParams: Set
    /**
     * This property stores the execution delay which has been necessary to obtain the data
     */
    executionDelay: number
    insertStmt: Statement
    readonly modelUsage: number
    preparedStmt: PStmt
    readonly selectStmt: Statement
    storeAllRows: boolean
    updateStmt: Statement
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.DataSelect */
    /**
     * Computes correct attributes for each of `model'`s columns, which includes the "NOT NULL" attribute, the
     * default value, the precision and scale for numeric values.
     */
    computeColumnsAttributes(): boolean
    /**
     * Makes `model` try to compute INSERT, UPDATE and DELETE statements to be used when modifying `model'`s contents.
     * Note: any modification statement set using gda_data_select_set_modification_statement() will first be unset
     * 
     * This function is similar to calling gda_data_select_compute_modification_statements_ext() with
     * `cond_type` set to %GDA_DATA_SELECT_COND_PK
     */
    computeModificationStatements(): boolean
    /**
     * Makes `model` try to compute INSERT, UPDATE and DELETE statements to be used when modifying `model'`s contents.
     * Note: any modification statement set using gda_data_select_set_modification_statement() will first be unset
     * @param condType the type of condition for the modifications where one row only should be identified
     */
    computeModificationStatementsExt(condType: DataSelectConditionType): boolean
    /**
     * Offers the same features as gda_data_select_set_row_selection_condition() but the expression
     * is computed from the meta data associated to the connection being used when `model` was created.
     * 
     * NOTE1: make sure the meta data associated to the connection is up to date before using this
     * method, see gda_connection_update_meta_store().
     * 
     * NOTE2: if the SELECT statement from which `model` has been created uses more than one table, or
     * if the table used does not have any primary key, then this method will fail
     */
    computeRowSelectionCondition(): boolean
    /**
     * Get a pointer to the #GdaConnection object which was used when `model` was created
     * (and which may be used internally by `model)`.
     */
    getConnection(): Connection
    /**
     * Use this method to make sure all the data contained in the data model are stored on the client
     * side (and that no subsquent call to the server will be necessary to access that data), at the cost of
     * a higher memory consumption.
     * 
     * This method is useful in the following situations:
     * <itemizedlist>
     *   <listitem><para>You need to disconnect from the server and continue to use the data in the data model</para></listitem>
     *   <listitem><para>You need to make sure the data in the data model can be used even though the connection to the server may be used for other purposes (for example executing other queries)</para></listitem>
     * </itemizedlist>
     * 
     * Note that this method will fail if:
     * <itemizedlist>
     *   <listitem><para>the data model contains any blobs (because blobs reading requires acces to the server);
     *     binary values are Ok, though.</para></listitem>
     *   <listitem><para>the data model has been modified since it was created</para></listitem>
     * </itemizedlist>
     */
    prepareForOffline(): boolean
    /**
     * Requests that `model` be re-run to have an updated result. If an error occurs,
     * then `model` will not be changed.
     */
    rerun(): boolean
    /**
     * Informs `model` that it should allow modifications to the data in some columns and some rows
     * using `mod_stmt` to propagate those modifications into the database.
     * 
     * If `mod_stmt` is:
     * <itemizedlist>
     *  <listitem><para>an UPDATE statement, then all the rows in `model` will be writable</para></listitem>
     *  <listitem><para>a DELETE statement, then it will be possible to delete rows in `model<`/para></listitem>
     *  <listitem><para>in INSERT statement, then it will be possible to add some rows to `model<`/para></listitem>
     *  <listitem><para>any other statement, then this method will return an error</para></listitem>
     * </itemizedlist>
     * 
     * This method can be called several times to specify different types of modification statements.
     * 
     * Each modification statement will be executed when one or more values are modified in the data model;
     * each statement should then include variables which will be set to either the old value or the
     * new value of a column at the specified modified row (but can also contain other variables). Each variable
     * named as "+&lt;number&gt;" will be mapped to the new value of the number'th column (starting at 0), and
     * each variable named as "-&lt;number&gt;" will be mapped to the old value of the number'th column.
     * 
     * Examples of the SQL equivalent of each statement are (for example if "mytable" has the "id" field as
     * primary key, and if that field is auto incremented and if the data model is the result of
     * executing "<![CDATA[SELECT * from mytable]]>").
     * 
     * <itemizedlist>
     *  <listitem><para>"<![CDATA[INSERT INTO mytable (name) VALUES (##+1::string)]]>": the column ID can not be set
     *   for new rows</para></listitem>
     *  <listitem><para>"<![CDATA[DELETE FROM mytable WHERE id=##-0::int]]>"</para></listitem>
     *  <listitem><para>"<![CDATA[UPDATE mytable SET name=##+1::string WHERE id=##-0::int]]>": the column ID cannot be
     *   modified</para></listitem>
     * </itemizedlist>
     * 
     * Also see the gda_data_select_set_row_selection_condition_sql() for more information about the WHERE
     * part of the UPDATE and DELETE statement types.
     * 
     * If `mod_stmt` is an UPDATE or DELETE statement then it should have a WHERE part which identifies
     * a unique row in `model` (please note that this property can't be checked but may result
     * in `model` behaving in an unpredictable way).
     * 
     * NOTE1: However, if the gda_data_select_set_row_selection_condition()
     * or gda_data_select_set_row_selection_condition_sql() have been successfully be called before, the WHERE
     * part of `mod_stmt` <emphasis>WILL</emphasis> be modified to use the row selection condition specified through one of
     * these methods (please not that it is then possible to avoid specifying a WHERE part in `mod_stmt` then).
     * 
     * NOTE2: if gda_data_select_set_row_selection_condition()
     * or gda_data_select_set_row_selection_condition_sql() have not yet been successfully be called before, then
     * the WHERE part of `mod_stmt` will be used as if one of these functions had been called.
     * @param modStmt a #GdaStatement (INSERT, UPDATE or DELETE)
     */
    setModificationStatement(modStmt: Statement): boolean
    /**
     * Offers the same feature as gda_data_select_set_modification_statement() but using an SQL statement.
     * @param sql an SQL text
     */
    setModificationStatementSql(sql: string): boolean
    /**
     * Specifies the SQL condition corresponding to the WHERE part of a SELECT statement which would
     * return only 1 row (the expression of the primary key).
     * 
     * For example for a table created as <![CDATA["CREATE TABLE mytable (part1 int NOT NULL, part2 string NOT NULL,
     * name string, PRIMARY KEY (part1, part2))"]]>, and if `pmodel` corresponds to the execution of the
     * <![CDATA["SELECT name, part1, part2 FROM mytable"]]>, then the sensible value for `sql_where` would be
     * <![CDATA["part1 = ##-1::int AND part2 = ##-2::string"]]> because the values of the 'part1' field are located
     * in `pmodel'`s column number 1 and the values of the 'part2' field are located
     * in `pmodel'`s column number 2 and the primary key is composed of (part1, part2).
     * 
     * For more information about the syntax of the parameters (named <![CDATA["##-1::int"]]> for example), see the
     * <link linkend="GdaSqlParser.description">GdaSqlParser</link> documentation, and
     * gda_data_select_set_modification_statement().
     * @param sqlWhere an SQL condition (without the WHERE keyword)
     */
    setRowSelectionConditionSql(sqlWhere: string): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataModel */
    /**
     * Adds the data from an XML node to the given data model (see the DTD for that node
     * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
     */
    addDataFromXmlNode(node: libxml2.NodePtr): boolean
    /**
     * Appends a row to the data model (the new row will possibly have NULL values for all columns,
     * or some other values depending on the data model implementation)
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     */
    appendRow(): number
    /**
     * Appends a row to the given data model. If any value in `values` is actually %NULL, then
     * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
     * 
     * Upon errors -1 will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
     */
    appendValues(values?: any[] | null): number
    /**
     * Makes a copy of `src` into a new #GdaDataModelArray object
     */
    arrayCopyModel(): DataModelArray | null
    /**
     * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
     * columns.
     * @param cols array of `src'`s columns to copy into the new array, not %NULL
     */
    arrayCopyModelExt(cols: number[]): DataModelArray | null
    /**
     * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
     * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
     * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
     * the data model from being destroyed).
     * 
     * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
     * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
     * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
     * with a cursor access mode specified), then this method will always return the same iterator.
     * 
     * If a new #GdaDataModelIter is created, then the row it represents is undefined.
     * 
     * For models which can be accessed
     * randomly, any row can be set using gda_data_model_iter_move_to_row(),
     * and for models which are accessible sequentially only then use
     * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
     * supported).
     * 
     * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
     * has twice the number of columns of the proxied data model), this method will create an iterator
     * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
     * in which all the proxy's columns appear, create it using:
     * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
     */
    createIter(): DataModelIter
    /**
     * Queries the underlying data model implementation for a description
     * of a given column. That description is returned in the form of
     * a #GdaColumn structure, which contains all the information
     * about the given column in the data model.
     * 
     * WARNING: the returned #GdaColumn object belongs to the `model` model and
     * and should not be destroyed; any modification will affect the whole data model.
     * @param col column number.
     */
    describeColumn(col: number): Column | null
    /**
     * Dumps a textual representation of the `model` to the `to_stream` stream
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     * @param toStream where to dump the data model
     */
    dump(toStream?: object | null): void
    /**
     * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
     * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
     * are not formatted according to the locale).
     * 
     * The following environment variables can affect the resulting output:
     * <itemizedlist>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
     *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
     * </itemizedlist>
     */
    dumpAsString(): string
    /**
     * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
     * the date format used is the one used by the connection from which the data model has been made (as the result of a
     * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
     * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
     * 
     * Specifically, the parameters in the `options` list can be:
     * <itemizedlist>
     *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
     *             </para></listitem>
     *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
     *             default if not specified is the double quote character</para></listitem>
     *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
     *             is requeted, in case of CSV export</para></listitem>
     *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
     *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
     *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
     *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
     *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
     *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
     *             </para></listitem>
     * </itemizedlist>
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * Upon errors %FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param format the format in which to export data
     * @param file the filename to export to
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToFile(format: DataModelIOFormat, file: string, cols: number[] | null, rows: number[] | null, options: Set): boolean
    /**
     * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
     * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
     * "OVERWRITE" option).
     * 
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * 
     * See also gda_data_model_dump_as_string();
     * @param format the format in which to export data
     * @param cols an array containing which columns of `model` will be exported, or %NULL for all columns
     * @param rows an array containing which rows of `model` will be exported, or %NULL for all rows
     * @param options list of options for the export
     */
    exportToString(format: DataModelIOFormat, cols: number[] | null, rows: number[] | null, options: Set): string
    /**
     * Disables notifications of changes on the given data model. To
     * re-enable notifications again, you should call the
     * #gda_data_model_thaw function.
     */
    freeze(): void
    /**
     * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
     */
    getAccessFlags(): DataModelAccessFlags
    /**
     * Get the attributes of the value stored at (row, col) in `model,` which
     * is an ORed value of #GdaValueAttribute flags. As a special case, if
     * `row` is -1, then the attributes returned correspond to a "would be" value
     * if a row was added to `model`.
     * @param col a valid column number
     * @param row a valid row number, or -1
     */
    getAttributesAt(col: number, row: number): ValueAttribute
    /**
     * Get the index of the first column named `name` in `model`.
     * @param name a column name
     */
    getColumnIndex(name: string): number
    getColumnName(col: number): string
    getColumnTitle(col: number): string
    /**
     * Get the global data model exception(s) that occurred when using `model`.
     * This is useful for example for the LDAP related
     * data models where some rows may be missing because the LDAP search has reached a limit
     * imposed by the LDAP server.
     */
    getExceptions(): GLib.Error[]
    getNColumns(): number
    getNRows(): number
    /**
     * Returns the status of notifications changes on the given data model.
     */
    getNotify(): boolean
    /**
     * Returns the first row where all the values in `values` at the columns identified at
     * `cols_index` match. If the row can't be identified, then returns -1;
     * 
     * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
     * @param values a list of #GValue values (no %NULL is allowed)
     * @param colsIndex an array of #gint containing the column number to match each value of `values`
     */
    getRowFromValues(values: any[], colsIndex: number[]): number
    /**
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
     * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
     * this method returns %NULL and an error code.
     * 
     * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     * @param expectedType the expected data type of the returned value
     * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
     */
    getTypedValueAt(col: number, row: number, expectedType: GObject.Type, nullok: boolean): any | null
    /**
     * Retrieves the data stored in the given position (identified by
     * the `col` and `row` parameters) on a data model.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * 
     * This is the main function for accessing data in a model which allows random access to its data.
     * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
     * gda_data_model_create_iter().
     * 
     * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
     * occur if you do so).
     * 
     * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
     * which means if you want to keep the value, a copy must be made, however it will remain valid
     * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
     * of the same row.
     * 
     * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
     * gda_data_model_set_values() methods.
     * 
     * Upon errors %NULL will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col a valid column number.
     * @param row a valid row number.
     */
    getValueAt(col: number, row: number): any | null
    /**
     * Imports data contained in the `file` file into `model;` the format is detected.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param file the filename to import from
     * @param colsTrans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromFile(file: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
     * orrurs.
     * 
     * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
     * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
     * create an entry in the hash table with a negative value. For example:
     * <programlisting><![CDATA[GHashTable *hash;
     * gint *ptr;
     * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
     * ptr = g_new (gint, 1);
     * *ptr = 2;
     * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
     * gda_data_model_import_from_model (...);
     * g_hash_table_free (hash);
     * ]]></programlisting>
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param from the source #GdaDataModel
     * @param overwrite TRUE if `to` is completely overwritten by `from'`s data, and FALSE if `from'`s data is appended to `to`
     * @param colsTrans a #GHashTable for columns translating, or %NULL
     */
    importFromModel(from: DataModel, overwrite: boolean, colsTrans?: GLib.HashTable | null): boolean
    /**
     * Loads the data from `string` into `model`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param string the string to import data from
     * @param colsTrans a hash table containing which columns of `model` will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
     * @param options list of options for the export
     */
    importFromString(string: string, colsTrans: GLib.HashTable | null, options: Set): boolean
    /**
     * Moves `iter` to the row number given by `row`.
     * @param iter a #GdaDataModelIter object.
     * @param row a row to point to with `iter`
     */
    iterAtRow(iter: DataModelIter, row: number): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterNext(iter: DataModelIter): boolean
    /**
     * Moves `iter` to the next row in `model`.
     * @param iter a #GdaDataModelIter object.
     */
    iterPrev(iter: DataModelIter): boolean
    /**
     * Set `value` to the given `column` and row pointed by `iter` in the given `model`.
     * @param iter a #GdaDataModelIter object.
     * @param col the number of column to set value to
     * @param value the to use to set on
     */
    iterSetValue(iter: DataModelIter, col: number, value: any): boolean
    /**
     * Removes a row from the data model.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row the row number to be removed.
     */
    removeRow(row: number): boolean
    /**
     * Emits the 'reset' and 'changed' signal on `model`.
     */
    reset(): void
    /**
     * Emits the 'row_inserted' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been inserted.
     * @param row row number.
     */
    rowInserted(row: number): void
    /**
     * Emits the 'row_removed' and 'changed' signal on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been removed
     * @param row row number.
     */
    rowRemoved(row: number): void
    /**
     * Emits the 'row_updated' and 'changed' signals on `model`.
     * 
     * This method should only be used by #GdaDataModel implementations to
     * signal that a row has been updated.
     * @param row row number.
     */
    rowUpdated(row: number): void
    /**
     * Sends a hint to the data model. The hint may or may not be handled by the data
     * model, depending on its implementation
     * @param hint a hint to send to the model
     * @param hintValue an optional value to specify the hint, or %NULL
     */
    sendHint(hint: DataModelHint, hintValue?: any | null): void
    /**
     * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
     * title to `name`.
     * @param col column number
     * @param name name for the given column.
     */
    setColumnName(col: number, name: string): void
    /**
     * Sets the `title` of the given `col` in `model`.
     * @param col column number
     * @param title title for the given column.
     */
    setColumnTitle(col: number, title: string): void
    /**
     * Enable or disable notifications changes on the given data model.
     * @param doNotifyChanges Set to TRUE if you require notifications.
     */
    setNotify(doNotifyChanges: boolean): void
    /**
     * Modifies a value in `model,` at (`col,` `row)`.
     * 
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param col column number.
     * @param row row number.
     * @param value a #GValue (not %NULL)
     */
    setValueAt(col: number, row: number, value: any): boolean
    /**
     * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
     * by setting several values at once.
     * 
     * If any value in `values` is actually %NULL, then the value in the corresponding column is left
     * unchanged.
     *  
     * Upon errors FALSE will be returned and `error` will be assigned a
     * #GError from the #GDA_DATA_MODEL_ERROR domain.
     * @param row row number.
     * @param values a list of #GValue (or %NULL), one for at most the number of columns of `model`
     */
    setValues(row: number, values?: any[] | null): boolean
    /**
     * Re-enables notifications of changes on the given data model.
     */
    thaw(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gda-5.0.Gda.DataModel */
    /**
     * Gets emitted when `model'`s access flags have changed. Use
     * gda_data_model_get_access_flags() to get the access flags.
     */
    connect(sigName: "access-changed", callback: (() => void)): number
    on(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "access-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "access-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "access-changed"): void
    /**
     * Gets emitted when any value in `model` has been changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when `model'`s contents has been completely reset (the number and
     * type of columns may also have changed)
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /**
     * Gets emitted when a row has been inserted in `model`
     * @param row the row number
     */
    connect(sigName: "row-inserted", callback: ((row: number) => void)): number
    on(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-inserted", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-inserted", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-inserted", row: number): void
    /**
     * Gets emitted when a row has been removed from `model`
     * @param row the row number
     */
    connect(sigName: "row-removed", callback: ((row: number) => void)): number
    on(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", row: number): void
    /**
     * Gets emitted when a row has been modified in `model`
     * @param row the row number
     */
    connect(sigName: "row-updated", callback: ((row: number) => void)): number
    on(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-updated", callback: (row: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-updated", callback: (row: number) => void): NodeJS.EventEmitter
    emit(sigName: "row-updated", row: number): void
    connect(sigName: "notify::auto-reset", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-reset", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auto-reset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auto-reset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auto-reset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::delete-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delete-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delete-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delete-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delete-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::exec-params", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::exec-params", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::exec-params", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::exec-params", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::exec-params", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::execution-delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::execution-delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::execution-delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::execution-delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::execution-delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::insert-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::insert-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::insert-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::insert-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::insert-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::model-usage", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::model-usage", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::model-usage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::model-usage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::model-usage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::prepared-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prepared-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::prepared-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::prepared-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::prepared-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::select-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::select-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::select-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::select-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::select-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::store-all-rows", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::store-all-rows", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::store-all-rows", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::store-all-rows", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::store-all-rows", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::update-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::update-stmt", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::update-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::update-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::update-stmt", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DataSelect_ConstructProps)
    _init (config?: DataSelect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface HandlerBin_ConstructProps extends GObject.Object_ConstructProps {
}
class HandlerBin {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataHandler */
    /**
     * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
     * @param type a #GType
     */
    acceptsGType(type: GObject.Type): boolean
    /**
     * Get a short description of the GdaDataHandler
     */
    getDescr(): string
    /**
     * Creates a new GValue which holds a sane initial value to be used if no value is specifically
     * provided. For example for a simple string, this would return a new value containing the "" string.
     * @param type a #GType
     */
    getSaneInitValue(type: GObject.Type): any | null
    /**
     * Creates a new string which is an SQL representation of the given value, the returned string
     * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
     * the returned string will be correctly quoted. Note however that it is a better practice
     * to use variables in statements instead of value literals, see
     * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
     * 
     * If the value is NULL or is of type GDA_TYPE_NULL,
     * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
     * @param value the value to be converted to a string, or %NULL
     */
    getSqlFromValue(value?: any | null): string
    /**
     * Creates a new string which is a "user friendly" representation of the given value
     * (in the user's locale, specially for the dates). If the value is
     * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
     * 
     * Note: the returned value will be in the current locale representation.
     * @param value the value to be converted to a string, or %NULL
     */
    getStrFromValue(value?: any | null): string
    /**
     * Creates a new GValue which represents the SQL value given as argument. This is
     * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `sql` string does not correspond to a valid SQL string for the requested type, then
     * the %NULL is returned.
     * @param sql an SQL string, or %NULL
     * @param type a GType
     */
    getValueFromSql(sql: string | null, type: GObject.Type): any
    /**
     * Creates a new GValue which represents the `str` value given as argument. This is
     * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `str` string does not correspond to a valid string for the requested type, then
     * %NULL is returned.
     * 
     * Note: the `str` string must be in the current locale representation
     * @param str a string or %NULL
     * @param type a GType
     */
    getValueFromStr(str: string | null, type: GObject.Type): any
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandlerBin_ConstructProps)
    _init (config?: HandlerBin_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     * 
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param forType a #GType type
     */
    static getDefault(forType: GObject.Type): DataHandler
    static $gtype: GObject.Type
}
interface HandlerBoolean_ConstructProps extends GObject.Object_ConstructProps {
}
class HandlerBoolean {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataHandler */
    /**
     * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
     * @param type a #GType
     */
    acceptsGType(type: GObject.Type): boolean
    /**
     * Get a short description of the GdaDataHandler
     */
    getDescr(): string
    /**
     * Creates a new GValue which holds a sane initial value to be used if no value is specifically
     * provided. For example for a simple string, this would return a new value containing the "" string.
     * @param type a #GType
     */
    getSaneInitValue(type: GObject.Type): any | null
    /**
     * Creates a new string which is an SQL representation of the given value, the returned string
     * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
     * the returned string will be correctly quoted. Note however that it is a better practice
     * to use variables in statements instead of value literals, see
     * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
     * 
     * If the value is NULL or is of type GDA_TYPE_NULL,
     * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
     * @param value the value to be converted to a string, or %NULL
     */
    getSqlFromValue(value?: any | null): string
    /**
     * Creates a new string which is a "user friendly" representation of the given value
     * (in the user's locale, specially for the dates). If the value is
     * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
     * 
     * Note: the returned value will be in the current locale representation.
     * @param value the value to be converted to a string, or %NULL
     */
    getStrFromValue(value?: any | null): string
    /**
     * Creates a new GValue which represents the SQL value given as argument. This is
     * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `sql` string does not correspond to a valid SQL string for the requested type, then
     * the %NULL is returned.
     * @param sql an SQL string, or %NULL
     * @param type a GType
     */
    getValueFromSql(sql: string | null, type: GObject.Type): any
    /**
     * Creates a new GValue which represents the `str` value given as argument. This is
     * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `str` string does not correspond to a valid string for the requested type, then
     * %NULL is returned.
     * 
     * Note: the `str` string must be in the current locale representation
     * @param str a string or %NULL
     * @param type a GType
     */
    getValueFromStr(str: string | null, type: GObject.Type): any
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandlerBoolean_ConstructProps)
    _init (config?: HandlerBoolean_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     * 
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param forType a #GType type
     */
    static getDefault(forType: GObject.Type): DataHandler
    static $gtype: GObject.Type
}
interface HandlerNumerical_ConstructProps extends GObject.Object_ConstructProps {
}
class HandlerNumerical {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataHandler */
    /**
     * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
     * @param type a #GType
     */
    acceptsGType(type: GObject.Type): boolean
    /**
     * Get a short description of the GdaDataHandler
     */
    getDescr(): string
    /**
     * Creates a new GValue which holds a sane initial value to be used if no value is specifically
     * provided. For example for a simple string, this would return a new value containing the "" string.
     * @param type a #GType
     */
    getSaneInitValue(type: GObject.Type): any | null
    /**
     * Creates a new string which is an SQL representation of the given value, the returned string
     * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
     * the returned string will be correctly quoted. Note however that it is a better practice
     * to use variables in statements instead of value literals, see
     * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
     * 
     * If the value is NULL or is of type GDA_TYPE_NULL,
     * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
     * @param value the value to be converted to a string, or %NULL
     */
    getSqlFromValue(value?: any | null): string
    /**
     * Creates a new string which is a "user friendly" representation of the given value
     * (in the user's locale, specially for the dates). If the value is
     * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
     * 
     * Note: the returned value will be in the current locale representation.
     * @param value the value to be converted to a string, or %NULL
     */
    getStrFromValue(value?: any | null): string
    /**
     * Creates a new GValue which represents the SQL value given as argument. This is
     * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `sql` string does not correspond to a valid SQL string for the requested type, then
     * the %NULL is returned.
     * @param sql an SQL string, or %NULL
     * @param type a GType
     */
    getValueFromSql(sql: string | null, type: GObject.Type): any
    /**
     * Creates a new GValue which represents the `str` value given as argument. This is
     * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `str` string does not correspond to a valid string for the requested type, then
     * %NULL is returned.
     * 
     * Note: the `str` string must be in the current locale representation
     * @param str a string or %NULL
     * @param type a GType
     */
    getValueFromStr(str: string | null, type: GObject.Type): any
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandlerNumerical_ConstructProps)
    _init (config?: HandlerNumerical_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     * 
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param forType a #GType type
     */
    static getDefault(forType: GObject.Type): DataHandler
    static $gtype: GObject.Type
}
interface HandlerString_ConstructProps extends GObject.Object_ConstructProps {
}
class HandlerString {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataHandler */
    /**
     * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
     * @param type a #GType
     */
    acceptsGType(type: GObject.Type): boolean
    /**
     * Get a short description of the GdaDataHandler
     */
    getDescr(): string
    /**
     * Creates a new GValue which holds a sane initial value to be used if no value is specifically
     * provided. For example for a simple string, this would return a new value containing the "" string.
     * @param type a #GType
     */
    getSaneInitValue(type: GObject.Type): any | null
    /**
     * Creates a new string which is an SQL representation of the given value, the returned string
     * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
     * the returned string will be correctly quoted. Note however that it is a better practice
     * to use variables in statements instead of value literals, see
     * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
     * 
     * If the value is NULL or is of type GDA_TYPE_NULL,
     * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
     * @param value the value to be converted to a string, or %NULL
     */
    getSqlFromValue(value?: any | null): string
    /**
     * Creates a new string which is a "user friendly" representation of the given value
     * (in the user's locale, specially for the dates). If the value is
     * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
     * 
     * Note: the returned value will be in the current locale representation.
     * @param value the value to be converted to a string, or %NULL
     */
    getStrFromValue(value?: any | null): string
    /**
     * Creates a new GValue which represents the SQL value given as argument. This is
     * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `sql` string does not correspond to a valid SQL string for the requested type, then
     * the %NULL is returned.
     * @param sql an SQL string, or %NULL
     * @param type a GType
     */
    getValueFromSql(sql: string | null, type: GObject.Type): any
    /**
     * Creates a new GValue which represents the `str` value given as argument. This is
     * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `str` string does not correspond to a valid string for the requested type, then
     * %NULL is returned.
     * 
     * Note: the `str` string must be in the current locale representation
     * @param str a string or %NULL
     * @param type a GType
     */
    getValueFromStr(str: string | null, type: GObject.Type): any
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandlerString_ConstructProps)
    _init (config?: HandlerString_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Creates a data handler for strings, which will use some specific methods implemented
     * by the `prov` object (possibly also `cnc)`.
     * @param prov a #GdaServerProvider object
     * @param cnc a #GdaConnection object, or %NULL
     */
    static newWithProvider(prov: ServerProvider, cnc?: Connection | null): DataHandler
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     * 
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param forType a #GType type
     */
    static getDefault(forType: GObject.Type): DataHandler
    static $gtype: GObject.Type
}
interface HandlerTime_ConstructProps extends GObject.Object_ConstructProps {
}
class HandlerTime {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.HandlerTime */
    /**
     * Get a string representing the locale-dependent way to enter a date/time/datetime, using
     * a syntax suitable for the #GdauiFormatEntry widget
     * @param type the type of data being handled
     */
    getFormat(type: GObject.Type): string
    getNoLocaleStrFromValue(value: any): string
    /**
     * Specifies the SQL output style of the `dh` data handler. The general format is "FIRSTsSECsTHIRD"
     * where FIRST, SEC and THIRD are specified by `first,` `sec` and `trird` and 's' is the separator,
     * specified by `separator`.
     * 
     * The default implementation is `first=`G_DATE_MONTH, `sec=`G_DATE_DAY and `third=`G_DATE_YEAR
     * (the year is rendered on 4 digits) and the separator is '-'
     * @param first what comes first in the date representation
     * @param sec what comes second in the date representation
     * @param third what comes third in the date representation
     * @param separator separator character used between year, month and day
     * @param twodigitsYears TRUE if year part of date must be rendered on 2 digits
     */
    setSqlSpec(first: GLib.DateDMY, sec: GLib.DateDMY, third: GLib.DateDMY, separator: number, twodigitsYears: boolean): void
    /**
     * Specifies the human readable output style of the `dh` data handler.
     * The general format is "FIRSTsSECsTHIRD"
     * where FIRST, SEC and THIRD are specified by `first,` `sec` and `trird` and 's' is the separator,
     * specified by `separator`.
     * 
     * The default implementation depends on the current locale, except if `dh` was created
     * using gda_handler_time_new_no_locale().
     * @param first what comes first in the date representation
     * @param sec what comes second in the date representation
     * @param third what comes third in the date representation
     * @param separator separator character used between year, month and day
     * @param twodigitsYears TRUE if year part of date must be rendered on 2 digits
     */
    setStrSpec(first: GLib.DateDMY, sec: GLib.DateDMY, third: GLib.DateDMY, separator: number, twodigitsYears: boolean): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataHandler */
    /**
     * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
     * @param type a #GType
     */
    acceptsGType(type: GObject.Type): boolean
    /**
     * Get a short description of the GdaDataHandler
     */
    getDescr(): string
    /**
     * Creates a new GValue which holds a sane initial value to be used if no value is specifically
     * provided. For example for a simple string, this would return a new value containing the "" string.
     * @param type a #GType
     */
    getSaneInitValue(type: GObject.Type): any | null
    /**
     * Creates a new string which is an SQL representation of the given value, the returned string
     * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
     * the returned string will be correctly quoted. Note however that it is a better practice
     * to use variables in statements instead of value literals, see
     * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
     * 
     * If the value is NULL or is of type GDA_TYPE_NULL,
     * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
     * @param value the value to be converted to a string, or %NULL
     */
    getSqlFromValue(value?: any | null): string
    /**
     * Creates a new string which is a "user friendly" representation of the given value
     * (in the user's locale, specially for the dates). If the value is
     * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
     * 
     * Note: the returned value will be in the current locale representation.
     * @param value the value to be converted to a string, or %NULL
     */
    getStrFromValue(value?: any | null): string
    /**
     * Creates a new GValue which represents the SQL value given as argument. This is
     * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `sql` string does not correspond to a valid SQL string for the requested type, then
     * the %NULL is returned.
     * @param sql an SQL string, or %NULL
     * @param type a GType
     */
    getValueFromSql(sql: string | null, type: GObject.Type): any
    /**
     * Creates a new GValue which represents the `str` value given as argument. This is
     * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `str` string does not correspond to a valid string for the requested type, then
     * %NULL is returned.
     * 
     * Note: the `str` string must be in the current locale representation
     * @param str a string or %NULL
     * @param type a GType
     */
    getValueFromStr(str: string | null, type: GObject.Type): any
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandlerTime_ConstructProps)
    _init (config?: HandlerTime_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Creates a data handler for time values, but using the default C locale
     * instead of the current user locale.
     */
    static newNoLocale(): DataHandler
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     * 
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param forType a #GType type
     */
    static getDefault(forType: GObject.Type): DataHandler
    static $gtype: GObject.Type
}
interface HandlerType_ConstructProps extends GObject.Object_ConstructProps {
}
class HandlerType {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.DataHandler */
    /**
     * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
     * @param type a #GType
     */
    acceptsGType(type: GObject.Type): boolean
    /**
     * Get a short description of the GdaDataHandler
     */
    getDescr(): string
    /**
     * Creates a new GValue which holds a sane initial value to be used if no value is specifically
     * provided. For example for a simple string, this would return a new value containing the "" string.
     * @param type a #GType
     */
    getSaneInitValue(type: GObject.Type): any | null
    /**
     * Creates a new string which is an SQL representation of the given value, the returned string
     * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
     * the returned string will be correctly quoted. Note however that it is a better practice
     * to use variables in statements instead of value literals, see
     * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
     * 
     * If the value is NULL or is of type GDA_TYPE_NULL,
     * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
     * @param value the value to be converted to a string, or %NULL
     */
    getSqlFromValue(value?: any | null): string
    /**
     * Creates a new string which is a "user friendly" representation of the given value
     * (in the user's locale, specially for the dates). If the value is
     * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
     * 
     * Note: the returned value will be in the current locale representation.
     * @param value the value to be converted to a string, or %NULL
     */
    getStrFromValue(value?: any | null): string
    /**
     * Creates a new GValue which represents the SQL value given as argument. This is
     * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `sql` string does not correspond to a valid SQL string for the requested type, then
     * the %NULL is returned.
     * @param sql an SQL string, or %NULL
     * @param type a GType
     */
    getValueFromSql(sql: string | null, type: GObject.Type): any
    /**
     * Creates a new GValue which represents the `str` value given as argument. This is
     * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
     * is used to determine the real data type requested for the returned value.
     * 
     * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
     * if the `str` string does not correspond to a valid string for the requested type, then
     * %NULL is returned.
     * 
     * Note: the `str` string must be in the current locale representation
     * @param str a string or %NULL
     * @param type a GType
     */
    getValueFromStr(str: string | null, type: GObject.Type): any
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandlerType_ConstructProps)
    _init (config?: HandlerType_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     * 
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param forType a #GType type
     */
    static getDefault(forType: GObject.Type): DataHandler
    static $gtype: GObject.Type
}
interface Holder_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.Holder */
    description?: string
    fullBind?: Holder
    gType?: GObject.Type
    id?: string
    name?: string
    notNull?: boolean
    simpleBind?: Holder
    sourceColumn?: number
    sourceModel?: DataModel
    /**
     * Defines if the "validate-change" signal gets emitted when
     * the holder's value changes.
     */
    validateChanges?: boolean
}
class Holder {
    /* Properties of Gda-5.0.Gda.Holder */
    description: string
    fullBind: Holder
    gType: GObject.Type
    id: string
    name: string
    notNull: boolean
    simpleBind: Holder
    sourceColumn: number
    sourceModel: DataModel
    /**
     * Defines if the "validate-change" signal gets emitted when
     * the holder's value changes.
     */
    validateChanges: boolean
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Holder */
    /**
     * Copy constructor.
     * 
     * Note1: if `orig` is set with a static value (see gda_holder_take_static_value())
     * its copy will have a fresh new allocated GValue, so that user should free it when done.
     */
    copy(): Holder
    /**
     * Forces a holder to be invalid; to set it valid again, a new value must be assigned
     * to it using gda_holder_set_value() or gda_holder_take_value().
     * 
     * `holder'`s value is set to %NULL.
     */
    forceInvalid(): void
    /**
     * Forces a holder to be invalid; to set it valid again, a new value must be assigned
     * to it using gda_holder_set_value() or gda_holder_take_value().
     * 
     * `holder'`s value is set to %NULL.
     * @param error a #GError explaining why `holder` is declared invalid, or %NULL
     */
    forceInvalidE(error?: GLib.Error | null): void
    /**
     * Get an "encoded" version of `holder'`s name. The "encoding" consists in replacing non
     * alphanumeric character with the string "__gdaXX" where XX is the hex. representation
     * of the non alphanumeric char.
     * 
     * This method is just a wrapper around the gda_text_to_alphanum() function.
     */
    getAlphanumId(): string
    /**
     * Get the value associated to a named attribute.
     * 
     * Attributes can have any name, but Libgda proposes some default names, see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
     * @param attribute attribute name as a string
     */
    getAttribute(attribute: string): any
    /**
     * Get the holder which makes `holder` change its value when the holder's value is changed.
     */
    getBind(): Holder
    /**
     * Get the default value held into the holder. WARNING: the default value does not need to be of
     * the same type as the one required by `holder`.
     */
    getDefaultValue(): any
    getGType(): GObject.Type
    /**
     * Get the ID of `holder`. The ID can be set using `holder'`s "id" property
     */
    getId(): string
    /**
     * Get wether the holder can be NULL or not
     */
    getNotNull(): boolean
    /**
     * If gda_holder_set_source_model() has been used to provide a hint that `holder'`s value
     * should be among the values contained in a column of a data model, then this method
     * returns which data model, and if `col` is not %NULL, then it is set to the restricting column
     * as well.
     * 
     * Otherwise, this method returns %NULL, and if `col` is not %NULL, then it is set to 0.
     * @param col a place to store the column in the model sourcing the holder, or %NULL
     */
    getSourceModel(col: number): DataModel
    /**
     * Get the value held into the holder. If `holder` is set to use its default value
     * and that default value is not of the same type as `holder,` then %NULL is returned.
     * 
     * If `holder` is set to NULL, then the returned value is a #GDA_TYPE_NULL GValue.
     * 
     * If `holder` is invalid, then the returned value is %NULL.
     */
    getValue(): any | null
    /**
     * Same functionality as gda_holder_get_value() except that it returns the value as a string
     * (the conversion is done using `dh` if not %NULL, or the default data handler otherwise).
     * @param dh a #GdaDataHandler to use, or %NULL
     */
    getValueStr(dh?: DataHandler | null): string
    /**
     * Get the validity of `holder` (that is, of the value held by `holder)`
     */
    isValid(): boolean
    /**
     * Get the validity of `holder` (that is, of the value held by `holder)`
     */
    isValidE(): boolean
    /**
     * Set the value associated to a named attribute. The `attribute` string is 'stolen' by this method, and
     * the memory it uses will be freed using the `destroy` function when no longer needed (if `destroy` is %NULL,
     * then the string will not be freed at all).
     * 
     * Attributes can have any name, but Libgda proposes some default names,
     * see <link linkend="libgda-5.0-Attributes-manager.synopsis">this section</link>.
     * 
     * For example one would use it as:
     * 
     * <code>gda_holder_set_attribute (holder, g_strdup (my_attribute), my_value, g_free);</code>
     * <code>gda_holder_set_attribute (holder, GDA_ATTRIBUTE_NAME, my_value, NULL);</code>
     * 
     * If there is already an attribute named `attribute` set, then its value is replaced with the new value (`value` is
     * copied), except if `value` is %NULL, in which case the attribute is removed.
     * @param attribute attribute name
     * @param value a #GValue, or %NULL
     * @param destroy a function to be called when `attribute` is not needed anymore, or %NULL
     */
    setAttribute(attribute: string, value: any, destroy: GLib.DestroyNotify): void
    /**
     * Sets `holder` to change when `bind_to` changes (and does not make `bind_to` change when `holder` changes).
     * For the operation to succeed, the GType of `holder` and `bind_to` must be the same, with the exception that
     * any of them can have a %GDA_TYPE_NULL type (in this situation, the GType of the two #GdaHolder objects
     * involved is set to match the other when any of them sets its type to something different than GDA_TYPE_NULL).
     * 
     * If `bind_to` is %NULL, then `holder` will not be bound anymore.
     * @param bindTo a #GdaHolder or %NULL
     */
    setBind(bindTo: Holder): boolean
    /**
     * Sets the default value within the holder. If `value` is %NULL then `holder` won't have a
     * default value anymore. To set a default value to %NULL, then pass a #GValue created using
     * gda_value_new_null().
     * 
     * NOTE: the default value does not need to be of the same type as the one required by `holder`.
     * @param value a value to set the holder's default value, or %NULL
     */
    setDefaultValue(value: any): void
    /**
     * Sets if the holder can have a NULL value. If `not_null` is TRUE, then that won't be allowed
     * @param notNull TRUE if `holder` should not accept %NULL values
     */
    setNotNull(notNull: boolean): void
    /**
     * Sets an hint that `holder'`s values should be restricted among the values
     * contained in the `col` column of the `model` data model. Note that this is just a hint,
     * meaning this policy is not enforced by `holder'`s implementation.
     * 
     * If `model` is %NULL, then the effect is to cancel ant previous call to gda_holder_set_source_model()
     * where `model` was not %NULL.
     * @param model a #GdaDataModel object or %NULL
     * @param col the reference column in `model`
     */
    setSourceModel(model: DataModel, col: number): boolean
    /**
     * Sets the value within the holder. If `holder` is an alias for another
     * holder, then the value is also set for that other holder.
     * 
     * On success, the action of any call to gda_holder_force_invalid() is cancelled
     * as soon as this method is called (even if `holder'`s value does not actually change)
     * 
     * If the value is not different from the one already contained within `holder,`
     * then `holder` is not changed and no signal is emitted.
     * 
     * Note1: the `value` argument is treated the same way if it is %NULL or if it is a #GDA_TYPE_NULL value
     * 
     * Note2: if `holder` can't accept the `value` value, then this method returns FALSE, and `holder` will be left
     * in an invalid state.
     * 
     * Note3: before the change is accepted by `holder,` the "validate-change" signal will be emitted (the value
     * of which can prevent the change from happening) which can be connected to to have a greater control
     * of which values `holder` can have, or implement some business rules.
     * @param value a value to set the holder to, or %NULL
     */
    setValue(value?: any | null): boolean
    /**
     * Same functionality as gda_holder_set_value() except that it uses a string representation
     * of the value to set, which will be converted into a GValue first (using default data handler if
     * `dh` is %NULL).
     * 
     * Note1: if `value` is %NULL or is the "NULL" string, then `holder'`s value is set to %NULL.
     * Note2: if `holder` can't accept the `value` value, then this method returns FALSE, and `holder` will be left
     * in an invalid state.
     * @param dh a #GdaDataHandler to use, or %NULL
     * @param value a value to set the holder to, as a string
     */
    setValueStr(dh: DataHandler, value: string): boolean
    /**
     * Set `holder'`s value to its default value.
     */
    setValueToDefault(): boolean
    /**
     * Sets the const value within the holder. If `holder` is an alias for another
     * holder, then the value is also set for that other holder.
     * 
     * The value will not be freed, and user should take care of it, either for its
     * freeing or for its correct value at the moment of query.
     * 
     * If the value is not different from the one already contained within `holder,`
     * then `holder` is not changed and no signal is emitted.
     * 
     * Note1: if `holder` can't accept the `value` value, then this method returns NULL, and `holder` will be left
     * in an invalid state.
     * 
     * Note2: before the change is accepted by `holder,` the "validate-change" signal will be emitted (the value
     * of which can prevent the change from happening) which can be connected to to have a greater control
     * of which values `holder` can have, or implement some business rules.
     * @param value a const value to set the holder to
     * @param valueChanged a boolean set with TRUE if the value changes, FALSE elsewhere.
     */
    takeStaticValue(value: any, valueChanged: boolean): any
    /**
     * Sets the value within the holder. If `holder` is an alias for another
     * holder, then the value is also set for that other holder.
     * 
     * On success, the action of any call to gda_holder_force_invalid() is cancelled
     * as soon as this method is called (even if `holder'`s value does not actually change).
     * 
     * If the value is not different from the one already contained within `holder,`
     * then `holder` is not changed and no signal is emitted.
     * 
     * Note1: if `holder` can't accept the `value` value, then this method returns FALSE, and `holder` will be left
     * in an invalid state.
     * 
     * Note2: before the change is accepted by `holder,` the "validate-change" signal will be emitted (the value
     * of which can prevent the change from happening) which can be connected to to have a greater control
     * of which values `holder` can have, or implement some business rules.
     * 
     * Note3: if user previously set this holder with gda_holder_take_static_value () the GValue
     * stored internally will be forgiven and replaced by the `value`. User should then
     * take care of the 'old' static GValue.
     * @param value a value to set the holder to
     */
    takeValue(value: any): boolean
    /**
     * Tells if `holder'`s current value is the default one.
     */
    valueIsDefault(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.Lockable */
    /**
     * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
     * by the other thread.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    lock(): void
    /**
     * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
     * it locks `lockable`.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    trylock(): boolean
    /**
     * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
     * used gda_lockable_lock() or gda_lockable_trylock()).
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     */
    unlock(): void
    /* Signals of Gda-5.0.Gda.Holder */
    /**
     * Gets emitted when any `holder'`s attribute has changed
     * @param attName attribute's name
     * @param attValue attribute's value
     */
    connect(sigName: "attribute-changed", callback: ((attName: string, attValue: any) => void)): number
    on(sigName: "attribute-changed", callback: (attName: string, attValue: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "attribute-changed", callback: (attName: string, attValue: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "attribute-changed", callback: (attName: string, attValue: any) => void): NodeJS.EventEmitter
    emit(sigName: "attribute-changed", attName: string, attValue: any): void
    /**
     * Gets emitted when `holder'`s value has changed
     */
    connect(sigName: "changed", callback: (() => void)): number
    on(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "changed"): void
    /**
     * Gets emitted when the data model in which `holder'`s values should be has changed
     */
    connect(sigName: "source-changed", callback: (() => void)): number
    on(sigName: "source-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "source-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "source-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "source-changed"): void
    /**
     * Gets emitted when `holder` is going to change its value. One can connect to
     * this signal to control which values `holder` can have (for example to implement some business rules)
     * @param newValue the proposed new value for `holder`
     */
    connect(sigName: "validate-change", callback: ((newValue: any) => GLib.Error)): number
    on(sigName: "validate-change", callback: (newValue: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "validate-change", callback: (newValue: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "validate-change", callback: (newValue: any) => void): NodeJS.EventEmitter
    emit(sigName: "validate-change", newValue: any): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::full-bind", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::full-bind", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::full-bind", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::full-bind", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::full-bind", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::g-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::g-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::g-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::g-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::not-null", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::not-null", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::not-null", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::not-null", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::not-null", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::simple-bind", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::simple-bind", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::simple-bind", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::simple-bind", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::simple-bind", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::source-column", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source-column", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::source-column", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::source-column", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::source-column", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::source-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source-model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::source-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::source-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::source-model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::validate-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::validate-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Holder_ConstructProps)
    _init (config?: Holder_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(type: GObject.Type): Holder
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface MetaStore_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.MetaStore */
    catalog?: string
    cnc?: Connection
    cncString?: string
    schema?: string
}
class MetaStore {
    /* Properties of Gda-5.0.Gda.MetaStore */
    readonly catalog: string
    readonly cnc: Connection
    readonly cncString: string
    readonly schema: string
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.MetaStore */
    /**
     * Creates a new #GdaDataModelArray data model which can be used, after being correctly filled,
     * with the gda_meta_store_modify*() methods.*
     * 
     * To be used by provider's implementation
     * @param tableName the name of a table present in `store`
     */
    createModifyDataModel(tableName: string): DataModel
    /**
     * Defines a new declared foreign key into `store`. If another declared foreign key is already defined
     * between the two tables and with the same name, then it is first removed.
     * 
     * This method begins a transaction if possible (ie. none is already started), and if it can't,
     * then if there is an error, the job may be partially done.
     * 
     * A check is always performed to make sure all the database objects actually
     * exist and returns an error if not. The check is performed using `mstruct` if it's not %NULL (in
     * this case only the tables already represented in `mstruct` will be considered, in other words: `mstruct`
     * will not be modified), and using an internal #GdaMetaStruct is %NULL.
     * 
     * The `catalog,` `schema,` `table,` `ref_catalog,` `ref_schema` and `ref_table` must follow the SQL
     * identifiers naming convention, see the <link linkend="gen:sql_identifiers">SQL identifiers</link>
     * section. The same convention needs to be respected for the strings in `conames` and `ref_colnames`.
     * 
     * If `catalog` is not %NULL, then `schema` must also be not %NULL (the same restriction applies to
     * `ref_catalog` and `ref_schema)`.
     * @param mstruct a #GdaMetaStruct, or %NULL
     * @param fkName the name of the foreign key to declare
     * @param catalog the catalog in which the table (for which the foreign key is for) is, or %NULL
     * @param schema the schema in which the table (for which the foreign key is for) is, or %NULL
     * @param table the name of the table (for which the foreign key is for)
     * @param refCatalog the catalog in which the referenced table is, or %NULL
     * @param refSchema the schema in which the referenced table is, or %NULL
     * @param refTable the name of the referenced table
     * @param colnames an array of column names from the table for which the foreign key is for
     * @param refColnames an array of column names from the referenced table
     */
    declareForeignKey(mstruct: MetaStruct | null, fkName: string, catalog: string | null, schema: string | null, table: string, refCatalog: string | null, refSchema: string | null, refTable: string, colnames: string[], refColnames: string[]): boolean
    /**
     * Extracts some data stored in `store` using a custom SELECT query. If the `select_sql` filter involves
     * SQL identifiers (such as table or column names), then the values should have been adapted using
     * gda_meta_store_sql_identifier_quote().
     * 
     * For more information about
     * SQL identifiers are represented in `store,` see the
     * <link linkend="information_schema:sql_identifiers">meta data section about SQL identifiers</link>.
     * @param selectSql a SELECT statement
     * @param vars a hash table with all variables names as keys and GValue* as value, representing values for all the variables mentioned in `select_sql`. If there is no variable then this part can be omitted.
     */
    extract(selectSql: string, vars?: GLib.HashTable | null): DataModel
    /**
     * The #GdaMetaStore object maintains a list of (name,value) attributes (attributes names starting with a '_'
     * character are for internal use only and cannot be altered). This method and the gda_meta_store_set_attribute_value()
     * method allows the user to add, set or remove attributes specific to their usage.
     * 
     * This method allows to get the value of a attribute stored in `store`. The returned attribute value is
     * placed at `att_value,` the caller is responsible for free that string.
     * 
     * If there is no attribute named `att_name` then `att_value` is set to %NULL
     * and `error` will contain the GDA_META_STORE_ATTRIBUTE_NOT_FOUND_ERROR error code, and FALSE is returned.
     * @param attName name of the attribute to get
     */
    getAttributeValue(attName: string): [ /* returnType */ boolean, /* attValue */ string ]
    /**
     * Get a pointer to the #GdaConnection object internally used by `store` to store
     * its contents.
     * 
     * The returned connection can be used to access some other data than the one managed by `store`
     * itself. The returned object is not owned by the caller (if you need to keep it, then use g_object_ref()).
     * Do not close the connection.
     */
    getInternalConnection(): Connection
    /**
     * Get `store'`s internal schema's version
     */
    getVersion(): number
    /**
     * Propagates an update to `store,` the update's contents is represented by `new_data,` this function is
     * primarily reserved to database providers.
     * @param tableName the name of the table to modify within `store`
     * @param newData a #GdaDataModel containing the new data to set in `table_name,` or %NULL (treated as a data model with no row at all)
     * @param condition SQL expression (which may contain variables) defining the rows which are being obsoleted by `new_data,` or %NULL
     * @param valueNames names of values
     * @param values values
     */
    modify(tableName: string, newData: DataModel | null, condition: string | null, valueNames: string[], values: any[]): boolean
    /**
     * Propagates an update to `store,` the update's contents is represented by `new_data,` this function is
     * primarily reserved to database providers.
     * @param context a #GdaMetaContext context describing what to modify in `store`
     * @param newData a #GdaDataModel containing the new data to set in `table_name,` or %NULL (treated as a data model with no row at all)
     */
    modifyWithContext(context: MetaContext, newData?: DataModel | null): boolean
    /**
     * The internal database used by `store` can be 'augmented' with some user-defined database objects
     * (such as tables or views). This method allows one to add a new database object.
     * 
     * If the internal database already contains the object, then:
     * <itemizedlist>
     *   <listitem><para>if the object is equal to the provided description then TRUE is returned</para></listitem>
     *   <listitem><para>if the object exists but differs from the provided description, then FALSE is returned,
     *      with the GDA_META_STORE_SCHEMA_OBJECT_CONFLICT_ERROR error code</para></listitem>
     * </itemizedlist>
     * 
     * The `xml_description` defines the table of view's definition, for example:
     * <programlisting><![CDATA[<table name="mytable">
     *     <column name="id" pkey="TRUE"/>
     *     <column name="value"/>
     * </table>]]></programlisting>
     * 
     * The partial DTD for this XML description of the object to add is the following (the top node must be
     * a &lt;table&gt; or a &lt;view&gt;):
     * <programlisting><![CDATA[<!ELEMENT table (column*,check*,fkey*,unique*)>
     * <!ATTLIST table
     *           name NMTOKEN #REQUIRED>
     * 
     * <!ELEMENT column EMPTY>
     * <!ATTLIST column
     *           name NMTOKEN #REQUIRED
     *           type CDATA #IMPLIED
     *           pkey (TRUE|FALSE) #IMPLIED
     *           autoinc (TRUE|FALSE) #IMPLIED
     *           nullok (TRUE|FALSE) #IMPLIED>
     * 
     * <!ELEMENT check (#PCDATA)>
     * 
     * <!ELEMENT fkey (part+)>
     * <!ATTLIST fkey
     *           ref_table NMTOKEN #REQUIRED>
     * 
     * <!ELEMENT part EMPTY>
     * <!ATTLIST part
     *           column NMTOKEN #IMPLIED
     *           ref_column NMTOKEN #IMPLIED>
     * 
     * <!ELEMENT unique (column)>
     * 
     * <!ELEMENT view (definition)>
     * <!ATTLIST view
     *           name NMTOKEN #REQUIRED
     *           descr CDATA #IMPLIED>
     * 
     * <!ELEMENT definition (#PCDATA)>]]></programlisting>
     * @param xmlDescription an XML description of the table or view to add to `store`
     */
    schemaAddCustomObject(xmlDescription: string): boolean
    /**
     * Get an ordered list of the tables `store` knows about. The tables are ordered in a way that tables dependencies
     * are respected: if table B has a foreign key on table A, then table A will be listed before table B in the returned
     * list.
     */
    schemaGetAllTables(): string[]
    /**
     * Get an ordered list of the tables `store` knows about on which the `table_name` table depends (recursively).
     * The tables are ordered in a way that tables dependencies
     * are respected: if table B has a foreign key on table A, then table A will be listed before table B in the returned
     * list.
     * @param tableName the name of the table for which all the dependencies must be listed
     */
    schemaGetDependTables(tableName: string): string[]
    /**
     * Creates a new #GdaMetaStruct object representing `store'`s internal database structure.
     */
    schemaGetStructure(): MetaStruct
    /**
     * Removes the custom database object named `obj_name`.
     * @param objName name of the custom object to remove
     */
    schemaRemoveCustomObject(objName: string): boolean
    /**
     * Set the value of the attribute named `att_name` to `att_value;` see gda_meta_store_get_attribute_value() for
     * more information.
     * @param attName name of the attribute to set
     * @param attValue value of the attribute to set, or %NULL to unset the attribute
     */
    setAttributeValue(attName: string, attValue?: string | null): boolean
    /**
     * Specifies how `store` must handle SQL identifiers it has to store. This method is mainly used by
     * database providers.
     * @param style a style
     */
    setIdentifiersStyle(style: SqlIdentifierStyle): void
    /**
     * Specifies a function which `store` will use to determine if a keyword is an SQL reserved
     * keyword or not.
     * 
     * This method is mainly used by database providers.
     * @param func a #GdaSqlReservedKeywordsFunc function, or %NULL
     */
    setReservedKeywordsFunc(func?: SqlReservedKeywordsFunc | null): void
    /**
     * Removes a declared foreign key from `store`.
     * 
     * This method begins a transaction if possible (ie. none is already started), and if it can't, then if there
     * is an error, the job may be partially done.
     * 
     * A check is always performed to make sure all the database objects actually
     * exist and returns an error if not. The check is performed using `mstruct` if it's not %NULL (in
     * this case only the tables already represented in `mstruct` will be considered, in other words: `mstruct`
     * will not be modified), and using an internal #GdaMetaStruct is %NULL.
     * 
     * See gda_meta_store_declare_foreign_key() for more information anout the `catalog,` `schema,` `name,`
     * `ref_catalog,` `ref_schema` and `ref_name` arguments.
     * @param mstruct a #GdaMetaStruct, or %NULL
     * @param fkName the name of the foreign key to declare
     * @param catalog the catalog in which the table (for which the foreign key is for) is, or %NULL
     * @param schema the schema in which the table (for which the foreign key is for) is, or %NULL
     * @param table the name of the table (for which the foreign key is for)
     * @param refCatalog the catalog in which the referenced table is, or %NULL
     * @param refSchema the schema in which the referenced table is, or %NULL
     * @param refTable the name of the referenced table
     */
    undeclareForeignKey(mstruct: MetaStruct | null, fkName: string, catalog: string | null, schema: string | null, table: string, refCatalog: string | null, refSchema: string | null, refTable: string): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.MetaStore */
    /**
     * This signal is emitted when the `store'`s contents have changed (the changes are in the `changes` list)
     * @param changes a list of changes made, as a #GSList of pointers to #GdaMetaStoreChange (which must not be modified)
     */
    connect(sigName: "meta-changed", callback: ((changes: MetaStoreChange[]) => void)): number
    on(sigName: "meta-changed", callback: (changes: MetaStoreChange[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "meta-changed", callback: (changes: MetaStoreChange[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "meta-changed", callback: (changes: MetaStoreChange[]) => void): NodeJS.EventEmitter
    emit(sigName: "meta-changed", changes: MetaStoreChange[]): void
    /**
     * This signal is emitted when the `store'`s contents have been reset completely and when
     * no detailed changes are available
     */
    connect(sigName: "meta-reset", callback: (() => void)): number
    on(sigName: "meta-reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "meta-reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "meta-reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "meta-reset"): void
    /**
     * This signal is emitted when the contents of a table should be updated (data to update or insert only;
     * deleting data is done automatically). This signal is used for internal purposes by the #GdaConnection
     * object.
     * @param suggest the suggested update, as a #GdaMetaContext structure
     */
    connect(sigName: "suggest-update", callback: ((suggest: MetaContext) => GLib.Error)): number
    on(sigName: "suggest-update", callback: (suggest: MetaContext) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "suggest-update", callback: (suggest: MetaContext) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "suggest-update", callback: (suggest: MetaContext) => void): NodeJS.EventEmitter
    emit(sigName: "suggest-update", suggest: MetaContext): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::catalog", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::catalog", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::catalog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::catalog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::catalog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cnc", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cnc", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cnc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cnc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cnc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cnc-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cnc-string", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cnc-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cnc-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cnc-string", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::schema", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::schema", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: MetaStore_ConstructProps)
    _init (config?: MetaStore_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(cncString?: string | null): MetaStore
    static newWithFile(fileName: string): MetaStore
    static errorQuark(): GLib.Quark
    /**
     * Use this method to get a correctly quoted (if necessary) SQL identifier which can be used
     * to retrieve or filter information in a #GdaMetaStore which stores meta data about `cnc`.
     * 
     * The returned SQL identifier can be used in conjunction with gda_connection_update_meta_store(),
     * gda_connection_get_meta_store_data(), gda_connection_get_meta_store_data_v() and
     * gda_meta_store_extract().
     * @param id an SQL identifier
     * @param cnc a #GdaConnection
     */
    static sqlIdentifierQuote(id: string, cnc: Connection): string
    static $gtype: GObject.Type
}
interface MetaStruct_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.MetaStruct */
    features?: number
    metaStore?: MetaStore
}
class MetaStruct {
    /* Properties of Gda-5.0.Gda.MetaStruct */
    readonly features: number
    readonly metaStore: MetaStore
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.MetaStruct */
    /**
     * Creates a new #GdaMetaDbObject structure in `mstruct` to represent the database object (of type `type)`
     * which can be uniquely identified as `catalog`.`schema`.`name`.
     * 
     * If `catalog` is not %NULL, then `schema` should not be %NULL.
     * 
     * If both `catalog` and `schema` are %NULL, then the database object will be the one which is
     * "visible" by default (that is which can be accessed only by its short `name` name).
     * 
     * If `catalog` is %NULL and `schema` is not %NULL, then the database object will be the one which
     * can be accessed by its `schema`.`name` name.
     * 
     * Important note: `catalog,` `schema` and `name` will be used using the following convention:
     * <itemizedlist>
     *   <listitem><para>be surrounded by double quotes for a case sensitive search</para></listitem>
     *   <listitem><para>otherwise for case insensitive search</para></listitem>
     * </itemizedlist>
     * 
     * For more information, see the <link linkend="information_schema:sql_identifiers">
     * meta data section about SQL identifiers</link>.
     * @param type the type of object to add (which can be GDA_META_DB_UNKNOWN)
     * @param catalog the catalog the object belongs to (as a G_TYPE_STRING GValue), or %NULL
     * @param schema the schema the object belongs to (as a G_TYPE_STRING GValue), or %NULL
     * @param name the object's name (as a G_TYPE_STRING GValue), not %NULL
     */
    complement(type: MetaDbObjectType, catalog: any | null, schema: any | null, name: any): MetaDbObject
    /**
     * This method is similar to gda_meta_struct_complement() and gda_meta_struct_complement_default()
     * but creates #GdaMetaDbObject for all the database object.
     * 
     * Please refer to gda_meta_struct_complement() form more information.
     */
    complementAll(): boolean
    /**
     * This method is similar to gda_meta_struct_complement() and gda_meta_struct_complement_all()
     * but creates #GdaMetaDbObject for all the
     * database object which are usable using only their short name (that is which do not need to be prefixed by
     * the schema in which they are to be used).
     * 
     * Please refer to gda_meta_struct_complement() form more information.
     */
    complementDefault(): boolean
    /**
     * This method is similar to gda_meta_struct_complement() but creates #GdaMetaDbObject for all the dependencies
     * of `dbo`.
     * 
     * Please refer to gda_meta_struct_complement() form more information.
     * @param dbo a #GdaMetaDbObject part of `mstruct`
     */
    complementDepend(dbo: MetaDbObject): boolean
    /**
     * This method is similar to gda_meta_struct_complement() but creates #GdaMetaDbObject for all the
     * database object which are in the `schema` schema (and in the `catalog` catalog).
     * If `catalog` is %NULL, then any catalog will be used, and
     * if `schema` is %NULL then any schema will be used (if `schema` is %NULL then catalog must also be %NULL).
     * 
     * Please refer to gda_meta_struct_complement() form more information.
     * @param catalog name of a catalog, or %NULL
     * @param schema name of a schema, or %NULL
     */
    complementSchema(catalog?: any | null, schema?: any | null): boolean
    /**
     * Creates a new graph (in the GraphViz syntax) representation of `mstruct`.
     * @param info informs what kind of information to show in the resulting graph
     */
    dumpAsGraph(info: MetaGraphInfo): string
    /**
     * Get a list of all the #GdaMetaDbObject structures representing database objects in `mstruct`. Note that
     * no #GdaMetaDbObject structure must not be modified.
     */
    getAllDbObjects(): MetaDbObject[]
    /**
     * Tries to locate the #GdaMetaDbObject structure representing the database object named after
     * `catalog,` `schema` and `name`.
     * 
     * If one or both of `catalog` and `schema` are %NULL, and more than one database object matches the name, then
     * the return value is also %NULL.
     * @param catalog the catalog the object belongs to (as a G_TYPE_STRING GValue), or %NULL
     * @param schema the schema the object belongs to (as a G_TYPE_STRING GValue), or %NULL
     * @param name the object's name (as a G_TYPE_STRING GValue), not %NULL
     */
    getDbObject(catalog: any | null, schema: any | null, name: any): MetaDbObject
    /**
     * Loads an XML description into `mstruct`. This method is still experimental and no description
     * the XML file structure is given, and no guarantee that it will remain as it is given.
     * @param catalog the catalog name, or %NULL
     * @param schema the schema name, or %NULL
     * @param xmlSpecFile the specifications as the name of an XML file
     */
    loadFromXmlFile(catalog: string | null, schema: string | null, xmlSpecFile: string): boolean
    /**
     * Reorders the list of database objects within `mstruct` in a way specified by `sort_type`.
     * @param sortType the kind of sorting requested
     */
    sortDbObjects(sortType: MetaSortType): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::features", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::features", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::features", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::features", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::features", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: MetaStruct_ConstructProps)
    _init (config?: MetaStruct_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(store: MetaStore, features: MetaStructFeature): MetaStruct
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface PStmt_ConstructProps extends GObject.Object_ConstructProps {
}
class PStmt {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.PStmt */
    /**
     * Copies `src'`s data to `dest`
     * @param dest a #GdaPStmt object
     */
    copyContents(dest: PStmt): void
    /**
     * Get a pointer to the #GdaStatement which led to the creation of this prepared statement.
     * 
     * Note: if that statement has been modified since the creation of `pstmt,` then this method
     * will return %NULL
     */
    getGdaStatement(): Statement
    /**
     * Informs `pstmt` that it corresponds to the preparation of the `stmt` statement
     * @param stmt a #GdaStatement object, or %NULL
     */
    setGdaStatement(stmt?: Statement | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: PStmt_ConstructProps)
    _init (config?: PStmt_ConstructProps): void
    static $gtype: GObject.Type
}
interface RepetitiveStatement_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.RepetitiveStatement */
    statement?: Statement
}
class RepetitiveStatement {
    /* Properties of Gda-5.0.Gda.RepetitiveStatement */
    readonly statement: Statement
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.RepetitiveStatement */
    /**
     * Specifies that `rstmt` be executed one time with the values contained in `values`.
     * 
     * A new #GdaSet to be used as the `values` argument can be obtained using
     * gda_repetitive_statement_get_template_set().
     * @param values a #GdaSet object with the values to be used
     * @param makeCopy %TRUE if `values` is copied, and %FALSE if `values` is only ref'ed
     */
    appendSet(values: Set, makeCopy: boolean): boolean
    /**
     * Get all the values sets which will have been added using gda_repetitive_statement_append_set().
     */
    getAllSets(): Set[]
    /**
     * Gets a new #GdaSet object with the parameters used by the template statement in the
     * `rstmt` object.
     * 
     * Use this object with gda_repetitive_statement_append_set().
     * @param set a place to store the returned template set
     */
    getTemplateSet(set: Set): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::statement", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::statement", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::statement", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::statement", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::statement", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: RepetitiveStatement_ConstructProps)
    _init (config?: RepetitiveStatement_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(stmt: Statement): RepetitiveStatement
    static $gtype: GObject.Type
}
interface Row_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.Row */
    nbValues?: number
}
class Row {
    /* Properties of Gda-5.0.Gda.Row */
    nbValues: number
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Row */
    getLength(): number
    /**
     * Gets a pointer to a #GValue stored in a #GdaRow.
     * 
     * This is a pointer to the internal array of values. Don't try to free
     * or modify it (modifying is reserved to database provider's implementations).
     * @param num field index.
     */
    getValue(num: number): any | null
    /**
     * Marks `value` as being invalid. This method is mainly used by database
     * providers' implementations to report any error while reading a value from the database.
     * @param value a #GValue belonging to `row` (obtained with gda_row_get_value()).
     */
    invalidateValue(value: any): void
    /**
     * Marks `value` as being invalid. This method is mainly used by database
     * providers' implementations to report any error while reading a value from the database.
     * @param value a #GValue belonging to `row` (obtained with gda_row_get_value()).
     * @param error the error which lead to the invalidation
     */
    invalidateValueE(value: any, error?: GLib.Error | null): void
    /**
     * Tells if `value` has been marked as being invalid by gda_row_invalidate_value().
     * This method is mainly used by database
     * providers' implementations to report any error while reading a value from the database.
     * @param value a #GValue belonging to `row` (obtained with gda_row_get_value()).
     */
    valueIsValid(value: any): boolean
    /**
     * Tells if `value` has been marked as being invalid by gda_row_invalidate_value().
     * This method is mainly used by database
     * providers' implementations to report any error while reading a value from the database.
     * @param value a #GValue belonging to `row` (obtained with gda_row_get_value()).
     */
    valueIsValidE(value: any): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::nb-values", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nb-values", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::nb-values", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::nb-values", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::nb-values", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Row_ConstructProps)
    _init (config?: Row_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(count: number): Row
    static $gtype: GObject.Type
}
interface ServerOperation_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.ServerOperation */
    connection?: Connection
    opType?: number
    provider?: ServerProvider
    specFilename?: string
}
class ServerOperation {
    /* Properties of Gda-5.0.Gda.ServerOperation */
    readonly connection: Connection
    readonly opType: number
    readonly provider: ServerProvider
    readonly specFilename: string
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.ServerOperation */
    addItemToSequence(seqPath: string): number
    delItemFromSequence(itemPath: string): boolean
    /**
     * Get the complete path to the parent of the node defined by `path`
     * @param path a complete path to a node (starting with "/")
     */
    getNodeParent(path: string): string
    /**
     * Get the last part of `path`
     * @param path a complete path to a node (starting with "/")
     */
    getNodePathPortion(path: string): string
    /**
     * Convenience function to get the type of a node.
     * @param path a complete path to a node (starting with "/")
     * @param status a place to store the status of the node, or %NULL
     */
    getNodeType(path: string, status?: ServerOperationNodeStatus | null): ServerOperationNodeType
    /**
     * Get the type of operation `op` is for
     */
    getOpType(): ServerOperationType
    /**
     * Get an array of strings containing the paths of nodes situated at the root of `op`.
     */
    getRootNodes(): string[]
    /**
     * Fetch the contents of a sequence. `path` can describe either a sequence (for example "/SEQNAME") or an item in a sequence
     * (for example "/SEQNAME/3")
     * @param path a complete path to a sequence node (starting with "/")
     */
    getSequenceItemNames(path: string): string[]
    getSequenceMaxSize(path: string): number
    getSequenceMinSize(path: string): number
    getSequenceName(path: string): string
    getSequenceSize(path: string): number
    /**
     * This method is similar to gda_server_operation_get_value_at(), but for SQL identifiers: a new string
     * is returned instead of a #GValue. Also the returned string is assumed to represents an SQL identifier
     * and will correctly be quoted to be used with `cnc,` or `prov` if `cnc` is %NULL (a generic quoting rule
     * will be applied if both are %NULL).
     * @param cnc a #GdaConnection, or %NULL
     * @param prov a #GdaServerProvider, or %NULL
     * @param path a complete path to a node (starting with "/")
     */
    getSqlIdentifierAt(cnc: Connection | null, prov: ServerProvider | null, path: string): string
    /**
     * Get the value for the node at the `path` path
     * @param path a complete path to a node (starting with "/")
     */
    getValueAt(path: string): any | null
    /**
     * Tells if all the required values in `op` have been defined.
     * 
     * if `xml_file` is not %NULL, the validity of `op` is tested against that specification,
     * and not against the current `op'`s specification.
     * @param xmlFile an XML specification file (see gda_server_operation_new()) or %NULL
     */
    isValid(xmlFile?: string | null): boolean
    /**
     * Loads the contents of `node` into `op`. The XML tree passed through the `node`
     * argument must correspond to an XML tree saved using gda_server_operation_save_data_to_xml().
     * @param node a #xmlNodePtr
     */
    loadDataFromXml(node: libxml2.NodePtr): boolean
    /**
     * Creates a new database using the specifications in `op`. `op` can be obtained using
     * gda_server_provider_create_operation(), or gda_server_operation_prepare_create_database().
     * @param provider the database provider to use, or %NULL if `op` has been created using gda_server_operation_prepare_create_database()
     */
    performCreateDatabase(provider?: string | null): boolean
    /**
     * Performs a prepared #GdaServerOperation to create a table. This could perform
     * an operation created by #gda_server_operation_prepare_create_table or any other using the
     * the #GdaServerOperation API.
     */
    performCreateTable(): boolean
    /**
     * Destroys an existing database using the specifications in `op`. `op` can be obtained using
     * gda_server_provider_create_operation(), or gda_server_operation_prepare_drop_database().
     * @param provider the database provider to use, or %NULL if `op` has been created using gda_server_operation_prepare_drop_database()
     */
    performDropDatabase(provider?: string | null): boolean
    /**
     * This is just a convenient function to perform a drop a table operation.
     */
    performDropTable(): boolean
    /**
     * Set the value for the node at the path formed using `path_format` and the ... ellipse (the rules are the same as
     * for g_strdup_printf()).
     * 
     * Note that trying to set a value for a path which is not used by the current
     * provider, such as "/TABLE_OPTIONS_P/TABLE_ENGINE" for a PostgreSQL connection (this option is only supported for MySQL),
     * will <emphasis>not</emphasis> generate
     * any error; this allows one to give values to a superset of the parameters and thus use the same code for several providers.
     * 
     * Here are the possible formats of `path_format:`
     * <itemizedlist>
     *  <listitem><para>If the path corresponds to a #GdaHolder, then the parameter is set to <![CDATA["`value"`]]></para></listitem>
     *  <listitem><para>If the path corresponds to a sequence item like for example "/SEQUENCE_NAME/5/NAME" for
     *     the "NAME" value of the 6th item of the "SEQUENCE_NAME" sequence then:
     *     <itemizedlist>
     *        <listitem><para>if the sequence already has 6 or more items, then the value is just set to the corresponding
     *           value in the 6th item of the sequence</para></listitem>
     *        <listitem><para>if the sequence has less then 6 items, then items are added up to the 6th one before setting
     *           the value to the corresponding in the 6th item of the sequence</para></listitem>
     *     </itemizedlist>
     *  </para></listitem>
     *  <listitem><para>If the path corresponds to a #GdaDataModel, like for example "/ARRAY/`@`COLUMN/5" for the value at the
     *     6th row of the "COLUMN" column of the "ARRAY" data model, then:
     *     <itemizedlist>
     *        <listitem><para>if the data model already contains 6 or more rows, then the value is just set</para></listitem>
     *        <listitem><para>if the data model has less than 6 rows, then rows are added up to the 6th one before setting
     *           the value</para></listitem>
     *     </itemizedlist>
     *  </para></listitem>
     * </itemizedlist>
     * @param value a string
     * @param path a complete path to a node (starting with "/")
     */
    setValueAt(value: string | null, path: string): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.ServerOperation */
    /**
     * Gets emitted whenever a new sequence item (from a sequence template) has been added
     * @param seqPath the path to the new sequence item
     * @param itemIndex the index (starting from 0) of the new sequence item in the sequence
     */
    connect(sigName: "sequence-item-added", callback: ((seqPath: string, itemIndex: number) => void)): number
    on(sigName: "sequence-item-added", callback: (seqPath: string, itemIndex: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "sequence-item-added", callback: (seqPath: string, itemIndex: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "sequence-item-added", callback: (seqPath: string, itemIndex: number) => void): NodeJS.EventEmitter
    emit(sigName: "sequence-item-added", seqPath: string, itemIndex: number): void
    /**
     * Gets emitted whenever a sequence item is about to be removed
     * @param seqPath the path to the sequence item to be removed
     * @param itemIndex the index (starting from 0) of the sequence item in the sequence
     */
    connect(sigName: "sequence-item-remove", callback: ((seqPath: string, itemIndex: number) => void)): number
    on(sigName: "sequence-item-remove", callback: (seqPath: string, itemIndex: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "sequence-item-remove", callback: (seqPath: string, itemIndex: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "sequence-item-remove", callback: (seqPath: string, itemIndex: number) => void): NodeJS.EventEmitter
    emit(sigName: "sequence-item-remove", seqPath: string, itemIndex: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::op-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::op-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::op-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::op-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::op-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::spec-filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::spec-filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::spec-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::spec-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::spec-filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ServerOperation_ConstructProps)
    _init (config?: ServerOperation_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(opType: ServerOperationType, xmlFile: string): ServerOperation
    static errorQuark(): GLib.Quark
    /**
     * Get a string version of `type`
     * @param type a #GdaServerOperationType value
     */
    static opTypeToString(type: ServerOperationType): string
    /**
     * Creates a new #GdaServerOperation object which contains the specifications required
     * to create a database. Once these specifications provided, use
     * gda_server_operation_perform_create_database() to perform the database creation.
     * 
     * If `db_name` is left %NULL, then the name of the database to create will have to be set in the
     * returned #GdaServerOperation using gda_server_operation_set_value_at().
     * @param provider the database provider to use
     * @param dbName the name of the database to create, or %NULL
     */
    static prepareCreateDatabase(provider: string, dbName?: string | null): ServerOperation | null
    /**
     * Creates a new #GdaServerOperation object which contains the specifications required
     * to drop a database. Once these specifications provided, use
     * gda_server_operation_perform_drop_database() to perform the database creation.
     * 
     * If `db_name` is left %NULL, then the name of the database to drop will have to be set in the
     * returned #GdaServerOperation using gda_server_operation_set_value_at().
     * @param provider the database provider to use
     * @param dbName the name of the database to drop, or %NULL
     */
    static prepareDropDatabase(provider: string, dbName?: string | null): ServerOperation | null
    /**
     * This is just a convenient function to create a #GdaServerOperation to drop a
     * table in an opened connection.
     * @param cnc an opened connection
     * @param tableName name of the table to drop
     */
    static prepareDropTable(cnc: Connection, tableName: string): ServerOperation | null
    /**
     * Performs the reverse of gda_server_operation_op_type_to_string()
     * @param str a string
     */
    static stringToOpType(str: string): ServerOperationType
    static $gtype: GObject.Type
}
interface ServerProvider_ConstructProps extends GObject.Object_ConstructProps {
}
class ServerProvider {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.ServerProvider */
    /**
     * Creates a new #GdaServerOperation object which can be modified in order to perform the `type` type of
     * action. The `options` can contain:
     * <itemizedlist>
     *  <listitem>named values which ID is a path in the resulting GdaServerOperation object, to initialize some value</listitem>
     *  <listitem>named values which may change the contents of the GdaServerOperation, see <link linkend="gda-server-op-information-std">this section</link> for more information</listitem>
     * </itemizedlist>
     * @param cnc a #GdaConnection object which will be used to perform an action, or %NULL
     * @param type the type of operation requested
     * @param options a list of parameters or %NULL
     */
    createOperation(cnc: Connection | null, type: ServerOperationType, options?: Set | null): ServerOperation | null
    /**
     * Creates a new #GdaSqlParser object which is adapted to `provider` (and possibly depending on
     * `cnc` for the actual database version).
     * 
     * If `prov` does not have its own parser, then %NULL is returned, and a general SQL parser can be obtained
     * using gda_sql_parser_new().
     * @param cnc a #GdaConnection, or %NULL
     */
    createParser(cnc?: Connection | null): SqlParser
    /**
     * Escapes `str` for use within an SQL command (to avoid SQL injection attacks). Note that the returned value still needs
     * to be enclosed in single quotes before being used in an SQL statement.
     * @param cnc a #GdaConnection object, or %NULL
     * @param str a string to escape
     */
    escapeString(cnc: Connection | null, str: string): string
    /**
     * Finds the location of a `filename`. This function should only be used by database provider's
     * implementations
     * @param instDir directory where `prov` is installed
     * @param filename name of the file to find
     */
    findFile(instDir: string, filename: string): string
    /**
     * Find a #GdaDataHandler object to manipulate data of type `for_type`.
     * 
     * Note: this function is currently very poorly implemented by database providers.
     * @param cnc a #GdaConnection object, or %NULL
     * @param forType a DBMS type definition
     */
    getDataHandlerDbms(cnc: Connection | null, forType: string): DataHandler
    /**
     * Provides the implementation when the default Libgda's data handlers must be used
     * @param cnc a #GdaConnection object, or %NULL
     * @param type a #GType
     * @param dbmsType a DBMS type definition
     */
    getDataHandlerDefault(cnc: Connection | null, type: GObject.Type, dbmsType: string): DataHandler
    /**
     * Find a #GdaDataHandler object to manipulate data of type `for_type`. The returned object must not be modified.
     * @param cnc a #GdaConnection object, or %NULL
     * @param forType a #GType
     */
    getDataHandlerGType(cnc: Connection | null, forType: GObject.Type): DataHandler
    /**
     * Get the name of the most common data type which has `type` type.
     * 
     * The returned value may be %NULL either if the provider does not implement that method, or if
     * there is no DBMS data type which could contain data of the `g_type` type (for example %NULL may be
     * returned if a DBMS has integers only up to 4 bytes and a #G_TYPE_INT64 is requested).
     * @param cnc a #GdaConnection object or %NULL
     * @param type a #GType value type
     */
    getDefaultDbmsType(cnc: Connection | null, type: GObject.Type): string | null
    /**
     * Get the name (identifier) of the provider
     */
    getName(): string
    /**
     * Get the version of the database to which the connection is opened.
     * @param cnc a #GdaConnection object
     */
    getServerVersion(cnc: Connection): string
    /**
     * Get the version of the provider.
     */
    getVersion(): string
    handlerDeclare(dh: DataHandler, cnc: Connection, gType: GObject.Type, dbmsType: string): void
    /**
     * Reserved to database provider's implementations: get the #GdaDataHandler associated to `prov`
     * for connection `cnc`. You probably want to use gda_server_provider_get_data_handler_g_type().
     * @param cnc a #GdaConnection
     * @param gType a #GType
     * @param dbmsType a database type
     */
    handlerFind(cnc: Connection | null, gType: GObject.Type, dbmsType?: string | null): DataHandler
    /**
     * This is a factory method to get a unique instance of a #GdaSqlParser object
     * for each #GdaServerProvider object
     * Don't unref it.
     */
    internalGetParser(): SqlParser
    /**
     * Performs the operation described by `op`. Note that `op` is not destroyed by this method
     * and can be reused.
     * @param cnc a #GdaConnection object which will be used to perform the action, or %NULL
     * @param op a #GdaServerOperation object
     */
    performOperation(cnc: Connection | null, op: ServerOperation): boolean
    /**
     * Performs the operation described by `op,` using the SQL from the rendering of the operation
     * @param cnc a #GdaConnection object which will be used to perform an action, or %NULL
     * @param op a #GdaServerOperation object
     */
    performOperationDefault(cnc: Connection | null, op: ServerOperation): boolean
    /**
     * Creates an SQL statement (possibly using some specific extensions of the DBMS) corresponding to the
     * `op` operation. Note that the returned string may actually contain more than one SQL statement.
     * 
     * This function's purpose is mainly informative to get the actual SQL code which would be executed to perform
     * the operation; to actually perform the operation, use gda_server_provider_perform_operation().
     * @param cnc a #GdaConnection object which will be used to render the action, or %NULL
     * @param op a #GdaServerOperation object
     */
    renderOperation(cnc: Connection | null, op: ServerOperation): string | null
    /**
     * Use `provider` to create a new #GValue from a single string representation.
     * 
     * The `preferred_type` can optionally ask `provider` to return a #GValue of the requested type
     * (but if such a value can't be created from `string,` then %NULL is returned);
     * pass #G_TYPE_INVALID if any returned type is acceptable.
     * 
     * The returned value is either a new #GValue or %NULL in the following cases:
     * - `string` cannot be converted to `preferred_type` type
     * - the provider does not handle `preferred_type`
     * - the provider could not make a #GValue from `string`
     * 
     * If `dbms_type` is not %NULL, then if will contain a constant string representing
     * the database type used for the conversion if the conversion was successfull, or %NULL
     * otherwise.
     * @param cnc a #GdaConnection object, or %NULL
     * @param string the SQL string to convert to a value
     * @param preferredType a #GType, or #G_TYPE_INVALID
     * @param dbmsType place to get the actual database type used if the conversion succeeded, or %NULL
     */
    stringToValue(cnc: Connection | null, string: string, preferredType: GObject.Type, dbmsType?: string | null): any
    /**
     * Tests if a feature is supported
     * @param cnc a #GdaConnection object, or %NULL
     * @param feature #GdaConnectionFeature feature to test
     */
    supportsFeature(cnc: Connection | null, feature: ConnectionFeature): boolean
    /**
     * Tells if `provider` supports the `type` of operation on the `cnc` connection, using the
     * (optional) `options` parameters.
     * @param cnc a #GdaConnection object which would be used to perform an action, or %NULL
     * @param type the type of operation requested
     * @param options a list of named parameters, or %NULL
     */
    supportsOperation(cnc: Connection | null, type: ServerOperationType, options?: Set | null): boolean
    /**
     * Unescapes `str` for use within an SQL command. This is the exact opposite of gda_server_provider_escape_string().
     * @param cnc a #GdaConnection object, or %NULL
     * @param str a string to escape
     */
    unescapeString(cnc: Connection | null, str: string): string
    /**
     * Produces a fully quoted and escaped string from a GValue
     * @param cnc a #GdaConnection object, or %NULL
     * @param from #GValue to convert from
     */
    valueToSqlString(cnc: Connection | null, from: any): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ServerProvider_ConstructProps)
    _init (config?: ServerProvider_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    /**
     * Loads and returns the contents of `filename,` which is searched in several places
     * This function should only be used by database provider's
     * implementations
     * @param instDir directory where the database provider has been installed
     * @param dataDir DATA directory to look for ($prefix/share)
     * @param filename name of the file to load
     */
    static loadFileContents(instDir: string, dataDir: string, filename: string): string
    static $gtype: GObject.Type
}
interface Set_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.Set */
    description?: string
    holders?: object
    id?: string
    name?: string
    /**
     * Defines if the "validate-set" signal gets emitted when
     * any holder in the data set changes. This property also affects the
     * GdaHolder:validate-changes property.
     */
    validateChanges?: boolean
}
class Set {
    /* Properties of Gda-5.0.Gda.Set */
    description: string
    readonly holders: object
    id: string
    name: string
    /**
     * Defines if the "validate-set" signal gets emitted when
     * any holder in the data set changes. This property also affects the
     * GdaHolder:validate-changes property.
     */
    validateChanges: boolean
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Set */
    /**
     * Adds `holder` to the list of holders managed within `set`.
     * 
     * NOTE: if `set` already has a #GdaHolder with the same ID as `holder,` then `holder`
     * will not be added to the set (even if `holder'`s type or value is not the same as the
     * one already in `set)`.
     * @param holder a #GdaHolder object
     */
    addHolder(holder: Holder): boolean
    /**
     * Creates a new #GdaSet object, copy of `set`
     */
    copy(): Set
    /**
     * Finds a #GdaSetGroup which lists a  #GdaSetNode containing `holder,`
     * don't modify the returned structure.
     * @param holder a #GdaHolder object
     */
    getGroup(holder: Holder): SetGroup
    /**
     * Finds a #GdaHolder using its ID
     * @param holderId the ID of the requested value holder
     */
    getHolder(holderId: string): Holder
    /**
     * Get the value of the #GdaHolder which ID is `holder_id`
     * @param holderId the ID of the holder to set the value
     */
    getHolderValue(holderId: string): any | null
    /**
     * Finds a #GdaSetNode holding information for `holder,` don't modify the returned structure
     * @param holder a #GdaHolder object
     */
    getNode(holder: Holder): SetNode
    /**
     * Finds a #GdaHolder using its position
     * @param pos the position of the requested #GdaHolder, starting at %0
     */
    getNthHolder(pos: number): Holder
    /**
     * Finds a #GdaSetSource which contains the #GdaDataModel restricting the possible values of
     * `holder,` don't modify the returned structure.
     * @param holder a #GdaHolder object
     */
    getSource(holder: Holder): SetSource
    /**
     * Finds the #GdaSetSource structure used in `set` for which `model` is a
     * the data model (the returned structure should not be modified).
     * @param model a #GdaDataModel object
     */
    getSourceForModel(model: DataModel): SetSource
    /**
     * This method tells if all `set'`s #GdaHolder objects are valid, and if
     * they represent a valid combination of values, as defined by rules
     * external to Libgda: the "validate-set" signal is emitted and if none of the signal handlers return an
     * error, then the returned value is TRUE, otherwise the return value is FALSE as soon as a signal handler
     * returns an error.
     */
    isValid(): boolean
    /**
     * Add to `set` all the holders of `set_to_merge`.
     * Note1: only the #GdaHolder of `set_to_merge` for which no holder in `set` has the same ID are merged
     * Note2: all the #GdaHolder merged in `set` are still used by `set_to_merge`.
     * @param setToMerge a #GdaSet object
     */
    mergeWithSet(setToMerge: Set): void
    /**
     * Removes a #GdaHolder from the list of holders managed by `set`
     * @param holder the #GdaHolder to remove from `set`
     */
    removeHolder(holder: Holder): void
    /**
     * Replaces `source->`data_model with `model,` which must have the same
     * characteristics as `source->`data_model (same column types)
     * 
     * Also for each #GdaHolder for which `source->`data_model is a source model,
     * this method calls gda_holder_set_source_model() with `model` to replace
     * the source by the new model
     * @param source a pointer to a #GdaSetSource in `set`
     * @param model a #GdaDataModel
     */
    replaceSourceModel(source: SetSource, model: DataModel): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.Set */
    /**
     * Gets emitted when an attribute for any of the #GdaHolder objects managed by `set` has changed
     * @param holder the GdaHolder for which an attribute changed
     * @param attrName attribute's name
     * @param attrValue attribute's value
     */
    connect(sigName: "holder-attr-changed", callback: ((holder: Holder, attrName: string, attrValue: any) => void)): number
    on(sigName: "holder-attr-changed", callback: (holder: Holder, attrName: string, attrValue: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "holder-attr-changed", callback: (holder: Holder, attrName: string, attrValue: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "holder-attr-changed", callback: (holder: Holder, attrName: string, attrValue: any) => void): NodeJS.EventEmitter
    emit(sigName: "holder-attr-changed", holder: Holder, attrName: string, attrValue: any): void
    connect(sigName: "holder-changed", callback: ((object: Holder) => void)): number
    on(sigName: "holder-changed", callback: (object: Holder) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "holder-changed", callback: (object: Holder) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "holder-changed", callback: (object: Holder) => void): NodeJS.EventEmitter
    emit(sigName: "holder-changed", object: Holder): void
    /**
     * Gets emitted when `holder` in `set` has its type finally set, in case
     * it was #GDA_TYPE_NULL
     * @param holder the #GdaHolder for which the #GType has been set
     */
    connect(sigName: "holder-type-set", callback: ((holder: Holder) => void)): number
    on(sigName: "holder-type-set", callback: (holder: Holder) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "holder-type-set", callback: (holder: Holder) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "holder-type-set", callback: (holder: Holder) => void): NodeJS.EventEmitter
    emit(sigName: "holder-type-set", holder: Holder): void
    /**
     * Gets emitted when `set'`s public data (#GdaSetNode, #GdaSetGroup or #GdaSetSource values) have changed
     */
    connect(sigName: "public-data-changed", callback: (() => void)): number
    on(sigName: "public-data-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "public-data-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "public-data-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "public-data-changed"): void
    /**
     * Gets emitted when the data model in `source` has changed
     * @param source the #GdaSetSource for which the `data_model` attribute has changed
     */
    connect(sigName: "source-model-changed", callback: ((source?: object | null) => void)): number
    on(sigName: "source-model-changed", callback: (source?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "source-model-changed", callback: (source?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "source-model-changed", callback: (source?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "source-model-changed", source?: object | null): void
    /**
     * Gets emitted when a #GdaHolder's in `set` is going to change its value. One can connect to
     * this signal to control which values `holder` can have (for example to implement some business rules)
     * @param holder the #GdaHolder which is going to change
     * @param newValue the proposed new value for `holder`
     */
    connect(sigName: "validate-holder-change", callback: ((holder: Holder, newValue: any) => GLib.Error)): number
    on(sigName: "validate-holder-change", callback: (holder: Holder, newValue: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "validate-holder-change", callback: (holder: Holder, newValue: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "validate-holder-change", callback: (holder: Holder, newValue: any) => void): NodeJS.EventEmitter
    emit(sigName: "validate-holder-change", holder: Holder, newValue: any): void
    /**
     * Gets emitted when gda_set_is_valid() is called, use
     * this signal to control which combination of values `set'`s holder can have (for example to implement some business rules)
     */
    connect(sigName: "validate-set", callback: (() => GLib.Error)): number
    on(sigName: "validate-set", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "validate-set", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "validate-set", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "validate-set"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::holders", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::holders", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::holders", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::holders", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::holders", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::validate-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::validate-changes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::validate-changes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Set_ConstructProps)
    _init (config?: Set_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(holders: Holder[]): Set
    static newFromSpecNode(xmlSpec: libxml2.NodePtr): Set
    static newFromSpecString(xmlSpec: string): Set
    static newReadOnly(holders: Holder[]): Set
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
class Short {
    static name: string
}
interface SqlBuilder_ConstructProps extends GObject.Object_ConstructProps {
}
class SqlBuilder {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.SqlBuilder */
    /**
     * Creates a new CASE ... WHEN ... THEN ... ELSE ... END expression. The WHEN expression and the THEN
     * expression IDs are taken from the `when_array` and `then_array` at the same index, for each index inferior to
     * `args_size`.
     * @param testExpr the expression ID representing the test of the CASE, or %0
     * @param elseExpr the expression ID representing the ELSE expression, or %0
     * @param whenArray an array containing each WHEN expression ID, having at least `args_size` elements
     * @param thenArray an array containing each THEN expression ID, having at least `args_size` elements
     */
    addCase(testExpr: SqlBuilderId, elseExpr: SqlBuilderId, whenArray: SqlBuilderId[], thenArray: SqlBuilderId[]): SqlBuilderId
    /**
     * Builds a new expression which represents a condition (or operation).
     * @param op type of condition
     * @param op1 the ID of the 1st argument (not 0)
     * @param op2 the ID of the 2nd argument (may be %0 if `op` needs only one operand)
     * @param op3 the ID of the 3rd argument (may be %0 if `op` needs only one or two operand)
     */
    addCond(op: SqlOperatorType, op1: SqlBuilderId, op2: SqlBuilderId, op3: SqlBuilderId): SqlBuilderId
    /**
     * Builds a new expression which represents a condition (or operation).
     * 
     * As a side case, if `ops_ids_size` is 1,
     * then `op` is ignored, and the returned ID represents `op_ids[`0] (this avoids any problem for example
     * when `op` is GDA_SQL_OPERATOR_TYPE_AND and there is in fact only one operand).
     * @param op type of condition
     * @param opIds an array of ID for the arguments (not %0)
     */
    addCondV(op: SqlOperatorType, opIds: SqlBuilderId[]): SqlBuilderId
    /**
     * Defines an expression in `builder` which may be reused to build other parts of a statement.
     * 
     * The new expression will contain the value passed as the `value` argument.
     * 
     * If `value'`s type is a string then it is possible to customize how the value has to be interpreted by passing a
     * specific #GdaDataHandler object as `dh`. This feature is very rarely used and the `dh` argument should generally
     * be %NULL.
     * @param dh deprecated useless argument, just pass %NULL
     * @param value value to set the expression to, or %NULL or a GDA_TYPE_NULL value to represent an SQL NULL
     */
    addExprValue(dh?: DataHandler | null, value?: any | null): SqlBuilderId
    /**
     * Defines an expression representing a field in `builder,`
     * which may be reused to build other parts of a statement,
     * for instance as a parameter to gda_sql_builder_add_cond() or
     * gda_sql_builder_add_field_value_id().
     * 
     * Calling this with a %NULL `table_name` is equivalent to calling gda_sql_builder_add_id().
     * 
     * For SELECT queries, see gda_sql_builder_select_add_field().
     * @param fieldName a field name
     * @param tableName a table name, or %NULL
     */
    addFieldId(fieldName: string, tableName?: string | null): SqlBuilderId
    /**
     * Valid only for: INSERT, UPDATE statements.
     * 
     * Specifies that the field represented by `field_name` will be set to the value identified
     * by `value`
     * @param fieldName a field name
     * @param value value to set the field to, or %NULL or a GDA_TYPE_NULL value to represent an SQL NULL
     */
    addFieldValueAsGvalue(fieldName: string, value?: any | null): void
    /**
     * Valid only for: INSERT, UPDATE, SELECT statements
     * <itemizedlist>
     * <listitem><para>For UPDATE: specifies that the field represented by `field_id` will be set to the value identified
     *    by `value_id`.</para></listitem>
     * <listitem><para>For SELECT: add a selected item to the statement, and if `value_id` is not %0, then use it as an
     *    alias</para></listitem>
     * <listitem><para>For INSERT: if `field_id` represents an SQL identifier (obtained using gda_sql_builder_add_id()): then if
     *    `value_id` is not %0 then specifies that the field represented by `field_id` will be set to the
     *    value identified by `value_id,` otherwise just specifies a named field to be given a value.
     *    If `field_id` represents a sub SELECT (obtained using gda_sql_builder_add_sub_select()), then
     *    this method call defines the sub SELECT from which values to insert are taken.</para></listitem>
     * </itemizedlist>
     * 
     * See also gda_sql_builder_add_field_value() and gda_sql_builder_add_field_value_as_gvalue().
     * @param fieldId the ID of the field's name or definition
     * @param valueId the ID of the value to set the field to, or %0
     */
    addFieldValueId(fieldId: SqlBuilderId, valueId: SqlBuilderId): void
    /**
     * Builds a new expression which represents a function applied to some arguments
     * @param funcName the functions's name
     * @param args an array of IDs representing the function's arguments
     */
    addFunction(funcName: string, args: SqlBuilderId[]): SqlBuilderId
    /**
     * Defines an expression representing an identifier in `builder,`
     * which may be reused to build other parts of a statement,
     * for instance as a parameter to gda_sql_builder_add_cond() or
     * gda_sql_builder_add_field_value_id().
     * 
     * The new expression will contain the `str` literal.
     * For example:
     * <programlisting>
     * gda_sql_builder_add_id (b, "name")
     * gda_sql_builder_add_id (b, "date")
     * </programlisting>
     * 
     * will be rendered as SQL as:
     * <programlisting>
     * name
     * "date"
     * </programlisting>
     * 
     * because "date" is an SQL reserved keyword.
     * 
     * For fields, see gda_sql_builder_add_field_id().
     * @param str a string
     */
    addId(str: string): SqlBuilderId
    /**
     * Defines a parameter in `builder` which may be reused to build other parts of a statement.
     * 
     * The new expression will contain the `string` literal.
     * For example:
     * <programlisting>
     * gda_sql_builder_add_param (b, "age", G_TYPE_INT, FALSE)
     * </programlisting>
     * 
     * will be rendered as SQL as:
     * <programlisting><![CDATA[
     * ##age::int
     * ]]>
     * </programlisting>
     * @param paramName parameter's name
     * @param type parameter's type
     * @param nullok TRUE if the parameter can be set to %NULL
     */
    addParam(paramName: string, type: GObject.Type, nullok: boolean): SqlBuilderId
    /**
     * Add a sub select to a COMPOUND statement
     * @param subselect a #GdaSqlBuilder, which has to be a SELECT or compound SELECT. This will be copied.
     */
    compoundAddSubSelectFromBuilder(subselect: SqlBuilder): void
    /**
     * Changes the type of compound which `builder` is making, for a COMPOUND statement
     * @param compoundType a type of compound
     */
    compoundSetType(compoundType: SqlStatementCompoundType): void
    /**
     * Creates a new #GdaStatement statement from `builder'`s contents.
     */
    getStatement(): Statement
    /**
     * Imports the an expression located in `query` into `builder`.
     * @param query a #GdaSqlBuilder object to get expression from
     * @param exprId a #GdaSqlBuilderId of the expression in `query`
     */
    importExpressionFromBuilder(query: SqlBuilder, exprId: SqlBuilderId): SqlBuilderId
    /**
     * Alter a join in a SELECT statement to make its condition use equal field
     * values in the fields named `field_name` in both tables, via the USING keyword.
     * @param joinId the ID of the join to modify (not %0)
     * @param fieldName the name of the field to use in the join condition (not %NULL)
     */
    joinAddField(joinId: SqlBuilderId, fieldName: string): void
    /**
     * Valid only for: SELECT statements.
     * 
     * Add a selected selected item to the SELECT statement.
     * 
     * For non-SELECT statements, see gda_sql_builder_add_field_id().
     * @param fieldName a field name
     * @param tableName a table name, or %NULL
     * @param alias an alias (eg. for the "AS" clause), or %NULL
     */
    selectAddField(fieldName: string, tableName?: string | null, alias?: string | null): SqlBuilderId
    /**
     * Adds a new target to a SELECT statement
     * @param tableName the name of the target table
     * @param alias the alias to give to the target, or %NULL
     */
    selectAddTarget(tableName: string, alias?: string | null): SqlBuilderId
    /**
     * Adds a new target to a SELECT statement. If there already exists a target representing
     * the same table and the same alias (or with the same absence of alias) then the same target
     * ID is returned instead of the ID of a new target.
     * @param tableId the ID of the expression holding a table reference (not %0)
     * @param alias the alias to give to the target, or %NULL
     */
    selectAddTargetId(tableId: SqlBuilderId, alias?: string | null): SqlBuilderId
    /**
     * Valid only for: SELECT statements
     * 
     * Adds the `expr_id` expression to the GROUP BY clause's expressions list
     * @param exprId the ID of the expression to set use in the GROUP BY clause, or 0 to unset any previous GROUP BY clause
     */
    selectGroupBy(exprId: SqlBuilderId): void
    /**
     * Adds a new ORDER BY expression to a SELECT statement.
     * @param exprId the ID of the expression to use during sorting (not %0)
     * @param asc %TRUE for an ascending sorting
     * @param collationName name of the collation to use when sorting, or %NULL
     */
    selectOrderBy(exprId: SqlBuilderId, asc: boolean, collationName?: string | null): void
    /**
     * Defines (if `distinct` is %TRUE) or removes (if `distinct` is %FALSE) a DISTINCT clause
     * for a SELECT statement.
     * 
     * If `distinct` is %TRUE, then the ID of an expression can be specified as the `expr_id` argument:
     * if not %0, this is the expression used to apply the DISTINCT clause on (the resuting SQL
     * will then usually be "... DISTINCT ON &lt;expression&gt;...").
     * @param distinct set to %TRUE to have the DISTINCT requirement
     * @param exprId the ID of the DISTINCT ON expression, or %0 if no expression is to be used. It is ignored           if `distinct` is %FALSE.
     */
    selectSetDistinct(distinct: boolean, exprId: SqlBuilderId): void
    /**
     * Valid only for: SELECT statements
     * 
     * Sets the HAVING condition of the statement
     * @param condId the ID of the expression to set as HAVING condition, or 0 to unset any previous HAVING condition
     */
    selectSetHaving(condId: SqlBuilderId): void
    /**
     * If `limit_count_expr_id` is not %0, defines the maximum number of rows in the #GdaDataModel
     * resulting from the execution of the built statement. In this case, the offset from which the
     * rows must be collected can be defined by the `limit_offset_expr_id` expression if not %0 (note that
     * this feature may not be supported by all the database providers).
     * 
     * If `limit_count_expr_id` is %0, then removes any LIMIT which may have been imposed by a previous
     * call to this method.
     * @param limitCountExprId the ID of the LIMIT expression, or %0
     * @param limitOffsetExprId the ID of the OFFSET expression, or %0
     */
    selectSetLimit(limitCountExprId: SqlBuilderId, limitOffsetExprId: SqlBuilderId): void
    /**
     * Valid only for: INSERT, UPDATE, DELETE statements
     * 
     * Sets the name of the table on which the built statement operates.
     * @param tableName a table name
     */
    setTable(tableName: string): void
    /**
     * Valid only for: UPDATE, DELETE, SELECT statements
     * 
     * Sets the WHERE condition of the statement
     * @param condId the ID of the expression to set as WHERE condition, or 0 to unset any previous WHERE condition
     */
    setWhere(condId: SqlBuilderId): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SqlBuilder_ConstructProps)
    _init (config?: SqlBuilder_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(stmtType: SqlStatementType): SqlBuilder
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface SqlParser_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.SqlParser */
    mode?: number
    tokenizerFlavour?: number
}
class SqlParser {
    /* Properties of Gda-5.0.Gda.SqlParser */
    readonly columnError: number
    readonly lineError: number
    mode: number
    tokenizerFlavour: number
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.SqlParser */
    /**
     * Parse `filename'`s contents and creates a #GdaBatch object which contains all the
     *  #GdaStatement objects created while parsing (one object per SQL statement).
     * 
     * `filename'`s contents are parsed and #GdaStatement objects are created as long as no error is found. If an error is found
     * at some point, then the parsing stops, `error` may be set and %NULL is returned
     * 
     * if `sql` is %NULL, then the returned #GdaBatch object will contain no statement.
     * @param filename name of the file to parse
     */
    parseFileAsBatch(filename: string): Batch | null
    /**
     * Parses `sql` and creates a #GdaStatement statement from the first SQL statement contained in `sql:` if `sql`
     * contains more than one statement, then the remaining part of the string is not parsed at all, and `remain` (if
     * not %NULL) will point at the first non parsed character.
     * 
     * To include variables in the `sql` string, see the
     * <link linkend="GdaSqlParser.description">GdaSqlParser's object description</link>.
     * @param sql the SQL string to parse
     */
    parseString(sql: string): [ /* returnType */ Statement | null, /* remain */ string | null ]
    /**
     * Parse `sql` and creates a #GdaBatch object which contains all the #GdaStatement objects created while parsing (one object
     * per SQL statement). Empty statements (composed of spaces only) do not appear in the resulting object.
     * 
     * `sql` is parsed and #GdaStatement objects are created as long as no error is found in `sql`. If an error is found
     * at some point, then the parsing stops and `remain` may contain a non %NULL pointer, `error` may be set, and %NULL
     * is returned.
     * 
     * if `sql` is %NULL, then the returned #GdaBatch object will contain no statement.
     * 
     * To include variables in the `sql` string, see the
     * <link linkend="GdaSqlParser.description">GdaSqlParser's object description</link>.
     * @param sql the SQL string to parse
     */
    parseStringAsBatch(sql: string): [ /* returnType */ Batch | null, /* remain */ string | null ]
    setOverflowError(): void
    setSyntaxError(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Methods of Gda-5.0.Gda.Lockable */
    /**
     * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
     * by the other thread.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    lock(): void
    /**
     * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
     * it locks `lockable`.
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     * 
     * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
     * (and has to unlock it as many times to actually unlock it).
     */
    trylock(): boolean
    /**
     * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
     * used gda_lockable_lock() or gda_lockable_trylock()).
     * 
     * This function can be used even if g_thread_init() has not yet been called, and, in that case, will do nothing.
     */
    unlock(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::column-error", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::column-error", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::column-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::column-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::column-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::line-error", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::line-error", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::line-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::line-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::line-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::tokenizer-flavour", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tokenizer-flavour", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::tokenizer-flavour", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::tokenizer-flavour", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::tokenizer-flavour", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SqlParser_ConstructProps)
    _init (config?: SqlParser_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SqlParser
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface Statement_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.Statement */
    structure?: object
}
class Statement {
    /* Properties of Gda-5.0.Gda.Statement */
    structure: object
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Statement */
    /**
     * Checks that `stmt'`s structure is correct.
     */
    checkStructure(): boolean
    /**
     * If `cnc` is not %NULL then checks that every object (table, field, function) used in `stmt`
     * actually exists in `cnc'`s database
     * 
     * If `cnc` is %NULL, then cleans anything related to `cnc` in `stmt`.
     * 
     * See gda_sql_statement_check_validity() for more information.
     * @param cnc a #GdaConnection object, or %NULL
     */
    checkValidity(cnc?: Connection | null): boolean
    /**
     * Copy constructor
     */
    copy(): Statement
    /**
     * Get a new #GdaSet object which groups all the execution parameters
     * which `stmt` needs. This new object is returned though `out_params`.
     * 
     * Note that if `stmt` does not need any parameter, then `out_params` is set to %NULL.
     */
    getParameters(): [ /* returnType */ boolean, /* outParams */ Set | null ]
    /**
     * Get the type of statement held by `stmt`. It returns GDA_SQL_STATEMENT_NONE if
     * `stmt` does not hold any statement
     */
    getStatementType(): SqlStatementType
    /**
     * Tells if `stmt` is composed only of spaces (that is it has no real SQL code), and is completely
     * useless as such.
     */
    isUseless(): boolean
    /**
     * "Normalizes" some parts of `stmt,` see gda_sql_statement_normalize() for more
     * information.
     * @param cnc a #GdaConnection object
     */
    normalize(cnc: Connection): boolean
    /**
     * Creates a string representing the contents of `stmt`.
     */
    serialize(): string
    /**
     * Renders `stmt` as an SQL statement, with some control on how it is rendered.
     * 
     * If `cnc` is not %NULL, then the rendered SQL will better be suited to be used by `cnc` (in particular
     * it may include some SQL tweaks and/or proprietary extensions specific to the database engine used by `cnc)`:
     * in this case the result is similar to calling gda_connection_statement_to_sql().
     * @param cnc a #GdaConnection object, or %NULL
     * @param params parameters contained in a single #GdaSet object, or %NULL
     * @param flags a set of flags to control the rendering
     */
    toSqlExtended(cnc: Connection | null, params: Set | null, flags: StatementSqlFlag): [ /* returnType */ string, /* paramsUsed */ Holder[] | null ]
    /**
     * Renders `stmt` to its SQL representation, using `context` to specify how each part of `stmt` must
     * be rendered. This function is mainly used by database provider's implementations which require
     * to specialize some aspects of SQL rendering to be adapted to the database,'s own SQL dialect
     * (for example SQLite rewrites the 'FALSE' and 'TRUE' literals as '0' and 'NOT 0').
     * @param context a #GdaSqlRenderingContext context
     */
    toSqlReal(context: SqlRenderingContext): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.Statement */
    /**
     * Gets emitted whenever the structure and contents
     * of the statement have been verified (emitted after gda_statement_check_validity()).
     * @param object 
     * @param p0 
     */
    connect(sigName: "checked", callback: ((object: Connection, p0: boolean) => void)): number
    on(sigName: "checked", callback: (object: Connection, p0: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "checked", callback: (object: Connection, p0: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "checked", callback: (object: Connection, p0: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "checked", object: Connection, p0: boolean): void
    /**
     * Gets emitted whenever the statement has changed
     */
    connect(sigName: "reset", callback: (() => void)): number
    on(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "reset", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "reset", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "reset"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::structure", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::structure", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::structure", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::structure", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::structure", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Statement_ConstructProps)
    _init (config?: Statement_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Statement
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface ThreadWrapper_ConstructProps extends GObject.Object_ConstructProps {
}
class ThreadWrapper {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.ThreadWrapper */
    /**
     * Cancels a job not yet executed. This may fail for the following reasons:
     * <itemizedlist>
     *  <listitem><para>the job `id` could not be found, either because it has already been treated or because
     *                  it does not exist or because it was created in another thread</para></listitem>
     *  <listitem><para>the job `id` is currently being treated by the worker thread</para></listitem>
     * </itemizedlist>
     * @param id the ID of a job as returned by gda_thread_wrapper_execute() or gda_thread_wrapper_execute_void()
     */
    cancel(id: number): boolean
    /**
     * Connects a callback function to a signal for a particular object. The difference with g_signal_connect() and
     * similar functions are:
     * <itemizedlist>
     *  <listitem><para>the `callback` argument is not a #GCallback function, so the callback signature is not
     *    dependent on the signal itself</para></listitem>
     *  <listitem><para>the signal handler must not have to return any value</para></listitem>
     *  <listitem><para>the `callback` function will be called asynchronously, the caller may need to use
     *    gda_thread_wrapper_iterate() to get the notification</para></listitem>
     *  <listitem><para>if `private_job` and `private_thread` control in which case the signal is propagated.</para></listitem>
     * </itemizedlist>
     * 
     * Also note that signal handling is done asynchronously: when emitted in the worker thread, it
     * will be "queued" to be processed in the user thread when it has the chance (when gda_thread_wrapper_iterate()
     * is called directly or indirectly). The side effect is that the callback function is usually
     * called long after the object emitting the signal has finished emitting it.
     * 
     * To disconnect a signal handler, don't use any of the g_signal_handler_*() functions but the
     * gda_thread_wrapper_disconnect() method.
     * @param instance the instance to connect to
     * @param sigName a string of the form "signal-name::detail"
     * @param privateThread set to %TRUE if `callback` is to be invoked only if the signal has    been emitted while in `wrapper'`s private sub thread (ie. used when `wrapper` is executing some functions    specified by gda_thread_wrapper_execute() or gda_thread_wrapper_execute_void()), and to %FALSE if the    callback is to be invoked whenever the signal is emitted, independently of the thread in which the    signal is emitted.
     * @param privateJob set to %TRUE if `callback` is to be invoked only if the signal has    been emitted when a job created for the calling thread is being executed, and to %FALSE    if `callback` has to be called whenever the `sig_name` signal is emitted by `instance`. Note that    this argument is not taken into account if `private_thread` is set to %FALSE.
     * @param callback a #GdaThreadWrapperCallback function
     */
    connectRaw(instance: object | null, sigName: string, privateThread: boolean, privateJob: boolean, callback: ThreadWrapperCallback): number
    /**
     * Disconnects the emission of a signal, does the opposite of gda_thread_wrapper_connect_raw().
     * 
     * As soon as this method returns, the callback function set when gda_thread_wrapper_connect_raw()
     * was called will not be called anymore (even if the object has emitted the signal in the worker
     * thread and this signal has not been handled in the user thread).
     * @param id a handler ID, as returned by gda_thread_wrapper_connect_raw()
     */
    disconnect(id: number): void
    /**
     * Make `wrapper` execute the `func` function with the `arg` argument (along with a #GError which is not `error)`
     * in the sub thread managed by `wrapper`. To execute a function which does not return anything,
     * use gda_thread_wrapper_execute_void().
     * 
     * This method returns immediately, and the caller then needs to use gda_thread_wrapper_fetch_result() to
     * check if the execution has finished and get the result.
     * 
     * Once `func'`s execution is finished, if `arg` is not %NULL, the `arg_destroy_func` destruction function is called
     * on `arg`. This call occurs in the thread calling gda_thread_wrapper_fetch_result().
     * 
     * If an error occurred in this function, then the `arg_destroy_func` function is not called to free `arg`.
     * @param func the function to execute, not %NULL
     * @param arg argument to pass to `func,` or %NULL
     */
    execute(func: ThreadWrapperFunc, arg?: object | null): number
    /**
     * Make `wrapper` execute the `func` function with the `arg` argument (along with a #GError which is not `error)`
     * in the sub thread managed by `wrapper`. To execute a function which returns some pointer,
     * use gda_thread_wrapper_execute().
     * 
     * This method returns immediately. Calling gda_thread_wrapper_fetch_result() is not necessary as `func`
     * does not return any result. However, it may be necessary to call gda_thread_wrapper_iterate() to give `wrapper` a
     * chance to execute the `arg_destroy_func` function if not %NULL (note that gda_thread_wrapper_iterate() is
     * called by gda_thread_wrapper_fetch_result() itself).
     * 
     * Once `func'`s execution is finished, if `arg` is not %NULL, the `arg_destroy_func` destruction function is called
     * on `arg`. This call occurs in the thread calling gda_thread_wrapper_fetch_result().
     * 
     * If an error occurred in this function, then the `arg_destroy_func` function is not called to free `arg`.
     * @param func the function to execute, not %NULL
     * @param arg argument to pass to `func`
     */
    executeVoid(func: ThreadWrapperVoidFunc, arg?: object | null): number
    /**
     * Use this method to check if the execution of a function is finished. The function's execution must have
     * been requested using gda_thread_wrapper_execute().
     * @param mayLock TRUE if this funct must lock the caller untill a result is available
     * @param expId ID of the job for which a result is expected
     */
    fetchResult(mayLock: boolean, expId: number): object | null
    /**
     * Allow `wrapper` to notify when an execution job is finished, by making its exec ID
     * readable through a new #GIOChannel. This function is useful when the notification needs
     * to be included into a main loop. This also notifies that signals (emitted by objects in
     * `wrapper'`s internal thread) are available.
     * 
     * The returned #GIOChannel will have something to read everytime an execution job is finished
     * for an execution job submitted from the calling thread. The user whould read #GdaThreadNotification
     * structures from the channel and analyse its contents to call gda_thread_wrapper_iterate()
     * or gda_thread_wrapper_fetch_result().
     * 
     * Note1: the new communication channel will only be operational for jobs submitted after this
     * function returns, and for signals which have been connected after this function returns. A safe
     * practice is to call this function before the `wrapper` object has been used.
     * 
     * Note2: this function will return the same #GIOChannel everytime it's called from the same thread.
     * 
     * Note3: if the usage of the returned #GIOChannel reveals an error, then g_io_channel_shutdown() and
     * g_io_channel_unref() should be called on the #GIOChannel to let `wrapper` know it should not use
     * that object anymore.
     */
    getIoChannel(): GLib.IOChannel
    /**
     * Use this method to query the number of functions which have been queued to be executed
     * but which have not yet been executed.
     */
    getWaitingSize(): number
    /**
     * This method gives `wrapper` a chance to check if some functions to be executed have finished
     * <emphasis>for the calling thread</emphasis>. In this case it handles the execution result and
     * makes it ready to be processed using gda_thread_wrapper_fetch_result().
     * 
     * This method also allows `wrapper` to handle signals which may have been emitted by objects
     * while in the worker thread, and call the callback function specified when gda_thread_wrapper_connect_raw()
     * was used.
     * 
     * If `may_block` is %TRUE, then it will block untill there is one finished execution
     * (functions returning void and signals are ignored regarding this argument).
     * @param mayBlock whether the call may block
     */
    iterate(mayBlock: boolean): void
    /**
     * Requests that the signal which ID is `id` (which has been obtained using gda_thread_wrapper_connect_raw())
     * be treated by the calling thread instead of by the thread in which gda_thread_wrapper_connect_raw()
     * was called.
     * @param id a signal ID
     */
    stealSignal(id: number): void
    /**
     * Does the opposite of gda_thread_wrapper_get_io_channel()
     */
    unsetIoChannel(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ThreadWrapper_ConstructProps)
    _init (config?: ThreadWrapper_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): ThreadWrapper
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface TransactionStatus_ConstructProps extends GObject.Object_ConstructProps {
}
class TransactionStatus {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TransactionStatus */
    find(str: string, destev: TransactionStatusEvent): TransactionStatus | null
    /**
     * Find a pointer to the "current" _unnamed_ transaction, which is the last
     * transaction if there are several nested transactions
     * @param destev 
     * @param unnamedOnly 
     */
    findCurrent(destev: TransactionStatusEvent, unnamedOnly: boolean): TransactionStatus | null
    freeEvents(event: TransactionStatusEvent, freeAfter: boolean): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TransactionStatus_ConstructProps)
    _init (config?: TransactionStatus_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name: string): TransactionStatus
    static $gtype: GObject.Type
}
interface Tree_ConstructProps extends GObject.Object_ConstructProps {
}
class Tree {
    /* Properties of Gda-5.0.Gda.Tree */
    /**
     * Tells if the GdaTree is a list or a tree.
     */
    readonly isList: boolean
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.Tree */
    /**
     * Sets `manager` as a top #GdaTreeManager object, which will be responsible for creating top level nodes in `tree`.
     * @param manager a #GdaTreeManager object
     */
    addManager(manager: TreeManager): void
    /**
     * Removes any node in `tree`
     */
    clean(): void
    /**
     * Dumps the contents of `tree` to `stream,` using a hierarchical view.
     * @param node a #GdaTreeNode to start the dump from, or %NULL for a full dump
     * @param stream a stream to send the dump to, or %NULL for STDOUT
     */
    dump(node?: TreeNode | null, stream?: object | null): void
    /**
     * Locates a #GdaTreeNode using the `tree_path` path.
     * @param treePath full path to the required nodes (if `use_names` is %TRUE, then it must start with '/')
     * @param useNames if %TRUE, then `tree_path` will be interpreted as a unix style path, and if %FALSE,             then `tree_path` will be interpreted similarly to the #GtkTreePath's string representation.
     */
    getNode(treePath: string, useNames: boolean): TreeNode | null
    /**
     * Get the #GdaTreeManager which created `node` in `tree`
     * @param node a #GdaTreeNode present in `tree`
     */
    getNodeManager(node: TreeNode): TreeManager
    /**
     * Get the path associated to `node` in `tree`.
     * @param node a #GdaTreeNode node in `tree`
     */
    getNodePath(node: TreeNode): string
    /**
     * The returned list is a list of all the #GdaTreeNode nodes <emphasis>below</emphasis> the node
     * at the specified path.
     * 
     * As a corner case if `tree_path` is %NULL, then the returned list contains all the top level nodes.
     * @param treePath full path to the required nodes (if `use_names` is %TRUE, then it must start with '/'), or %NULL
     * @param useNames if %TRUE, then `tree_path` will be interpreted as a unix style path, and if %FALSE,             then `tree_path` will be interpreted similarly to the #GtkTreePath's string representation.
     */
    getNodesInPath(treePath: string | null, useNames: boolean): TreeNode[]
    /**
     * Sets an attribute to `tree,` which will be accessible to any node in it.
     * @param attribute attribute name
     * @param value a #GValue, or %NULL
     * @param destroy a function to be called when `attribute` is not needed anymore, or %NULL
     */
    setAttribute(attribute: string, value: any, destroy: GLib.DestroyNotify): void
    /**
     * Requests that `tree` be populated with nodes. If an error occurs, then `tree'`s contents is left
     * unchanged, and otherwise `tree'`s previous contents is completely replaced by the new one.
     */
    updateAll(): boolean
    /**
     * Update the children of `node` in `tree` (not recursively, to update recursively, use
     * gda_tree_update_part()). If `node` is %NULL then the top level nodes are updated.
     * @param node a #GdaTreeNode node in `tree,` or %NULL
     */
    updateChildren(node?: TreeNode | null): boolean
    /**
     * Requests that `tree` be populated with nodes, starting from `node`
     * @param node a #GdaTreeNode node in `tree`
     */
    updatePart(node: TreeNode): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.Tree */
    /**
     * Gets emitted when a `node` has changed in `tree`
     * @param node the #GdaTreeNode which has changed
     */
    connect(sigName: "node-changed", callback: ((node: TreeNode) => void)): number
    on(sigName: "node-changed", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-changed", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-changed", callback: (node: TreeNode) => void): NodeJS.EventEmitter
    emit(sigName: "node-changed", node: TreeNode): void
    /**
     * Gets emitted when a `node` has been removed from `tree`
     * @param nodePath the position the node held in `tree` as a tree path
     */
    connect(sigName: "node-deleted", callback: ((nodePath: string) => void)): number
    on(sigName: "node-deleted", callback: (nodePath: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-deleted", callback: (nodePath: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-deleted", callback: (nodePath: string) => void): NodeJS.EventEmitter
    emit(sigName: "node-deleted", nodePath: string): void
    /**
     * Gets emitted when a `node` has has a child when it did not have any or when it
     * does not have a ny children anymore when it had some
     * @param node the #GdaTreeNode which changed from having children to being a        leaf or the other way around
     */
    connect(sigName: "node-has-child-toggled", callback: ((node: TreeNode) => void)): number
    on(sigName: "node-has-child-toggled", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-has-child-toggled", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-has-child-toggled", callback: (node: TreeNode) => void): NodeJS.EventEmitter
    emit(sigName: "node-has-child-toggled", node: TreeNode): void
    /**
     * Gets emitted when a `node` has been inserted in `tree`
     * @param node the #GdaTreeNode which has inserted
     */
    connect(sigName: "node-inserted", callback: ((node: TreeNode) => void)): number
    on(sigName: "node-inserted", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-inserted", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-inserted", callback: (node: TreeNode) => void): NodeJS.EventEmitter
    emit(sigName: "node-inserted", node: TreeNode): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::is-list", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-list", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::is-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::is-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::is-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Tree_ConstructProps)
    _init (config?: Tree_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Tree
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface TreeManager_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func?: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive?: boolean
}
class TreeManager {
    /* Properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive: boolean
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeManager */
    /**
     * Adds a sub manager to `manager`. Use this method to create the skeleton structure
     * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
     * or several times in the same #GdaTree's structure.
     * 
     * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
     * infinite recursive behaviour in this case when creating children nodes
     * (depending on the actual implementation of the #GdaTreeManager).
     * @param sub a #GdaTreeManager object to add
     */
    addManager(sub: TreeManager): void
    /**
     * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
     * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
     * 
     * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
     * @param attribute an attribute name
     * @param value the attribute's value, or %NULL
     */
    addNewNodeAttribute(attribute: string, value?: any | null): void
    /**
     * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
     * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
     * 
     * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
     * or when subclassing the #GdaTreeManager.
     * @param parent the parent the new node may have, or %NULL
     * @param name name given to the new node, or %NULL
     */
    createNode(parent?: TreeNode | null, name?: string | null): TreeNode
    /**
     * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
     */
    getManagers(): TreeManager[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeManager_ConstructProps)
    _init (config?: TreeManager_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
interface TreeMgrColumns_ConstructProps extends TreeManager_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeMgrColumns */
    /**
     * Defines the #GdaConnection to display information for. Necessary upon construction unless
     * the #GdaTreeMgrColumns:meta-store property is specified instead.
     */
    connection?: Connection
    /**
     * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
     * the #GdaTreeMgrColumns:connection property is specified instead. This property has
     * priority over the GdaTreeMgrColumns:connection property.
     */
    metaStore?: MetaStore
    /**
     * If no set, then the table name will be fetched from the parent node using the "schema" attribute
     */
    schema?: string
    /**
     * If no set, then the table name will be fetched from the parent node using the "table_name" attribute
     */
    tableName?: string
}
class TreeMgrColumns {
    /* Properties of Gda-5.0.Gda.TreeMgrColumns */
    /**
     * Defines the #GdaConnection to display information for. Necessary upon construction unless
     * the #GdaTreeMgrColumns:meta-store property is specified instead.
     */
    readonly connection: Connection
    /**
     * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
     * the #GdaTreeMgrColumns:connection property is specified instead. This property has
     * priority over the GdaTreeMgrColumns:connection property.
     */
    readonly metaStore: MetaStore
    /**
     * If no set, then the table name will be fetched from the parent node using the "schema" attribute
     */
    readonly schema: string
    /**
     * If no set, then the table name will be fetched from the parent node using the "table_name" attribute
     */
    readonly tableName: string
    /* Properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive: boolean
    /* Fields of Gda-5.0.Gda.TreeManager */
    object: GObject.Object
    priv: TreeManagerPrivate
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeManager */
    /**
     * Adds a sub manager to `manager`. Use this method to create the skeleton structure
     * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
     * or several times in the same #GdaTree's structure.
     * 
     * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
     * infinite recursive behaviour in this case when creating children nodes
     * (depending on the actual implementation of the #GdaTreeManager).
     * @param sub a #GdaTreeManager object to add
     */
    addManager(sub: TreeManager): void
    /**
     * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
     * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
     * 
     * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
     * @param attribute an attribute name
     * @param value the attribute's value, or %NULL
     */
    addNewNodeAttribute(attribute: string, value?: any | null): void
    /**
     * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
     * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
     * 
     * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
     * or when subclassing the #GdaTreeManager.
     * @param parent the parent the new node may have, or %NULL
     * @param name name given to the new node, or %NULL
     */
    createNode(parent?: TreeNode | null, name?: string | null): TreeNode
    /**
     * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
     */
    getManagers(): TreeManager[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::schema", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::schema", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::table-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::table-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::table-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::table-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::table-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeMgrColumns_ConstructProps)
    _init (config?: TreeMgrColumns_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(cnc: Connection, schema: string, tableName: string): TreeMgrColumns
    static $gtype: GObject.Type
}
interface TreeMgrLabel_ConstructProps extends TreeManager_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeMgrLabel */
    label?: string
}
class TreeMgrLabel {
    /* Properties of Gda-5.0.Gda.TreeMgrLabel */
    readonly label: string
    /* Properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive: boolean
    /* Fields of Gda-5.0.Gda.TreeManager */
    object: GObject.Object
    priv: TreeManagerPrivate
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeManager */
    /**
     * Adds a sub manager to `manager`. Use this method to create the skeleton structure
     * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
     * or several times in the same #GdaTree's structure.
     * 
     * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
     * infinite recursive behaviour in this case when creating children nodes
     * (depending on the actual implementation of the #GdaTreeManager).
     * @param sub a #GdaTreeManager object to add
     */
    addManager(sub: TreeManager): void
    /**
     * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
     * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
     * 
     * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
     * @param attribute an attribute name
     * @param value the attribute's value, or %NULL
     */
    addNewNodeAttribute(attribute: string, value?: any | null): void
    /**
     * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
     * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
     * 
     * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
     * or when subclassing the #GdaTreeManager.
     * @param parent the parent the new node may have, or %NULL
     * @param name name given to the new node, or %NULL
     */
    createNode(parent?: TreeNode | null, name?: string | null): TreeNode
    /**
     * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
     */
    getManagers(): TreeManager[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::label", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeMgrLabel_ConstructProps)
    _init (config?: TreeMgrLabel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(label: string): TreeMgrLabel
    static $gtype: GObject.Type
}
interface TreeMgrLdap_ConstructProps extends TreeManager_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeMgrLdap */
    /**
     * Defines the Distinguised Name of the LDAP entry to list children from
     */
    dn?: string
}
class TreeMgrLdap {
    /* Properties of Gda-5.0.Gda.TreeMgrLdap */
    /**
     * Defines the Distinguised Name of the LDAP entry to list children from
     */
    readonly dn: string
    /* Properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive: boolean
    /* Fields of Gda-5.0.Gda.TreeManager */
    object: GObject.Object
    priv: TreeManagerPrivate
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeManager */
    /**
     * Adds a sub manager to `manager`. Use this method to create the skeleton structure
     * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
     * or several times in the same #GdaTree's structure.
     * 
     * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
     * infinite recursive behaviour in this case when creating children nodes
     * (depending on the actual implementation of the #GdaTreeManager).
     * @param sub a #GdaTreeManager object to add
     */
    addManager(sub: TreeManager): void
    /**
     * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
     * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
     * 
     * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
     * @param attribute an attribute name
     * @param value the attribute's value, or %NULL
     */
    addNewNodeAttribute(attribute: string, value?: any | null): void
    /**
     * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
     * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
     * 
     * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
     * or when subclassing the #GdaTreeManager.
     * @param parent the parent the new node may have, or %NULL
     * @param name name given to the new node, or %NULL
     */
    createNode(parent?: TreeNode | null, name?: string | null): TreeNode
    /**
     * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
     */
    getManagers(): TreeManager[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::dn", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dn", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::dn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::dn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::dn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeMgrLdap_ConstructProps)
    _init (config?: TreeMgrLdap_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(cnc: Connection, dn?: string | null): TreeMgrLdap
    static $gtype: GObject.Type
}
interface TreeMgrSchemas_ConstructProps extends TreeManager_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeMgrSchemas */
    /**
     * Defines the #GdaConnection to display information for. Necessary upon construction unless
     * the #GdaTreeMgrSchema:meta-store property is specified instead.
     */
    connection?: Connection
    /**
     * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
     * the #GdaTreeMgrSchema:connection property is specified instead. This property has
     * priority over the GdaTreeMgrSchema:connection property.
     */
    metaStore?: MetaStore
}
class TreeMgrSchemas {
    /* Properties of Gda-5.0.Gda.TreeMgrSchemas */
    /**
     * Defines the #GdaConnection to display information for. Necessary upon construction unless
     * the #GdaTreeMgrSchema:meta-store property is specified instead.
     */
    readonly connection: Connection
    /**
     * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
     * the #GdaTreeMgrSchema:connection property is specified instead. This property has
     * priority over the GdaTreeMgrSchema:connection property.
     */
    readonly metaStore: MetaStore
    /* Properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive: boolean
    /* Fields of Gda-5.0.Gda.TreeManager */
    object: GObject.Object
    priv: TreeManagerPrivate
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeManager */
    /**
     * Adds a sub manager to `manager`. Use this method to create the skeleton structure
     * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
     * or several times in the same #GdaTree's structure.
     * 
     * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
     * infinite recursive behaviour in this case when creating children nodes
     * (depending on the actual implementation of the #GdaTreeManager).
     * @param sub a #GdaTreeManager object to add
     */
    addManager(sub: TreeManager): void
    /**
     * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
     * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
     * 
     * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
     * @param attribute an attribute name
     * @param value the attribute's value, or %NULL
     */
    addNewNodeAttribute(attribute: string, value?: any | null): void
    /**
     * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
     * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
     * 
     * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
     * or when subclassing the #GdaTreeManager.
     * @param parent the parent the new node may have, or %NULL
     * @param name name given to the new node, or %NULL
     */
    createNode(parent?: TreeNode | null, name?: string | null): TreeNode
    /**
     * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
     */
    getManagers(): TreeManager[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeMgrSchemas_ConstructProps)
    _init (config?: TreeMgrSchemas_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(cnc: Connection): TreeMgrSchemas
    static $gtype: GObject.Type
}
interface TreeMgrSelect_ConstructProps extends TreeManager_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeMgrSelect */
    connection?: Connection
    params?: Set
    statement?: Statement
}
class TreeMgrSelect {
    /* Properties of Gda-5.0.Gda.TreeMgrSelect */
    readonly connection: Connection
    readonly params: Set
    readonly statement: Statement
    /* Properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive: boolean
    /* Fields of Gda-5.0.Gda.TreeManager */
    object: GObject.Object
    priv: TreeManagerPrivate
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeManager */
    /**
     * Adds a sub manager to `manager`. Use this method to create the skeleton structure
     * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
     * or several times in the same #GdaTree's structure.
     * 
     * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
     * infinite recursive behaviour in this case when creating children nodes
     * (depending on the actual implementation of the #GdaTreeManager).
     * @param sub a #GdaTreeManager object to add
     */
    addManager(sub: TreeManager): void
    /**
     * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
     * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
     * 
     * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
     * @param attribute an attribute name
     * @param value the attribute's value, or %NULL
     */
    addNewNodeAttribute(attribute: string, value?: any | null): void
    /**
     * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
     * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
     * 
     * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
     * or when subclassing the #GdaTreeManager.
     * @param parent the parent the new node may have, or %NULL
     * @param name name given to the new node, or %NULL
     */
    createNode(parent?: TreeNode | null, name?: string | null): TreeNode
    /**
     * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
     */
    getManagers(): TreeManager[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::params", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::params", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::params", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::params", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::params", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::statement", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::statement", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::statement", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::statement", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::statement", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeMgrSelect_ConstructProps)
    _init (config?: TreeMgrSelect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(cnc: Connection, stmt: Statement, params: Set): TreeMgrSelect
    static $gtype: GObject.Type
}
interface TreeMgrTables_ConstructProps extends TreeManager_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeMgrTables */
    /**
     * Defines the #GdaConnection to display information for. Necessary upon construction unless
     * the #GdaTreeMgrTables:meta-store property is specified instead.
     */
    connection?: Connection
    /**
     * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
     * the #GdaTreeMgrTables:connection property is specified instead. This property has
     * priority over the GdaTreeMgrTables:connection property.
     */
    metaStore?: MetaStore
    /**
     * If no set, then the table name will be fetched from the parent node using the "schema" attribute. If not
     * found that way, then the list of visible tables (tables which can be identified without having to specify
     * a schema) will be used
     */
    schema?: string
}
class TreeMgrTables {
    /* Properties of Gda-5.0.Gda.TreeMgrTables */
    /**
     * Defines the #GdaConnection to display information for. Necessary upon construction unless
     * the #GdaTreeMgrTables:meta-store property is specified instead.
     */
    readonly connection: Connection
    /**
     * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
     * the #GdaTreeMgrTables:connection property is specified instead. This property has
     * priority over the GdaTreeMgrTables:connection property.
     */
    readonly metaStore: MetaStore
    /**
     * If no set, then the table name will be fetched from the parent node using the "schema" attribute. If not
     * found that way, then the list of visible tables (tables which can be identified without having to specify
     * a schema) will be used
     */
    readonly schema: string
    /* Properties of Gda-5.0.Gda.TreeManager */
    /**
     * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
     * managed has to be updated
     */
    func: object
    /**
     * This property specifies if, when initially creating nodes or updating the list of nodes,
     * the tree manager shoud also request that each node it has created or updated also
     * initially create or update their children.
     * 
     * This property can typically set to FALSE if the process of creating children nodes is lenghty
     * and needs to be postponed while an event occurs.
     */
    recursive: boolean
    /* Fields of Gda-5.0.Gda.TreeManager */
    object: GObject.Object
    priv: TreeManagerPrivate
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeManager */
    /**
     * Adds a sub manager to `manager`. Use this method to create the skeleton structure
     * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
     * or several times in the same #GdaTree's structure.
     * 
     * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
     * infinite recursive behaviour in this case when creating children nodes
     * (depending on the actual implementation of the #GdaTreeManager).
     * @param sub a #GdaTreeManager object to add
     */
    addManager(sub: TreeManager): void
    /**
     * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
     * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
     * 
     * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
     * @param attribute an attribute name
     * @param value the attribute's value, or %NULL
     */
    addNewNodeAttribute(attribute: string, value?: any | null): void
    /**
     * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
     * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
     * 
     * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
     * or when subclassing the #GdaTreeManager.
     * @param parent the parent the new node may have, or %NULL
     * @param name name given to the new node, or %NULL
     */
    createNode(parent?: TreeNode | null, name?: string | null): TreeNode
    /**
     * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
     */
    getManagers(): TreeManager[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::meta-store", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::meta-store", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::schema", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::schema", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::schema", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::func", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::recursive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::recursive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeMgrTables_ConstructProps)
    _init (config?: TreeMgrTables_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(cnc: Connection, schema?: string | null): TreeMgrTables
    static $gtype: GObject.Type
}
interface TreeNode_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.TreeNode */
    name?: string
}
class TreeNode {
    /* Properties of Gda-5.0.Gda.TreeNode */
    name: string
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.TreeNode */
    /**
     * Get the value associated to the attribute named `attribute` for `node`. If the attribute is not set,
     * then `node'`s parents is queries (recursively up to the top level node).
     * 
     * Attributes can have any name, but Libgda proposes some default names,
     * see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
     * @param attribute attribute name as a string
     */
    fetchAttribute(attribute: string): any
    /**
     * Get the #GdaTreeNode child of `node` at position `index` (starting at 0).
     * @param index a index
     */
    getChildIndex(index: number): TreeNode
    /**
     * Get the #GdaTreeNode child of `node` which has the #GDA_ATTRIBUTE_NAME set to `name`
     * @param name requested node's name
     */
    getChildName(name: string): TreeNode
    /**
     * Get a list of all `node'`s children, free it with g_slist_free() after usage
     */
    getChildren(): TreeNode[]
    /**
     * Get the value associated to the attribute named `attribute` for `node`. The difference with gda_tree_node_fetch_attribute()
     * is that gda_tree_node_fetch_attribute() will also query `node'`s parents (recursively up to the top level node) if
     * the attribute is not set for `node`.
     * 
     * Attributes can have any name, but Libgda proposes some default names,
     * see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
     * @param attribute attribute name as a string
     */
    getNodeAttribute(attribute: string): any
    /**
     * Get the #GdaTreeNode parent of `node` in the #GdaTree node belongs to. If `node` is at the top level,
     * then this method return %NULL.
     */
    getParent(): TreeNode
    /**
     * Set the value associated to a named attribute. The `attribute` string is used AS IT IS by this method (eg.
     * no copy of it is made), and
     * the memory it uses will be freed using the `destroy` function when no longer needed (if `destroy` is %NULL,
     * then the string will not be freed at all).
     * 
     * Attributes can have any name, but Libgda proposes some default names,
     * see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
     * 
     * For example one would use it as:
     * 
     * <code>
     * gda_tree_node_set_node_attribute (node, g_strdup (my_attribute), my_value, g_free);
     * gda_tree_node_set_node_attribute (node, GDA_ATTRIBUTE_NAME, my_value, NULL);
     * </code>
     * 
     * If there is already an attribute named `attribute` set, then its value is replaced with the new value (`value` is
     * copied), except if `value` is %NULL, in which case the attribute is removed.
     * @param attribute attribute name
     * @param value a #GValue, or %NULL
     * @param destroy a function to be called when `attribute` is not needed anymore, or %NULL
     */
    setNodeAttribute(attribute: string, value: any | null, destroy: GLib.DestroyNotify): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of Gda-5.0.Gda.TreeNode */
    /**
     * Gets emitted when a `node` has changed
     * @param node the #GdaTreeNode which has changed
     */
    connect(sigName: "node-changed", callback: ((node: TreeNode) => void)): number
    on(sigName: "node-changed", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-changed", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-changed", callback: (node: TreeNode) => void): NodeJS.EventEmitter
    emit(sigName: "node-changed", node: TreeNode): void
    /**
     * Gets emitted when a `node` has been removed
     * @param relativePath the path the node held, relative to `reporting`
     */
    connect(sigName: "node-deleted", callback: ((relativePath: string) => void)): number
    on(sigName: "node-deleted", callback: (relativePath: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-deleted", callback: (relativePath: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-deleted", callback: (relativePath: string) => void): NodeJS.EventEmitter
    emit(sigName: "node-deleted", relativePath: string): void
    /**
     * Gets emitted when a `node` has has a child when it did not have any or when it
     * does not have a ny children anymore when it had some
     * @param node the #GdaTreeNode which changed from having children to being a        leaf or the other way around
     */
    connect(sigName: "node-has-child-toggled", callback: ((node: TreeNode) => void)): number
    on(sigName: "node-has-child-toggled", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-has-child-toggled", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-has-child-toggled", callback: (node: TreeNode) => void): NodeJS.EventEmitter
    emit(sigName: "node-has-child-toggled", node: TreeNode): void
    /**
     * Gets emitted when a `node` has been inserted
     * @param node the #GdaTreeNode which has been inserted
     */
    connect(sigName: "node-inserted", callback: ((node: TreeNode) => void)): number
    on(sigName: "node-inserted", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-inserted", callback: (node: TreeNode) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-inserted", callback: (node: TreeNode) => void): NodeJS.EventEmitter
    emit(sigName: "node-inserted", node: TreeNode): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TreeNode_ConstructProps)
    _init (config?: TreeNode_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name?: string | null): TreeNode
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
class UShort {
    static name: string
}
interface XaTransaction_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gda-5.0.Gda.XaTransaction */
    formatId?: number
    transactionId?: string
}
class XaTransaction {
    /* Properties of Gda-5.0.Gda.XaTransaction */
    readonly formatId: number
    readonly transactionId: string
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of Gda-5.0.Gda.XaTransaction */
    /**
     * Begins a distributed transaction (managed by `xa_trans)`. Please note that this phase may fail
     * for some connections if a (normal) transaction is already started (this depends on the database
     * provider being used), so it's better to avoid starting any (normal) transaction on any of the
     * connections registered with `xa_trans`.
     */
    begin(): boolean
    /**
     * Commits a distributed transaction (managed by `xa_trans)`. The commit is composed of two phases:
     * <itemizedlist>
     *   <listitem><para>a PREPARE phase where all the connections are required to store their transaction data to a
     *     permanent place (to be able to complete the commit should a problem occur afterwards)</para></listitem>
     *   <listitem><para>a COMMIT phase where the transaction data is actually written to the database</para></listitem>
     * </itemizedlist>
     * 
     * If the PREPARE phase fails for any of the connection registered with `xa_trans,` then the distributed commit
     * fails and FALSE is returned. During the COMMIT phase, some commit may actually fail but the transaction can
     * still be completed because the PREPARE phase succeeded (through the recover method).
     */
    commit(): [ /* returnType */ boolean, /* cncToRecover */ Connection[] | null ]
    /**
     * Tries to commit the data prepared but which failed to commit (see gda_xa_transaction_commit()). This
     * method allows one to terminate a distributed transaction which succeeded but for which some
     * connections needed to be recovered.
     */
    commitRecovered(): [ /* returnType */ boolean, /* cncToRecover */ Connection[] | null ]
    /**
     * Registers `cnc` to be used by `xa_trans` to create a distributed transaction.
     * 
     * Note: any #GdaConnection object can only be registered with at most one #GdaXaTransaction object; also
     * some connections may not be registered at all with a #GdaXaTransaction object because the database
     * provider being used does not support it.
     * @param cnc the connection to add to `xa_trans`
     * @param branch the branch qualifier
     */
    registerConnection(cnc: Connection, branch: string): boolean
    /**
     * Cancels a distributed transaction (managed by `xa_trans)`.
     */
    rollback(): boolean
    /**
     * Unregisters `cnc` to be used by `xa_trans` to create a distributed transaction. This is
     * the opposite of gda_xa_transaction_register_connection().
     * @param cnc the connection to add to `xa_trans`
     */
    unregisterConnection(cnc: Connection): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param sourceProperty the property on `source` to bind
     * @param target the target #GObject
     * @param targetProperty the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transformTo a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transformFrom a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param propertyName the name of the property to get
     * @param value return location for the property value
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param propertyName the name of a property installed on the class of `object`.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param propertyName the name of the property to set
     * @param value the value
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::format-id", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::format-id", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::format-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::format-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::format-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transaction-id", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transaction-id", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transaction-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transaction-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transaction-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: XaTransaction_ConstructProps)
    _init (config?: XaTransaction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(format: number, globalTransactionId: string): XaTransaction
    static errorQuark(): GLib.Quark
    static $gtype: GObject.Type
}
class AttributesManager {
    /* Methods of Gda-5.0.Gda.AttributesManager */
    clear(ptr?: object | null): void
    foreach(ptr: object | null, func: AttributesManagerFunc): void
    free(): void
    get(ptr: object | null, attName: string): any
    set(ptr: object | null, attName: string, value: any): void
    setFull(ptr: object | null, attName: string, value: any, destroy: GLib.DestroyNotify): void
    static name: string
}
abstract class BatchClass {
    /* Fields of Gda-5.0.Gda.BatchClass */
    parentClass: GObject.ObjectClass
    changed: (batch: Batch, changedStmt: Statement) => void
    static name: string
}
class BatchPrivate {
    static name: string
}
class Binary {
    /* Fields of Gda-5.0.Gda.Binary */
    /**
     * the actual data as an array
     */
    data: Uint8Array
    /**
     * length of `data`
     */
    binaryLength: number
    /* Methods of Gda-5.0.Gda.Binary */
    /**
     * Converts all the non printable characters of bin->data into the "\xyz" representation
     * where "xyz" is the octal representation of the byte, and the '\' (backslash) character
     * is converted to "\\". Printable characters (defined by g_ascii_isprint()) as well as newline
     * character are not converted.
     * 
     * Note that the backslash and newline characters are considered as printable characters and
     * will not be represented by the "\xyz" representation.
     * 
     * Use this function to get a representation as much readable by humans as possible of a binary
     * chunk. Note that this function is internally called when transforming a binary value to
     * a string for example when using g_value_transform() or gda_value_stringify().
     * @param maxlen a maximum len used to truncate, or %0 for no maximum length
     */
    toString(maxlen: number): string
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Creates a new #GdaBinary structure from an existing one.
     * @param boxed source to get a copy from.
     */
    static copy(boxed?: object | null): object | null
    /**
     * Deallocates all memory associated to the given #GdaBinary.
     * @param boxed #GdaBinary to free.
     */
    static free(boxed?: object | null): void
}
class Blob {
    /* Fields of Gda-5.0.Gda.Blob */
    /**
     * data buffer, as a #GdaBinary
     */
    data: Binary
    /**
     * a pointer to a #GdaBlopOp, or %NULL
     */
    op: BlobOp
    /* Methods of Gda-5.0.Gda.Blob */
    /**
     * correctly assigns `op` to `blob`
     * @param op a #GdaBlobOp object, or %NULL
     */
    setOp(op?: BlobOp | null): void
    /**
     * Converts all the non printable characters of blob->data into the \xxx representation
     * where xxx is the octal representation of the byte, and the '\' (backslash) character
     * is converted to "\\".
     * @param maxlen a maximum len used to truncate, or 0 for no maximum length
     */
    toString(maxlen: number): string
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Creates a new #GdaBlob structure from an existing one.
     * @param boxed source to get a copy from.
     */
    static copy(boxed?: object | null): object | null
    /**
     * Deallocates all memory associated to the given #GdaBlob.
     * @param boxed #GdaBlob to free.
     */
    static free(boxed?: object | null): void
}
abstract class BlobOpClass {
    /* Fields of Gda-5.0.Gda.BlobOpClass */
    parentClass: GObject.ObjectClass
    getLength: (op: BlobOp) => number
    read: (op: BlobOp, blob: Blob, offset: number, size: number) => number
    write: (op: BlobOp, blob: Blob, offset: number) => number
    writeAll: (op: BlobOp, blob: Blob) => boolean
    static name: string
}
abstract class ColumnClass {
    /* Fields of Gda-5.0.Gda.ColumnClass */
    parentClass: GObject.ObjectClass
    nameChanged: (column: Column, oldName: string) => void
    gTypeChanged: (column: Column, oldType: GObject.Type, newType: GObject.Type) => void
    static name: string
}
class ColumnPrivate {
    static name: string
}
abstract class ConfigClass {
    /* Fields of Gda-5.0.Gda.ConfigClass */
    objectClass: GObject.ObjectClass
    dsnAdded: (conf: Config, newDsn: DsnInfo) => void
    dsnToBeRemoved: (conf: Config, oldDsn: DsnInfo) => void
    dsnRemoved: (conf: Config, oldDsn: DsnInfo) => void
    dsnChanged: (conf: Config, dsn: DsnInfo) => void
    static name: string
}
class ConfigPrivate {
    static name: string
}
abstract class ConnectionClass {
    /* Fields of Gda-5.0.Gda.ConnectionClass */
    objectClass: GObject.ObjectClass
    error: (cnc: Connection, error: ConnectionEvent) => void
    connOpened: (obj: Connection) => void
    connToClose: (obj: Connection) => void
    connClosed: (obj: Connection) => void
    dsnChanged: (obj: Connection) => void
    transactionStatusChanged: (obj: Connection) => void
    static name: string
}
abstract class ConnectionEventClass {
    /* Fields of Gda-5.0.Gda.ConnectionEventClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class ConnectionEventPrivate {
    static name: string
}
class ConnectionPrivate {
    static name: string
}
abstract class DataAccessWrapperClass {
    /* Fields of Gda-5.0.Gda.DataAccessWrapperClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class DataAccessWrapperPrivate {
    static name: string
}
abstract class DataComparatorClass {
    /* Fields of Gda-5.0.Gda.DataComparatorClass */
    parentClass: GObject.ObjectClass
    diffComputed: (comp: DataComparator, diff: Diff) => boolean
    static name: string
}
class DataComparatorPrivate {
    static name: string
}
abstract class DataHandlerIface {
    /* Fields of Gda-5.0.Gda.DataHandlerIface */
    gIface: GObject.TypeInterface
    getSqlFromValue: (dh: DataHandler, value?: any | null) => string
    getStrFromValue: (dh: DataHandler, value?: any | null) => string
    getValueFromSql: (dh: DataHandler, sql: string | null, type: GObject.Type) => any
    getValueFromStr: (dh: DataHandler, str: string | null, type: GObject.Type) => any
    getSaneInitValue: (dh: DataHandler, type: GObject.Type) => any | null
    acceptsGType: (dh: DataHandler, type: GObject.Type) => boolean
    getDescr: (dh: DataHandler) => string
    static name: string
}
abstract class DataModelArrayClass {
    /* Fields of Gda-5.0.Gda.DataModelArrayClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class DataModelArrayPrivate {
    static name: string
}
abstract class DataModelDirClass {
    /* Fields of Gda-5.0.Gda.DataModelDirClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class DataModelDirPrivate {
    static name: string
}
abstract class DataModelIface {
    /* Fields of Gda-5.0.Gda.DataModelIface */
    gIface: GObject.TypeInterface
    iGetNRows: (model: DataModel) => number
    iGetNColumns: (model: DataModel) => number
    iDescribeColumn: (model: DataModel, col: number) => Column | null
    iGetAccessFlags: (model: DataModel) => DataModelAccessFlags
    iGetValueAt: (model: DataModel, col: number, row: number) => any | null
    iGetAttributesAt: (model: DataModel, col: number, row: number) => ValueAttribute
    iCreateIter: (model: DataModel) => DataModelIter
    iIterAtRow: (model: DataModel, iter: DataModelIter, row: number) => boolean
    iIterNext: (model: DataModel, iter: DataModelIter) => boolean
    iIterPrev: (model: DataModel, iter: DataModelIter) => boolean
    iSetValueAt: (model: DataModel, col: number, row: number, value: any) => boolean
    iIterSetValue: (model: DataModel, iter: DataModelIter, col: number, value: any) => boolean
    iSetValues: (model: DataModel, row: number, values?: any[] | null) => boolean
    iAppendValues: (model: DataModel, values?: any[] | null) => number
    iAppendRow: (model: DataModel) => number
    iRemoveRow: (model: DataModel, row: number) => boolean
    iFindRow: (model: DataModel, values: any[], colsIndex: number[]) => number
    iSetNotify: (model: DataModel, doNotifyChanges: boolean) => void
    iGetNotify: (model: DataModel) => boolean
    iSendHint: (model: DataModel, hint: DataModelHint, hintValue?: any | null) => void
    rowInserted: (model: DataModel, row: number) => void
    rowUpdated: (model: DataModel, row: number) => void
    rowRemoved: (model: DataModel, row: number) => void
    changed: (model: DataModel) => void
    reset: (model: DataModel) => void
    accessChanged: (model: DataModel) => void
    iGetExceptions: (model: DataModel) => GLib.Error[]
    static name: string
}
abstract class DataModelImportClass {
    /* Fields of Gda-5.0.Gda.DataModelImportClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class DataModelImportPrivate {
    static name: string
}
abstract class DataModelIterClass {
    /* Fields of Gda-5.0.Gda.DataModelIterClass */
    parentClass: SetClass
    rowChanged: (iter: DataModelIter, row: number) => void
    endOfData: (iter: DataModelIter) => void
    static name: string
}
class DataModelIterPrivate {
    static name: string
}
abstract class DataModelLdapClass {
    /* Fields of Gda-5.0.Gda.DataModelLdapClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class DataModelLdapPrivate {
    static name: string
}
abstract class DataPivotClass {
    /* Fields of Gda-5.0.Gda.DataPivotClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class DataPivotPrivate {
    static name: string
}
abstract class DataProxyClass {
    /* Fields of Gda-5.0.Gda.DataProxyClass */
    parentClass: GObject.ObjectClass
    rowDeleteChanged: (proxy: DataProxy, row: number, toBeDeleted: boolean) => void
    sampleSizeChanged: (proxy: DataProxy, sampleSize: number) => void
    sampleChanged: (proxy: DataProxy, sampleStart: number, sampleEnd: number) => void
    validateRowChanges: (proxy: DataProxy, row: number, proxiedRow: number) => GLib.Error
    rowChangesApplied: (proxy: DataProxy, row: number, proxiedRow: number) => void
    filterChanged: (proxy: DataProxy) => void
    static name: string
}
class DataProxyPrivate {
    static name: string
}
abstract class DataSelectClass {
    /* Fields of Gda-5.0.Gda.DataSelectClass */
    parentClass: GObject.ObjectClass
    fetchNbRows: (model: DataSelect) => number
    fetchRandom: (model: DataSelect, prow: Row, rownum: number) => boolean
    storeAll: (model: DataSelect) => boolean
    fetchNext: (model: DataSelect, prow: Row, rownum: number) => boolean
    fetchPrev: (model: DataSelect, prow: Row, rownum: number) => boolean
    fetchAt: (model: DataSelect, prow: Row, rownum: number) => boolean
    static name: string
}
class DataSelectPrivate {
    static name: string
}
class Diff {
    /* Fields of Gda-5.0.Gda.Diff */
    type: DiffType
    oldRow: number
    newRow: number
    values: GLib.HashTable
    static name: string
}
class DsnInfo {
    /* Fields of Gda-5.0.Gda.DsnInfo */
    /**
     * the (unique) name of the DSN (plain text, not RFC 1738 encoded)
     */
    name: string
    /**
     * the ID of the database provider to be used (plain text, not RFC 1738 encoded)
     */
    provider: string
    /**
     * a descriptive string (plain text, not RFC 1738 encoded), can be %NULL.
     */
    description: string
    /**
     * the connection string, a semi-colon separated &lt;key>=&lt;value&gt; list where &lt;key&gt; and &lt;value&gt; are RFC 1738 encoded
     */
    cncString: string
    /**
     * the authentication string, a semi-colon separated &lt;key>=&lt;value&gt; list where &lt;key&gt; and &lt;value&gt; are RFC 1738 encoded. Can be %NULL.
     */
    authString: string
    /**
     * %TRUE if the DSN is a system wide defined data source
     */
    isSystem: boolean
    /* Methods of Gda-5.0.Gda.DsnInfo */
    /**
     * Copy constructor.
     */
    copy(): DsnInfo
    /**
     * Frees any resources taken by `dsn` struct. If `dsn` is %NULL, then nothing happens.
     */
    free(): void
    static name: string
    static new(): DsnInfo
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): DsnInfo
}
class GeometricPoint {
    /* Fields of Gda-5.0.Gda.GeometricPoint */
    x: number
    y: number
    static name: string
    /* Static methods and pseudo-constructors */
    static copy(boxed?: object | null): object | null
    static free(boxed?: object | null): void
}
abstract class HandlerBinClass {
    /* Fields of Gda-5.0.Gda.HandlerBinClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class HandlerBinPriv {
    static name: string
}
abstract class HandlerBooleanClass {
    /* Fields of Gda-5.0.Gda.HandlerBooleanClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class HandlerBooleanPriv {
    static name: string
}
abstract class HandlerNumericalClass {
    /* Fields of Gda-5.0.Gda.HandlerNumericalClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class HandlerNumericalPriv {
    static name: string
}
abstract class HandlerStringClass {
    /* Fields of Gda-5.0.Gda.HandlerStringClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class HandlerStringPriv {
    static name: string
}
abstract class HandlerTimeClass {
    /* Fields of Gda-5.0.Gda.HandlerTimeClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class HandlerTimePriv {
    static name: string
}
abstract class HandlerTypeClass {
    /* Fields of Gda-5.0.Gda.HandlerTypeClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class HandlerTypePriv {
    static name: string
}
abstract class HolderClass {
    /* Fields of Gda-5.0.Gda.HolderClass */
    parentClass: GObject.ObjectClass
    changed: (holder: Holder) => void
    sourceChanged: (holder: Holder) => void
    validateChange: (holder: Holder, newValue: any) => GLib.Error
    attChanged: (holder: Holder, attName: string, attValue: any) => void
    static name: string
}
class HolderPrivate {
    static name: string
}
abstract class LockableIface {
    /* Fields of Gda-5.0.Gda.LockableIface */
    gIface: GObject.TypeInterface
    iLock: (lock: Lockable) => void
    iTrylock: (lock: Lockable) => boolean
    iUnlock: (lock: Lockable) => void
    static name: string
}
class MetaContext {
    /* Fields of Gda-5.0.Gda.MetaContext */
    /**
     * the name of the table <emphasis>in the GdaMetaStore's internal database</emphasis>
     */
    tableName: string
    /**
     * the size of the `column_names` and `column_values` arrays
     */
    size: number
    /**
     * an array of column names (columns of the `table_name` table)
     */
    columnNames: string[]
    /**
     * an array of values, one for each column named in `column_names`
     */
    columnValues: any[]
    /**
     * A #GHashTable storing columns' name as key and #GValue as column's
     * value.
     */
    columns: GLib.HashTable
    /* Methods of Gda-5.0.Gda.MetaContext */
    /**
     * Copy constructor.
     */
    copy(): MetaContext
    /**
     * Frees any resources taken by `ctx` struct. If `ctx` is %NULL, then nothing happens.
     */
    free(): void
    /**
     * Get table's name to used in the context.
     */
    getTable(): string
    /**
     * Sets a new column/value pair to the given context `ctx`. Column, must be a column in the given table's
     * name setted by #gda_meta_context_set_table () (a table in the <link linkend="information_schema">database
     * schema</link>). If the given `column` already exists it's value is overwrited.
     * 
     * Column's name and value is copied and destroyed when #gda_meta_context_free is called.
     * @param column the column's name
     * @param value the column's value
     * @param cnc a #GdaConnection to be used when identifier are normalized, or NULL
     */
    setColumn(column: string, value: any, cnc?: Connection | null): void
    /**
     * Set columns to use in the context. The #GHashTable use column's name as key and a #GValue as value,
     * to represent its value.
     * 
     * `columns` incements its reference counting. Is recommended to use #gda_meta_context_free in order to free them.
     * @param columns a #GHashTable with the table's columns' name and their values to use in context.
     * @param cnc a #GdaConnection to used to normalize identifiers quoting, or NULL
     */
    setColumns(columns: GLib.HashTable, cnc?: Connection | null): void
    /**
     * Set table's name to use in the context. The table is one of <link linkend="information_schema">database
     * schema</link> used to store meta information about the database. Use "_tables" to update meta information
     * about database's tables.
     * @param table a string with the table's name to use in context
     */
    setTable(table: string): void
    static name: string
    static new(): MetaContext
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): MetaContext
}
class MetaDbObject {
    /* Fields of Gda-5.0.Gda.MetaDbObject */
    /**
     * the type of object (table, view)
     */
    objType: MetaDbObjectType
    /**
     * set to %TRUE if the information in this #GdaMetaDbObject may be outdated because the #GdaMetaStore has been updated
     */
    outdated: boolean
    /**
     * the catalog the object is in
     */
    objCatalog: string
    /**
     * the schema the object is in
     */
    objSchema: string
    /**
     * the object's name
     */
    objName: string
    /**
     * the shortest way to name the object
     */
    objShortName: string
    /**
     * the full name of the object (in the &lt;schema&gt;.&lt;nameagt; notation
     */
    objFullName: string
    /**
     * object's owner
     */
    objOwner: string
    /**
     * list of #GdaMetaDbObject pointers on which this object depends (through foreign keys
     *               or tables used for views)
     */
    dependList: MetaDbObject[]
    static name: string
}
class MetaStoreChange {
    /* Fields of Gda-5.0.Gda.MetaStoreChange */
    cType: MetaStoreChangeType
    tableName: string
    keys: GLib.HashTable
    static name: string
}
abstract class MetaStoreClass {
    /* Fields of Gda-5.0.Gda.MetaStoreClass */
    parentClass: GObject.ObjectClass
    cpriv: MetaStoreClassPrivate
    metaReset: (store: MetaStore) => void
    suggestUpdate: (store: MetaStore, suggest: MetaContext) => GLib.Error
    static name: string
}
class MetaStoreClassPrivate {
    static name: string
}
class MetaStorePrivate {
    static name: string
}
abstract class MetaStructClass {
    /* Fields of Gda-5.0.Gda.MetaStructClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class MetaStructPrivate {
    static name: string
}
class MetaTable {
    /* Fields of Gda-5.0.Gda.MetaTable */
    /**
     * list of #GdaMetaTableColumn structures, one for each column in the table
     */
    columns: MetaTableColumn[]
    /**
     * index of the columns part of the primary key for the table (WARNING: columns numbering
     *                 here start at 0)
     */
    pkColsArray: number
    /**
     * size of the `pk_cols_array` array
     */
    pkColsNb: number
    /**
     * list of #GdaMetaTableForeignKey where the referenced table is this table
     */
    reverseFkList: MetaTableForeignKey[]
    /**
     * list of #GdaMetaTableForeignKey for this table
     */
    fkList: MetaTableForeignKey[]
    static name: string
}
class MetaTableColumn {
    /* Fields of Gda-5.0.Gda.MetaTableColumn */
    /**
     * the column's name
     */
    columnName: string
    /**
     * the column's DBMS's type
     */
    columnType: string
    /**
     * the detected column's #GType
     */
    gtype: GObject.Type
    /**
     * tells if the column is part of a primary key
     */
    pkey: boolean
    /**
     * tells if the column can be %NULL
     */
    nullok: boolean
    /**
     * the column's default value, represented as a valid SQL value (surrounded by simple quotes for strings, ...), or %NULL if column has no default value
     */
    defaultValue: string
    /* Methods of Gda-5.0.Gda.MetaTableColumn */
    /**
     * Calls `func` for each attribute set to tcol
     * @param func a #GdaAttributesManagerFunc function
     */
    foreachAttribute(func: AttributesManagerFunc): void
    /**
     * Get the value associated to a named attribute.
     * 
     * Attributes can have any name, but Libgda proposes some default names, see <link linkend="libgda-5.0-Attributes-manager.synopsis">this section</link>.
     * @param attribute attribute name as a string
     */
    getAttribute(attribute: string): any
    /**
     * Set the value associated to a named attribute.
     * 
     * Attributes can have any name, but Libgda proposes some default names, see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
     * If there is already an attribute named `attribute` set, then its value is replaced with the new `value,`
     * except if `value` is %NULL, in which case the attribute is removed.
     * 
     * Warning: `attribute` is not copied, if it needs to be freed when not used anymore, then `destroy` should point to
     * the functions which will free it (typically g_free()). If `attribute` does not need to be freed, then `destroy` can be %NULL.
     * @param attribute attribute name as a static string
     * @param value a #GValue, or %NULL
     * @param destroy function called when `attribute` has to be freed, or %NULL
     */
    setAttribute(attribute: string, value?: any | null, destroy?: GLib.DestroyNotify | null): void
    static name: string
}
class MetaTableForeignKey {
    /* Fields of Gda-5.0.Gda.MetaTableForeignKey */
    /**
     * the #GdaMetaDbObject for which this structure represents a foreign key
     */
    metaTable: MetaDbObject
    /**
     * the #GdaMetaDbObject which is referenced by the foreign key
     */
    dependOn: MetaDbObject
    /**
     * the size of the `fk_cols_array,` `fk_names_array,` `ref_pk_cols_array` and `ref_pk_names_array` arrays
     */
    colsNb: number
    /**
     * the columns' indexes in `meta_table` which participate in the constraint (WARNING: columns numbering
     *                 here start at 1)
     */
    fkColsArray: number
    /**
     * the columns' names in `meta_table` which participate in the constraint
     */
    fkNamesArray: string
    /**
     * the columns' indexes in `depend_on` which participate in the constraint (WARNING: columns numbering
     *                 here start at 1)
     */
    refPkColsArray: number
    /**
     * the columns' names in `depend_on` which participate in the constraint
     */
    refPkNamesArray: string
    fkName: string
    static name: string
}
class MetaView {
    /* Fields of Gda-5.0.Gda.MetaView */
    /**
     * a view is also a table as it has columns
     */
    table: MetaTable
    /**
     * views' definition
     */
    viewDef: string
    /**
     * tells if the view's contents can be updated
     */
    isUpdatable: boolean
    static name: string
}
class Numeric {
    /* Fields of Gda-5.0.Gda.Numeric */
    /**
     * a string representing a number
     */
    number: string
    /**
     * precision to use when `number` is converted (not implemented jet)
     */
    precision: number
    /**
     * not implemented jet
     */
    width: number
    /* Methods of Gda-5.0.Gda.Numeric */
    /**
     * Creates a new #GdaNumeric structure from an existing one.
     */
    copy(): Numeric
    /**
     * Deallocates all memory associated to the given `boxed`
     */
    free(): void
    getDouble(): number
    /**
     * Gets the precision of a #GdaNumeric.
     */
    getPrecision(): number
    /**
     * Get the string representation of `numeric,` in the C locale format (dot as a fraction separator).
     */
    getString(): string | null
    /**
     * Gets the width of a #GdaNumeric. (Not yet implemented).
     */
    getWidth(): number
    /**
     * Sets `numeric` using a #gdouble represented by `number`.
     * @param number a #gdouble
     */
    setDouble(number: number): void
    /**
     * Sets `numeric` with a number represented by `str,` in the C locale format (dot as a fraction separator).
     * @param str a string representing a number, in the C locale format
     */
    setFromString(str: string): void
    /**
     * Sets the precision of a #GdaNumeric.
     * @param precision a #glong
     */
    setPrecision(precision: number): void
    /**
     * Sets the width of a #GdaNumeric. (Not yet implemented).
     * @param width a #glong
     */
    setWidth(width: number): void
    static name: string
    static new(): Numeric
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): Numeric
}
abstract class PStmtClass {
    /* Fields of Gda-5.0.Gda.PStmtClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class PStmtPrivate {
    static name: string
}
class ProviderInfo {
    /* Fields of Gda-5.0.Gda.ProviderInfo */
    /**
     * the unique identifier of the database provider
     */
    id: string
    /**
     * the complete path to the shared library implementing the database provider
     */
    location: string
    /**
     * provider's description
     */
    description: string
    /**
     * a #GdaSet containing all the parameters which can/must be specified when opening a connection or defining a named data source (DSN)
     */
    dsnParams: Set
    /**
     * a #GdaSet containing all the authentication parameters
     */
    authParams: Set
    static name: string
}
class QuarkList {
    /* Methods of Gda-5.0.Gda.QuarkList */
    /**
     * `string` must be a semi-colon separated list of "&lt;key&gt;=&lt;value&gt;" strings (for example
     * "DB_NAME=notes;USERNAME=alfred"). Each key and value must respect the RFC 1738 recommendations: the
     * <constant>&lt;&gt;&quot;#%{}|\^~[]&apos;`;/?:`=`&amp;</constant> and space characters are replaced by
     * <constant>&quot;%%ab&quot;</constant> where
     * <constant>ab</constant> is the hexadecimal number corresponding to the character (for example the
     * "DB_NAME=notes;USERNAME=al%%20fred" string will specify a username as "al fred"). If this formalism
     * is not respected, then some unexpected results may occur.
     * 
     * Adds new key->value pairs from the given `string`. If `cleanup` is
     * set to %TRUE, the previous contents will be discarded before adding
     * the new pairs.
     * @param string a string.
     * @param cleanup whether to cleanup the previous content or not.
     */
    addFromString(string: string, cleanup: boolean): void
    /**
     * Removes all strings in the given #GdaQuarkList.
     */
    clear(): void
    /**
     * Creates a new #GdaQuarkList from an existing one.
     */
    copy(): QuarkList
    /**
     * Searches for the value identified by `name` in the given #GdaQuarkList. For protected values
     * (authentification data), don't forget to call gda_quark_list_protect_values() when you
     * don't need them anymore (when needed again, they will be unmangled again).
     * @param name the name of the value to search for.
     */
    find(name: string): string
    /**
     * Calls the given function for each of the key/value pairs in `qlist`. The function is passed the key and value
     * of each pair, and the given user_data parameter. `qlist` may not be modified while iterating over it.
     * @param func the function to call for each key/value pair
     */
    foreach(func: GLib.HFunc): void
    /**
     * Releases all memory occupied by the given #GdaQuarkList.
     */
    free(): void
    /**
     * Call this function to get rid of the clear version of the value associated to
     * `name`.
     */
    protectValues(): void
    /**
     * Removes an entry from the #GdaQuarkList, given its name.
     * @param name an entry name.
     */
    remove(name: string): void
    static name: string
    static new(): QuarkList
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): QuarkList
    static newFromString(string: string): QuarkList
}
abstract class RepetitiveStatementClass {
    /* Fields of Gda-5.0.Gda.RepetitiveStatementClass */
    parentClass: GObject.ObjectClass
    static name: string
}
abstract class RowClass {
    /* Fields of Gda-5.0.Gda.RowClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class RowPrivate {
    static name: string
}
abstract class ServerOperationClass {
    /* Fields of Gda-5.0.Gda.ServerOperationClass */
    parentClass: GObject.ObjectClass
    seqItemAdded: (op: ServerOperation, seqPath: string, itemIndex: number) => void
    seqItemRemove: (op: ServerOperation, seqPath: string, itemIndex: number) => void
    static name: string
}
class ServerOperationNode {
    /* Fields of Gda-5.0.Gda.ServerOperationNode */
    type: ServerOperationNodeType
    status: ServerOperationNodeStatus
    plist: Set
    model: DataModel
    column: Column
    param: Holder
    priv: object
    static name: string
}
class ServerOperationPrivate {
    static name: string
}
abstract class ServerProviderClass {
    /* Fields of Gda-5.0.Gda.ServerProviderClass */
    parentClass: GObject.ObjectClass
    limitingThread: GLib.Thread
    getName: (provider: ServerProvider) => string
    getVersion: (provider: ServerProvider) => string
    getServerVersion: (provider: ServerProvider, cnc: Connection) => string
    supportsFeature: (provider: ServerProvider, cnc: Connection | null, feature: ConnectionFeature) => boolean
    getDefDbmsType: (provider: ServerProvider, cnc: Connection, gType: GObject.Type) => string
    escapeString: (provider: ServerProvider, cnc: Connection | null, str: string) => string
    unescapeString: (provider: ServerProvider, cnc: Connection | null, str: string) => string
    closeConnection: (provider: ServerProvider, cnc: Connection) => boolean
    getDatabase: (provider: ServerProvider, cnc: Connection) => string
    supportsOperation: (provider: ServerProvider, cnc: Connection | null, type: ServerOperationType, options?: Set | null) => boolean
    createOperation: (provider: ServerProvider, cnc: Connection | null, type: ServerOperationType, options?: Set | null) => ServerOperation | null
    renderOperation: (provider: ServerProvider, cnc: Connection | null, op: ServerOperation) => string | null
    beginTransaction: (provider: ServerProvider, cnc: Connection, name: string, level: TransactionIsolation) => boolean
    commitTransaction: (provider: ServerProvider, cnc: Connection, name: string) => boolean
    rollbackTransaction: (provider: ServerProvider, cnc: Connection, name: string) => boolean
    addSavepoint: (provider: ServerProvider, cnc: Connection, name: string) => boolean
    rollbackSavepoint: (provider: ServerProvider, cnc: Connection, name: string) => boolean
    deleteSavepoint: (provider: ServerProvider, cnc: Connection, name: string) => boolean
    createParser: (provider: ServerProvider, cnc?: Connection | null) => SqlParser
    statementPrepare: (provider: ServerProvider, cnc: Connection, stmt: Statement) => boolean
    isBusy: (provider: ServerProvider, cnc: Connection) => boolean
    cancel: (provider: ServerProvider, cnc: Connection, taskId: number) => boolean
    metaFuncs: ServerProviderMeta
    xaFuncs: ServerProviderXa
    identifierQuote: (provider: ServerProvider, cnc: Connection, id: string, forMetaStore: boolean, forceQuotes: boolean) => string
    handleAsync: (provider: ServerProvider, cnc: Connection) => boolean
    static name: string
}
class ServerProviderHandlerInfo {
    /* Fields of Gda-5.0.Gda.ServerProviderHandlerInfo */
    cnc: Connection
    gType: GObject.Type
    dbmsType: string
    static name: string
}
class ServerProviderInfo {
    static name: string
}
class ServerProviderMeta {
    /* Fields of Gda-5.0.Gda.ServerProviderMeta */
    udt: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, udtCatalog: any, udtSchema: any) => boolean
    udtCols: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, udtCatalog: any, udtSchema: any, udtName: any) => boolean
    enums: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, udtCatalog: any, udtSchema: any, udtName: any) => boolean
    domains: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, domainCatalog: any, domainSchema: any) => boolean
    constraintsDom: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, domainCatalog: any, domainSchema: any, domainName: any) => boolean
    elTypes: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, specificName: any) => boolean
    collations: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, collationCatalog: any, collationSchema: any, collationNameN: any) => boolean
    characterSets: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, chsetCatalog: any, chsetSchema: any, chsetNameN: any) => boolean
    schemata: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, catalogName: any, schemaNameN: any) => boolean
    tablesViews: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableNameN: any) => boolean
    columns: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any) => boolean
    viewCols: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, viewCatalog: any, viewSchema: any, viewName: any) => boolean
    constraintsTab: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any, constraintNameN: any) => boolean
    constraintsRef: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any, constraintName: any) => boolean
    keyColumns: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any, constraintName: any) => boolean
    checkColumns: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any, constraintName: any) => boolean
    triggers: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any) => boolean
    routines: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, routineCatalog: any, routineSchema: any, routineNameN: any) => boolean
    routineCol: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, routCatalog: any, routSchema: any, routName: any) => boolean
    routinePar: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, routCatalog: any, routSchema: any, routName: any) => boolean
    indexesTab: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any, indexNameN: any) => boolean
    indexCols: (prov: ServerProvider, cnc: Connection, meta: MetaStore, ctx: MetaContext, error: GLib.Error, tableCatalog: any, tableSchema: any, tableName: any, indexName: any) => boolean
    static name: string
}
class ServerProviderPrivate {
    /* Fields of Gda-5.0.Gda.ServerProviderPrivate */
    dataHandlers: GLib.HashTable
    parser: SqlParser
    static name: string
}
class ServerProviderXa {
    /* Fields of Gda-5.0.Gda.ServerProviderXa */
    xaStart: (prov: ServerProvider, cnc: Connection, trx: XaTransactionId) => boolean
    xaEnd: (prov: ServerProvider, cnc: Connection, trx: XaTransactionId) => boolean
    xaPrepare: (prov: ServerProvider, cnc: Connection, trx: XaTransactionId) => boolean
    xaCommit: (prov: ServerProvider, cnc: Connection, trx: XaTransactionId) => boolean
    xaRollback: (prov: ServerProvider, cnc: Connection, trx: XaTransactionId) => boolean
    static name: string
}
abstract class SetClass {
    /* Fields of Gda-5.0.Gda.SetClass */
    parentClass: GObject.ObjectClass
    validateHolderChange: (set: Set, holder: Holder, newValue: any) => GLib.Error
    validateSet: (set: Set) => GLib.Error
    holderChanged: (set: Set, holder: Holder) => void
    holderAttrChanged: (set: Set, holder: Holder, attrName: string, attrValue: any) => void
    publicDataChanged: (set: Set) => void
    holderTypeSet: (set: Set, holder: Holder) => void
    sourceModelChanged: (set: Set, source: SetSource) => void
    static name: string
}
class SetGroup {
    /* Fields of Gda-5.0.Gda.SetGroup */
    /**
     * list of GdaSetNode, at least one entry
     */
    nodes: SetNode[]
    /**
     * if NULL, then `nodes` contains exactly one entry
     */
    nodesSource: SetSource
    /* Methods of Gda-5.0.Gda.SetGroup */
    addNode(node: SetNode): void
    /**
     * Copy constructor.
     */
    copy(): SetGroup
    /**
     * Frees any resources taken by `sg` struct. If `sg` is %NULL, then nothing happens.
     */
    free(): void
    getNNodes(): number
    /**
     * This method always return first #GdaSetNode in `sg`.
     */
    getNode(): SetNode
    /**
     * Returns a #GSList with the #GdaSetNode grouped by `sg`. You must use
     * #g_slist_free on returned list.
     */
    getNodes(): SetNode[]
    getSource(): SetSource
    setSource(source: SetSource): void
    static name: string
    static new(node: SetNode): SetGroup
    constructor(node: SetNode)
    /* Static methods and pseudo-constructors */
    static new(node: SetNode): SetGroup
}
class SetNode {
    /* Fields of Gda-5.0.Gda.SetNode */
    /**
     * a #GdaHolder. It can't be NULL
     */
    holder: Holder
    /**
     * a #GdaDataModel. It could be NULL
     */
    sourceModel: DataModel
    /**
     * a #gint with the number of column in `source_model`
     */
    sourceColumn: number
    /* Methods of Gda-5.0.Gda.SetNode */
    /**
     * Copy constructor.
     */
    copy(): SetNode
    /**
     * Frees any resources taken by `node` struct. If `node` is %NULL, then nothing happens.
     */
    free(): void
    getDataModel(): DataModel
    getHolder(): Holder
    getSourceColumn(): number
    /**
     * Set a #GdaDataModel to be used by `node`. `model` increment its reference
     * counting when set. Internally referenced column number is set to first column
     * in `model`.
     * @param model a #GdaDataModel to be used by `node`
     */
    setDataModel(model?: DataModel | null): void
    /**
     * Set a #GdaHolder to `node`.
     * @param holder 
     */
    setHolder(holder: Holder): void
    /**
     * Set column number in the #GdaDataModel used `node`. If no #GdaDataModel is set
     * then column is set to invalid (-1);
     * @param column 
     */
    setSourceColumn(column: number): void
    static name: string
    static new(holder: Holder): SetNode
    constructor(holder: Holder)
    /* Static methods and pseudo-constructors */
    static new(holder: Holder): SetNode
}
class SetPrivate {
    static name: string
}
class SetSource {
    /* Fields of Gda-5.0.Gda.SetSource */
    /**
     * Can't be NULL
     */
    dataModel: DataModel
    /**
     * list of #GdaSetNode for which source_model == `data_model`
     */
    nodes: SetNode[]
    /* Methods of Gda-5.0.Gda.SetSource */
    /**
     * Set a #GdaDataModel
     * @param node a #GdaSetNode to add
     */
    addNode(node: SetNode): void
    /**
     * Copy constructor.
     */
    copy(): SetSource
    /**
     * Frees any resources taken by `s` struct. If `s` is %NULL, then nothing happens.
     */
    free(): void
    getDataModel(): DataModel
    getNNodes(): number
    getNodes(): SetNode[]
    /**
     * Set a #GdaDataModel
     * @param model a #GdaDataModel
     */
    setDataModel(model: DataModel): void
    static name: string
    static new(model: DataModel): SetSource
    constructor(model: DataModel)
    /* Static methods and pseudo-constructors */
    static new(model: DataModel): SetSource
}
class SqlAnyPart {
    /* Fields of Gda-5.0.Gda.SqlAnyPart */
    /**
     * type of structure, as a #GdaSqlAnyPartType enum.
     */
    type: any
    /**
     * pointer to the parent #GdaSqlAnyPart structure
     */
    parent: any
    /* Methods of Gda-5.0.Gda.SqlAnyPart */
    checkStructure(): boolean
    static name: string
}
abstract class SqlBuilderClass {
    /* Fields of Gda-5.0.Gda.SqlBuilderClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class SqlBuilderPrivate {
    static name: string
}
class SqlCase {
    /* Fields of Gda-5.0.Gda.SqlCase */
    /**
     * inheritance structure
     */
    any: any
    /**
     * expression to test
     */
    baseExpr: any
    /**
     * list of #GdaSqlExpr, one for each WHEN clause
     */
    whenExprList: object[]
    /**
     * list of #GdaSqlExpr, one for each THEN clause
     */
    thenExprList: object[]
    /**
     * default expression for the CASE
     */
    elseExpr: any
    /* Methods of Gda-5.0.Gda.SqlCase */
    free(): void
    serialize(): string
    static name: string
}
class SqlExpr {
    /* Fields of Gda-5.0.Gda.SqlExpr */
    /**
     * inheritance structure
     */
    any: any
    /**
     * a #GValue, or %NULL. Please see specific note about this field.
     */
    value: any
    /**
     * a #GdaSqlParamSpec, or %NULL if this is not a variable
     */
    paramSpec: any
    /**
     * not %NULL if expression is a function or aggregate
     */
    func: any
    /**
     * not %NULL if expression is a condition or an operation
     */
    cond: any
    /**
     * not %NULL if expression is a sub select statement (#GdaSqlStatementSelect or #GdaSqlStatementCompound)
     */
    select: any
    /**
     * not %NULL if expression is a CASE WHEN ... expression
     */
    caseS: any
    /**
     * not %NULL if expression must be cast to another data type
     */
    castAs: string
    /**
     * Please see specific note about the `value` field
     */
    valueIsIdent: boolean
    /* Methods of Gda-5.0.Gda.SqlExpr */
    free(): void
    serialize(): string
    takeSelect(stmt: SqlStatement): void
    static name: string
}
class SqlField {
    /* Fields of Gda-5.0.Gda.SqlField */
    any: any
    fieldName: string
    validityMetaTableColumn: MetaTableColumn
    /* Methods of Gda-5.0.Gda.SqlField */
    free(): void
    serialize(): string
    takeName(value: any): void
    static name: string
}
class SqlFunction {
    /* Fields of Gda-5.0.Gda.SqlFunction */
    /**
     * inheritance structure
     */
    any: any
    /**
     * name of the function , in the form [[catalog.]schema.]function_name
     */
    functionName: string
    /**
     * list of #GdaSqlExpr expressions, one for each argument
     */
    argsList: object[]
    /* Methods of Gda-5.0.Gda.SqlFunction */
    checkClean(): void
    free(): void
    serialize(): string
    takeArgsList(args: object[]): void
    takeName(value: any): void
    static name: string
}
class SqlOperation {
    /* Fields of Gda-5.0.Gda.SqlOperation */
    /**
     * inheritance structure
     */
    any: any
    operatorType: SqlOperatorType
    /**
     * list of #GdaSqlExpr operands
     */
    operands: object[]
    /* Methods of Gda-5.0.Gda.SqlOperation */
    free(): void
    serialize(): string
    static name: string
    /* Static methods and pseudo-constructors */
    static operatorFromString(op: string): SqlOperatorType
    static operatorToString(op: SqlOperatorType): string
}
abstract class SqlParserClass {
    /* Fields of Gda-5.0.Gda.SqlParserClass */
    parentClass: GObject.ObjectClass
    delimAlloc: (f: object) => object
    delimFree: (d: object, f: object) => void
    delimTrace: (d: object, s: string) => void
    delimParse: (d: object, i: number, v: any, iface: SqlParserIface) => void
    delimTokensTrans: number
    parserAlloc: (f: object) => object
    parserFree: (p: object, f: object) => void
    parserTrace: (p: object, s: string) => void
    parserParse: (p: object, i: number, v: any, iface: SqlParserIface) => void
    parserTokensTrans: number
    static name: string
}
class SqlParserIface {
    /* Fields of Gda-5.0.Gda.SqlParserIface */
    parser: SqlParser
    parsedStatement: SqlStatement
    static name: string
}
class SqlParserPrivate {
    static name: string
}
class SqlRenderingContext {
    /* Fields of Gda-5.0.Gda.SqlRenderingContext */
    /**
     * Global rendering options
     */
    flags: StatementSqlFlag
    /**
     * Parameters to be used while doing the rendering
     */
    params: Set
    /**
     * When rendering is complete, contains the ordered list of parameters which have been used while doing the rendering
     */
    paramsUsed: Holder[]
    /**
     * Pointer to the server provider to be used
     */
    provider: ServerProvider
    /**
     * Pointer to the connection to be used
     */
    cnc: Connection
    /**
     * function to render a #GValue
     */
    renderValue: SqlRenderingValue
    static name: string
}
class SqlSelectField {
    /* Fields of Gda-5.0.Gda.SqlSelectField */
    /**
     * inheritance structure
     */
    any: any
    /**
     * expression
     */
    expr: any
    /**
     * field name part of `expr` if `expr` represents a field
     */
    fieldName: string
    /**
     * table name part of `expr` if `expr` represents a field
     */
    tableName: string
    /**
     * alias
     */
    as: string
    validityMetaObject: MetaDbObject
    validityMetaTableColumn: MetaTableColumn
    /* Methods of Gda-5.0.Gda.SqlSelectField */
    free(): void
    serialize(): string
    takeAlias(alias: any): void
    takeStarValue(value: any): void
    static name: string
}
class SqlSelectFrom {
    /* Fields of Gda-5.0.Gda.SqlSelectFrom */
    /**
     * inheritance structure
     */
    any: any
    /**
     * list of #GdaSqlSelectTarget
     */
    targets: any[]
    /**
     * list of #GdaSqlSelectJoin
     */
    joins: any[]
    /* Methods of Gda-5.0.Gda.SqlSelectFrom */
    free(): void
    serialize(): string
    static name: string
}
class SqlSelectJoin {
    /* Fields of Gda-5.0.Gda.SqlSelectJoin */
    /**
     * inheritance structure
     */
    any: any
    /**
     * type of join
     */
    type: SqlSelectJoinType
    /**
     * represents a join between a target at (pos &lt; `position)` and the one at `position`
     */
    position: number
    /**
     * joining expression, or %NULL
     */
    expr: any
    /**
     * list of #GdaSqlField pointers to use when joining, or %NULL
     */
    use: object[]
    /* Methods of Gda-5.0.Gda.SqlSelectJoin */
    free(): void
    serialize(): string
    static name: string
    /* Static methods and pseudo-constructors */
    static typeToString(type: SqlSelectJoinType): string
}
class SqlSelectOrder {
    /* Fields of Gda-5.0.Gda.SqlSelectOrder */
    /**
     * inheritance structure
     */
    any: any
    /**
     * expression to order on
     */
    expr: any
    /**
     * TRUE is ordering is ascending
     */
    asc: boolean
    /**
     * name of the collation to use for ordering
     */
    collationName: string
    /* Methods of Gda-5.0.Gda.SqlSelectOrder */
    free(): void
    serialize(): string
    static name: string
}
class SqlSelectTarget {
    /* Fields of Gda-5.0.Gda.SqlSelectTarget */
    /**
     * inheritance structure
     */
    any: any
    /**
     * expression
     */
    expr: any
    /**
     * table name part of `expr` if `expr` represents a table
     */
    tableName: string
    /**
     * alias
     */
    as: string
    validityMetaObject: MetaDbObject
    /* Methods of Gda-5.0.Gda.SqlSelectTarget */
    free(): void
    serialize(): string
    takeAlias(alias: any): void
    takeSelect(stmt: SqlStatement): void
    takeTableName(value: any): void
    static name: string
}
class SqlStatement {
    /* Methods of Gda-5.0.Gda.SqlStatement */
    compoundSetType(type: SqlStatementCompoundType): void
    compoundTakeStmt(s: SqlStatement): void
    static name: string
}
class SqlStatementCheckValidityData {
    /* Fields of Gda-5.0.Gda.SqlStatementCheckValidityData */
    cnc: Connection
    store: MetaStore
    mstruct: MetaStruct
    static name: string
}
class SqlStatementCompound {
    /* Fields of Gda-5.0.Gda.SqlStatementCompound */
    any: any
    compoundType: SqlStatementCompoundType
    stmtList: object[]
    static name: string
}
class SqlStatementContentsInfo {
    /* Fields of Gda-5.0.Gda.SqlStatementContentsInfo */
    type: SqlStatementType
    name: string
    construct: () => object
    free: (stm: object) => void
    copy: (stm: object) => object
    serialize: (stm: object) => string
    checkStructureFunc: any
    checkValidityFunc: any
    static name: string
}
class SqlStatementDelete {
    static name: string
}
class SqlStatementInsert {
    static name: string
}
class SqlStatementSelect {
    static name: string
}
class SqlStatementTransaction {
    static name: string
}
class SqlStatementUnknown {
    static name: string
}
class SqlStatementUpdate {
    static name: string
}
class SqlTable {
    /* Fields of Gda-5.0.Gda.SqlTable */
    any: any
    tableName: string
    validityMetaObject: MetaDbObject
    /* Methods of Gda-5.0.Gda.SqlTable */
    free(): void
    serialize(): string
    takeName(value: any): void
    static name: string
}
abstract class StatementClass {
    /* Fields of Gda-5.0.Gda.StatementClass */
    parentClass: GObject.ObjectClass
    checked: (stmt: Statement, cnc: Connection, checked: boolean) => void
    reset: (stmt: Statement) => void
    static name: string
}
class StatementPrivate {
    static name: string
}
class ThreadNotification {
    /* Fields of Gda-5.0.Gda.ThreadNotification */
    /**
     * the notification type
     */
    type: ThreadNotificationType
    /**
     * the job ID, if `type` is a #GDA_THREAD_NOTIFICATION_JOB
     */
    jobId: number
    static name: string
}
abstract class ThreadWrapperClass {
    /* Fields of Gda-5.0.Gda.ThreadWrapperClass */
    objectClass: GObject.ObjectClass
    static name: string
}
class ThreadWrapperPrivate {
    static name: string
}
class Time {
    /* Fields of Gda-5.0.Gda.Time */
    /**
     * hour representation of the time, as a number between 0 and 23
     */
    hour: number
    /**
     * minute representation of the time, as a number between 0 and 59
     */
    minute: number
    /**
     * second representation of the time, as a number between 0 and 59
     */
    second: number
    /**
     * fractionnal part of the seconds, in millionth' of second
     */
    fraction: number
    /**
     * number of seconds added to the GMT timezone
     */
    timezone: number
    /* Methods of Gda-5.0.Gda.Time */
    /**
     * Changes `time'`s timezone (for example to convert from GMT to another time zone).
     * If `time'`s current timezone is unset (i.e. equal to %GDA_TIMEZONE_INVALID), then this function simply sets
     * `time'`s timezone attribute; Otherwise, it adds or removes hours, minutes or seconds to reflect the time in the new timezone.
     * 
     * Note: the resulting will always be a valid time.
     * @param ntz a new timezone to use, in seconds added to GMT
     */
    changeTimezone(ntz: number): void
    valid(): boolean
    static name: string
    /* Static methods and pseudo-constructors */
    static copy(boxed?: object | null): object | null
    static free(boxed?: object | null): void
}
class Timestamp {
    /* Fields of Gda-5.0.Gda.Timestamp */
    /**
     * year representation of the time stamp
     */
    year: number
    /**
     * month representation of the time stamp, as a number between 1 and 12
     */
    month: number
    /**
     * day representation of the time stamp, as a number between 1 and 31
     */
    day: number
    /**
     * hour representation of the time stamp, as a number between 0 and 23
     */
    hour: number
    /**
     * minute representation of the time stamp, as a number between 0 and 59
     */
    minute: number
    /**
     * second representation of the time stamp, as a number between 0 and 59
     */
    second: number
    /**
     * fractionnal part of the seconds, in millionth' of second
     */
    fraction: number
    /**
     * number of seconds added to the GMT timezone
     */
    timezone: number
    /* Methods of Gda-5.0.Gda.Timestamp */
    /**
     * This function is similar to gda_time_change_timezone() but operates on time stamps.
     * 
     * Note: the resulting will always be a valid time.
     * @param ntz a new timezone to use, in seconds added to GMT
     */
    changeTimezone(ntz: number): void
    valid(): boolean
    static name: string
    /* Static methods and pseudo-constructors */
    static copy(boxed?: object | null): object | null
    static free(boxed?: object | null): void
}
abstract class TransactionStatusClass {
    /* Fields of Gda-5.0.Gda.TransactionStatusClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class TransactionStatusEvent {
    /* Fields of Gda-5.0.Gda.TransactionStatusEvent */
    trans: TransactionStatus
    type: TransactionStatusEventType
    connEvent: ConnectionEvent
    static name: string
}
abstract class TreeClass {
    /* Fields of Gda-5.0.Gda.TreeClass */
    objectClass: GObject.ObjectClass
    nodeChanged: (tree: Tree, node: TreeNode) => void
    nodeInserted: (tree: Tree, node: TreeNode) => void
    nodeHasChildToggled: (tree: Tree, node: TreeNode) => void
    nodeDeleted: (tree: Tree, nodePath: string) => void
    static name: string
}
abstract class TreeManagerClass {
    /* Fields of Gda-5.0.Gda.TreeManagerClass */
    objectClass: GObject.ObjectClass
    static name: string
}
class TreeManagerPrivate {
    static name: string
}
abstract class TreeMgrColumnsClass {
    /* Fields of Gda-5.0.Gda.TreeMgrColumnsClass */
    objectClass: TreeManagerClass
    static name: string
}
class TreeMgrColumnsPriv {
    static name: string
}
abstract class TreeMgrLabelClass {
    /* Fields of Gda-5.0.Gda.TreeMgrLabelClass */
    objectClass: TreeManagerClass
    static name: string
}
class TreeMgrLabelPriv {
    static name: string
}
abstract class TreeMgrLdapClass {
    /* Fields of Gda-5.0.Gda.TreeMgrLdapClass */
    objectClass: TreeManagerClass
    static name: string
}
class TreeMgrLdapPriv {
    static name: string
}
abstract class TreeMgrSchemasClass {
    /* Fields of Gda-5.0.Gda.TreeMgrSchemasClass */
    objectClass: TreeManagerClass
    static name: string
}
class TreeMgrSchemasPriv {
    static name: string
}
abstract class TreeMgrSelectClass {
    /* Fields of Gda-5.0.Gda.TreeMgrSelectClass */
    objectClass: TreeManagerClass
    static name: string
}
class TreeMgrSelectPriv {
    static name: string
}
abstract class TreeMgrTablesClass {
    /* Fields of Gda-5.0.Gda.TreeMgrTablesClass */
    objectClass: TreeManagerClass
    static name: string
}
class TreeMgrTablesPriv {
    static name: string
}
abstract class TreeNodeClass {
    /* Fields of Gda-5.0.Gda.TreeNodeClass */
    objectClass: GObject.ObjectClass
    nodeChanged: (reporting: TreeNode, node: TreeNode) => void
    nodeInserted: (reporting: TreeNode, node: TreeNode) => void
    nodeHasChildToggled: (reporting: TreeNode, node: TreeNode) => void
    nodeDeleted: (reporting: TreeNode, relativePath: string) => void
    dumpHeader: (node: TreeNode) => string
    dumpChildren: (node: TreeNode, prefix: string, inString: GLib.String) => void
    static name: string
}
class TreeNodePrivate {
    static name: string
}
class TreePrivate {
    static name: string
}
abstract class XaTransactionClass {
    /* Fields of Gda-5.0.Gda.XaTransactionClass */
    parentClass: GObject.ObjectClass
    static name: string
}
class XaTransactionId {
    /* Fields of Gda-5.0.Gda.XaTransactionId */
    /**
     * any number
     */
    format: number
    /**
     * number between 1 and 64
     */
    gtridLength: number
    /**
     * number between 1 and 64
     */
    bqualLength: number
    data: number[]
    /* Methods of Gda-5.0.Gda.XaTransactionId */
    /**
     * Creates a string representation of `xid,` in the format &lt;gtrid&gt;,&lt;bqual&gt;,&lt;formatID&gt; the
     * &lt;gtrid&gt; and &lt;bqual&gt; strings contain alphanumeric characters, and non alphanumeric characters
     * are converted to "%ab" where ab is the hexadecimal representation of the character.
     */
    toString(): string
    static name: string
}
class XaTransactionPrivate {
    static name: string
}
    type Mutex = GLib.RecMutex
    type SqlBuilderId = number
    type SqlErrorType = SqlError
}
export default Gda;