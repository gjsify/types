/*
 * Type Definitions for node-gtk (https://github.com/romgrk/node-gtk)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * Clutter-1.0
 */

import type cairo from './cairo-1.0';
import type Json from './Json-1.0';
import type Gio from './Gio-2.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';
import type GL from './GL-1.0';
import type CoglPango from './CoglPango-1.0';
import type PangoCairo from './PangoCairo-1.0';
import type Pango from './Pango-1.0';
import type HarfBuzz from './HarfBuzz-0.0';
import type Cogl from './Cogl-1.0';
import type Atk from './Atk-1.0';

export namespace Clutter {

/**
 * Controls how a #ClutterActor should align itself inside the extra space
 * assigned to it during the allocation.
 * 
 * Alignment only matters if the allocated space given to an actor is
 * bigger than its natural size; for example, when the #ClutterActor:x-expand
 * or the #ClutterActor:y-expand properties of #ClutterActor are set to %TRUE.
 */
enum ActorAlign {
    /**
     * Stretch to cover the whole allocated space
     */
    FILL,
    /**
     * Snap to left or top side, leaving space
     *   to the right or bottom. For horizontal layouts, in right-to-left
     *   locales this should be reversed.
     */
    START,
    /**
     * Center the actor inside the allocation
     */
    CENTER,
    /**
     * Snap to right or bottom side, leaving space
     *   to the left or top. For horizontal layouts, in right-to-left locales
     *   this should be reversed.
     */
    END,
}
/**
 * Specifies the axis on which #ClutterAlignConstraint should maintain
 * the alignment.
 */
enum AlignAxis {
    /**
     * Maintain the alignment on the X axis
     */
    X_AXIS,
    /**
     * Maintain the alignment on the Y axis
     */
    Y_AXIS,
    /**
     * Maintain the alignment on both the X and Y axis
     */
    BOTH,
}
/**
 * The animation modes used by #ClutterAlpha and #ClutterAnimation. This
 * enumeration can be expanded in later versions of Clutter.
 * 
 * <figure id="easing-modes">
 *   <title>Easing modes provided by Clutter</title>
 *   <graphic fileref="easing-modes.png" format="PNG"/>
 * </figure>
 * 
 * Every global alpha function registered using clutter_alpha_register_func()
 * or clutter_alpha_register_closure() will have a logical id greater than
 * %CLUTTER_ANIMATION_LAST.
 */
enum AnimationMode {
    /**
     * custom progress function
     */
    CUSTOM_MODE,
    /**
     * linear tweening
     */
    LINEAR,
    /**
     * quadratic tweening
     */
    EASE_IN_QUAD,
    /**
     * quadratic tweening, inverse of
     *    %CLUTTER_EASE_IN_QUAD
     */
    EASE_OUT_QUAD,
    /**
     * quadratic tweening, combininig
     *    %CLUTTER_EASE_IN_QUAD and %CLUTTER_EASE_OUT_QUAD
     */
    EASE_IN_OUT_QUAD,
    /**
     * cubic tweening
     */
    EASE_IN_CUBIC,
    /**
     * cubic tweening, invers of
     *    %CLUTTER_EASE_IN_CUBIC
     */
    EASE_OUT_CUBIC,
    /**
     * cubic tweening, combining
     *    %CLUTTER_EASE_IN_CUBIC and %CLUTTER_EASE_OUT_CUBIC
     */
    EASE_IN_OUT_CUBIC,
    /**
     * quartic tweening
     */
    EASE_IN_QUART,
    /**
     * quartic tweening, inverse of
     *    %CLUTTER_EASE_IN_QUART
     */
    EASE_OUT_QUART,
    /**
     * quartic tweening, combining
     *    %CLUTTER_EASE_IN_QUART and %CLUTTER_EASE_OUT_QUART
     */
    EASE_IN_OUT_QUART,
    /**
     * quintic tweening
     */
    EASE_IN_QUINT,
    /**
     * quintic tweening, inverse of
     *    %CLUTTER_EASE_IN_QUINT
     */
    EASE_OUT_QUINT,
    /**
     * fifth power tweening, combining
     *    %CLUTTER_EASE_IN_QUINT and %CLUTTER_EASE_OUT_QUINT
     */
    EASE_IN_OUT_QUINT,
    /**
     * sinusoidal tweening
     */
    EASE_IN_SINE,
    /**
     * sinusoidal tweening, inverse of
     *    %CLUTTER_EASE_IN_SINE
     */
    EASE_OUT_SINE,
    /**
     * sine wave tweening, combining
     *    %CLUTTER_EASE_IN_SINE and %CLUTTER_EASE_OUT_SINE
     */
    EASE_IN_OUT_SINE,
    /**
     * exponential tweening
     */
    EASE_IN_EXPO,
    /**
     * exponential tweening, inverse of
     *    %CLUTTER_EASE_IN_EXPO
     */
    EASE_OUT_EXPO,
    /**
     * exponential tweening, combining
     *    %CLUTTER_EASE_IN_EXPO and %CLUTTER_EASE_OUT_EXPO
     */
    EASE_IN_OUT_EXPO,
    /**
     * circular tweening
     */
    EASE_IN_CIRC,
    /**
     * circular tweening, inverse of
     *    %CLUTTER_EASE_IN_CIRC
     */
    EASE_OUT_CIRC,
    /**
     * circular tweening, combining
     *    %CLUTTER_EASE_IN_CIRC and %CLUTTER_EASE_OUT_CIRC
     */
    EASE_IN_OUT_CIRC,
    /**
     * elastic tweening, with offshoot on start
     */
    EASE_IN_ELASTIC,
    /**
     * elastic tweening, with offshoot on end
     */
    EASE_OUT_ELASTIC,
    /**
     * elastic tweening with offshoot on both ends
     */
    EASE_IN_OUT_ELASTIC,
    /**
     * overshooting cubic tweening, with
     *   backtracking on start
     */
    EASE_IN_BACK,
    /**
     * overshooting cubic tweening, with
     *   backtracking on end
     */
    EASE_OUT_BACK,
    /**
     * overshooting cubic tweening, with
     *   backtracking on both ends
     */
    EASE_IN_OUT_BACK,
    /**
     * exponentially decaying parabolic (bounce)
     *   tweening, with bounce on start
     */
    EASE_IN_BOUNCE,
    /**
     * exponentially decaying parabolic (bounce)
     *   tweening, with bounce on end
     */
    EASE_OUT_BOUNCE,
    /**
     * exponentially decaying parabolic (bounce)
     *   tweening, with bounce on both ends
     */
    EASE_IN_OUT_BOUNCE,
    /**
     * parametrized step function; see clutter_timeline_set_step_progress()
     *   for further details. (Since 1.12)
     */
    STEPS,
    /**
     * equivalent to %CLUTTER_STEPS with a number of steps
     *   equal to 1, and a step mode of %CLUTTER_STEP_MODE_START. (Since 1.12)
     */
    STEP_START,
    /**
     * equivalent to %CLUTTER_STEPS with a number of steps
     *   equal to 1, and a step mode of %CLUTTER_STEP_MODE_END. (Since 1.12)
     */
    STEP_END,
    /**
     * cubic bezier between (0, 0) and (1, 1) with two
     *   control points; see clutter_timeline_set_cubic_bezier_progress(). (Since 1.12)
     */
    CUBIC_BEZIER,
    /**
     * equivalent to %CLUTTER_CUBIC_BEZIER with control points
     *   in (0.25, 0.1) and (0.25, 1.0). (Since 1.12)
     */
    EASE,
    /**
     * equivalent to %CLUTTER_CUBIC_BEZIER with control points
     *   in (0.42, 0) and (1.0, 1.0). (Since 1.12)
     */
    EASE_IN,
    /**
     * equivalent to %CLUTTER_CUBIC_BEZIER with control points
     *   in (0, 0) and (0.58, 1.0). (Since 1.12)
     */
    EASE_OUT,
    /**
     * equivalent to %CLUTTER_CUBIC_BEZIER with control points
     *   in (0.42, 0) and (0.58, 1.0). (Since 1.12)
     */
    EASE_IN_OUT,
    /**
     * last animation mode, used as a guard for
     *   registered global alpha functions
     */
    ANIMATION_LAST,
}
/**
 * The alignment policies available on each axis for #ClutterBinLayout
 */
enum BinAlignment {
    /**
     * Fixed position alignment; the
     *   #ClutterBinLayout will honour the fixed position provided
     *   by the actors themselves when allocating them
     */
    FIXED,
    /**
     * Fill the allocation size
     */
    FILL,
    /**
     * Position the actors at the top
     *   or left side of the container, depending on the axis
     */
    START,
    /**
     * Position the actors at the bottom
     *   or right side of the container, depending on the axis
     */
    END,
    /**
     * Position the actors at the
     *   center of the container, depending on the axis
     */
    CENTER,
}
/**
 * Specifies which property should be used in a binding
 */
enum BindCoordinate {
    /**
     * Bind the X coordinate
     */
    X,
    /**
     * Bind the Y coordinate
     */
    Y,
    /**
     * Bind the width
     */
    WIDTH,
    /**
     * Bind the height
     */
    HEIGHT,
    /**
     * Equivalent to to %CLUTTER_BIND_X and
     *   %CLUTTER_BIND_Y (added in Clutter 1.6)
     */
    POSITION,
    /**
     * Equivalent to %CLUTTER_BIND_WIDTH and
     *   %CLUTTER_BIND_HEIGHT (added in Clutter 1.6)
     */
    SIZE,
    /**
     * Equivalent to %CLUTTER_BIND_POSITION and
     *   %CLUTTER_BIND_SIZE (added in Clutter 1.10)
     */
    ALL,
}
/**
 * The alignment policies available on each axis of the #ClutterBoxLayout
 */
enum BoxAlignment {
    /**
     * Align the child to the top or to
     *   to the left, depending on the used axis
     */
    START,
    /**
     * Align the child to the bottom or to
     *   the right, depending on the used axis
     */
    END,
    /**
     * Align the child to the center
     */
    CENTER,
}
/**
 * Controls the alignment of the #ClutterContent inside a #ClutterActor.
 */
enum ContentGravity {
    /**
     * Align the content to the top left corner
     */
    TOP_LEFT,
    /**
     * Align the content to the top edge
     */
    TOP,
    /**
     * Align the content to the top right corner
     */
    TOP_RIGHT,
    /**
     * Align the content to the left edge
     */
    LEFT,
    /**
     * Align the content to the center
     */
    CENTER,
    /**
     * Align the content to the right edge
     */
    RIGHT,
    /**
     * Align the content to the bottom left corner
     */
    BOTTOM_LEFT,
    /**
     * Align the content to the bottom edge
     */
    BOTTOM,
    /**
     * Align the content to the bottom right corner
     */
    BOTTOM_RIGHT,
    /**
     * Resize the content to fill the allocation
     */
    RESIZE_FILL,
    /**
     * Resize the content to remain within the
     *   allocation, while maintaining the aspect ratio
     */
    RESIZE_ASPECT,
}
/**
 * The axis of the constraint that should be applied on the
 * dragging action
 */
enum DragAxis {
    /**
     * No constraint
     */
    AXIS_NONE,
    /**
     * Set a constraint on the X axis
     */
    X_AXIS,
    /**
     * Set a constraint on the Y axis
     */
    Y_AXIS,
}
/**
 * Types of events.
 */
enum EventType {
    /**
     * Empty event
     */
    NOTHING,
    /**
     * Key press event
     */
    KEY_PRESS,
    /**
     * Key release event
     */
    KEY_RELEASE,
    /**
     * Pointer motion event
     */
    MOTION,
    /**
     * Actor enter event
     */
    ENTER,
    /**
     * Actor leave event
     */
    LEAVE,
    /**
     * Pointer button press event
     */
    BUTTON_PRESS,
    /**
     * Pointer button release event
     */
    BUTTON_RELEASE,
    /**
     * Pointer scroll event
     */
    SCROLL,
    /**
     * Stage state change event
     */
    STAGE_STATE,
    /**
     * Destroy notification event
     */
    DESTROY_NOTIFY,
    /**
     * Client message event
     */
    CLIENT_MESSAGE,
    /**
     * Stage delete event
     */
    DELETE,
    /**
     * A new touch event sequence has started;
     *   event added in 1.10
     */
    TOUCH_BEGIN,
    /**
     * A touch event sequence has been updated;
     *   event added in 1.10
     */
    TOUCH_UPDATE,
    /**
     * A touch event sequence has finished;
     *   event added in 1.10
     */
    TOUCH_END,
    /**
     * A touch event sequence has been canceled;
     *   event added in 1.10
     */
    TOUCH_CANCEL,
    /**
     * A pinch gesture event, the current state is
     *   determined by its phase field; event added in 1.24
     */
    TOUCHPAD_PINCH,
    /**
     * A swipe gesture event, the current state is
     *   determined by its phase field; event added in 1.24
     */
    TOUCHPAD_SWIPE,
    /**
     * Marks the end of the #ClutterEventType enumeration;
     *   added in 1.10
     */
    EVENT_LAST,
}
/**
 * The direction of the arrangement of the children inside
 * a #ClutterFlowLayout
 */
enum FlowOrientation {
    /**
     * Arrange the children of the flow layout
     *   horizontally first
     */
    HORIZONTAL,
    /**
     * Arrange the children of the flow layout
     *   vertically first
     */
    VERTICAL,
}
/**
 * Enum passed to the clutter_gesture_action_set_threshold_trigger_edge()
 * function.
 */
enum GestureTriggerEdge {
    /**
     * Tell #ClutterGestureAction that
     * the gesture must begin immediately and there's no drag limit that
     * will cause its cancellation;
     */
    NONE,
    /**
     * Tell #ClutterGestureAction that
     * it needs to wait until the drag threshold has been exceeded before
     * considering that the gesture has begun;
     */
    AFTER,
    /**
     * Tell #ClutterGestureAction that
     * the gesture must begin immediately and that it must be cancelled
     * once the drag exceed the configured threshold.
     */
    BEFORE,
}
/**
 * Gravity of the scaling operations. When a gravity different than
 * %CLUTTER_GRAVITY_NONE is used, an actor is scaled keeping the position
 * of the specified portion at the same coordinates.
 */
enum Gravity {
    /**
     * Do not apply any gravity
     */
    NONE,
    /**
     * Scale from topmost downwards
     */
    NORTH,
    /**
     * Scale from the top right corner
     */
    NORTH_EAST,
    /**
     * Scale from the right side
     */
    EAST,
    /**
     * Scale from the bottom right corner
     */
    SOUTH_EAST,
    /**
     * Scale from the bottom upwards
     */
    SOUTH,
    /**
     * Scale from the bottom left corner
     */
    SOUTH_WEST,
    /**
     * Scale from the left side
     */
    WEST,
    /**
     * Scale from the top left corner
     */
    NORTH_WEST,
    /**
     * Scale from the center.
     */
    CENTER,
}
/**
 * Grid position modes.
 */
enum GridPosition {
    /**
     * left position
     */
    LEFT,
    /**
     * right position
     */
    RIGHT,
    /**
     * top position
     */
    TOP,
    /**
     * bottom position
     */
    BOTTOM,
}
/**
 * Error enumeration for #ClutterImage.
 */
enum ImageError {
    /**
     * Invalid data passed to the
     *   clutter_image_set_data() function.
     */
    DATA,
}
/**
 * Error conditions returned by clutter_init() and clutter_init_with_args().
 */
enum InitError {
    /**
     * Initialisation successful
     */
    SUCCESS,
    /**
     * Unknown error
     */
    ERROR_UNKNOWN,
    /**
     * Thread initialisation failed
     */
    ERROR_THREADS,
    /**
     * Backend initialisation failed
     */
    ERROR_BACKEND,
    /**
     * Internal error
     */
    ERROR_INTERNAL,
}
/**
 * The type of axes Clutter recognizes on a #ClutterInputDevice
 */
enum InputAxis {
    /**
     * Unused axis
     */
    IGNORE,
    /**
     * The position on the X axis
     */
    X,
    /**
     * The position of the Y axis
     */
    Y,
    /**
     * The pressure information
     */
    PRESSURE,
    /**
     * The tilt on the X axis
     */
    XTILT,
    /**
     * The tile on the Y axis
     */
    YTILT,
    /**
     * A wheel
     */
    WHEEL,
    /**
     * Distance (Since 1.12)
     */
    DISTANCE,
    /**
     * Last value of the enumeration; this value is
     *   useful when iterating over the enumeration values (Since 1.12)
     */
    LAST,
}
/**
 * The types of input devices available.
 * 
 * The #ClutterInputDeviceType enumeration can be extended at later
 * date; not every platform supports every input device type.
 */
enum InputDeviceType {
    /**
     * A pointer device
     */
    POINTER_DEVICE,
    /**
     * A keyboard device
     */
    KEYBOARD_DEVICE,
    /**
     * A generic extension device
     */
    EXTENSION_DEVICE,
    /**
     * A joystick device
     */
    JOYSTICK_DEVICE,
    /**
     * A tablet device
     */
    TABLET_DEVICE,
    /**
     * A touchpad device
     */
    TOUCHPAD_DEVICE,
    /**
     * A touch screen device
     */
    TOUCHSCREEN_DEVICE,
    /**
     * A pen device
     */
    PEN_DEVICE,
    /**
     * An eraser device
     */
    ERASER_DEVICE,
    /**
     * A cursor device
     */
    CURSOR_DEVICE,
    /**
     * The number of device types
     */
    N_DEVICE_TYPES,
}
/**
 * The mode for input devices available.
 */
enum InputMode {
    /**
     * A master, virtual device
     */
    MASTER,
    /**
     * A slave, physical device, attached to
     *   a master device
     */
    SLAVE,
    /**
     * A slave, physical device, not attached
     *   to a master device
     */
    FLOATING,
}
/**
 * The mode of interpolation between key frames
 */
enum Interpolation {
    /**
     * linear interpolation
     */
    LINEAR,
    /**
     * cubic interpolation
     */
    CUBIC,
}
/**
 * The states for the #ClutterClickAction::long-press signal.
 */
enum LongPressState {
    /**
     * Queries the action whether it supports
     *   long presses
     */
    QUERY,
    /**
     * Activates the action on a long press
     */
    ACTIVATE,
    /**
     * The long press was cancelled
     */
    CANCEL,
}
/**
 * Represents the orientation of actors or layout managers.
 */
enum Orientation {
    /**
     * An horizontal orientation
     */
    HORIZONTAL,
    /**
     * A vertical orientation
     */
    VERTICAL,
}
/**
 * The axis of the constraint that should be applied on the
 * panning action
 */
enum PanAxis {
    /**
     * No constraint
     */
    AXIS_NONE,
    /**
     * Set a constraint on the X axis
     */
    X_AXIS,
    /**
     * Set a constraint on the Y axis
     */
    Y_AXIS,
    /**
     * Constrain panning automatically based on initial
     *   movement (available since 1.24)
     */
    AXIS_AUTO,
}
/**
 * Types of nodes in a #ClutterPath.
 */
enum PathNodeType {
    /**
     * jump to the given position
     */
    MOVE_TO,
    /**
     * create a line from the last node to the
     *   given position
     */
    LINE_TO,
    /**
     * bezier curve using the last position and
     *   three control points.
     */
    CURVE_TO,
    /**
     * create a line from the last node to the last
     *   %CLUTTER_PATH_MOVE_TO node.
     */
    CLOSE,
    /**
     * same as %CLUTTER_PATH_MOVE_TO but with
     *   coordinates relative to the last node.
     */
    REL_MOVE_TO,
    /**
     * same as %CLUTTER_PATH_LINE_TO but with
     *   coordinates relative to the last node.
     */
    REL_LINE_TO,
    /**
     * same as %CLUTTER_PATH_CURVE_TO but with
     *   coordinates relative to the last node.
     */
    REL_CURVE_TO,
}
/**
 * Controls the paint cycle of the scene graph when in pick mode
 */
enum PickMode {
    /**
     * Do not paint any actor
     */
    NONE,
    /**
     * Paint only the reactive actors
     */
    REACTIVE,
    /**
     * Paint all actors
     */
    ALL,
}
/**
 * Specifies the type of requests for a #ClutterActor.
 */
enum RequestMode {
    /**
     * Height for width requests
     */
    HEIGHT_FOR_WIDTH,
    /**
     * Width for height requests
     */
    WIDTH_FOR_HEIGHT,
    /**
     * Use the preferred size of the
     *   #ClutterContent, if it has any (available since 1.22)
     */
    CONTENT_SIZE,
}
/**
 * Axis of a rotation.
 */
enum RotateAxis {
    /**
     * Rotate around the X axis
     */
    X_AXIS,
    /**
     * Rotate around the Y axis
     */
    Y_AXIS,
    /**
     * Rotate around the Z axis
     */
    Z_AXIS,
}
/**
 * Direction of a rotation.
 */
enum RotateDirection {
    /**
     * Clockwise rotation
     */
    CW,
    /**
     * Counter-clockwise rotation
     */
    CCW,
}
/**
 * The scaling filters to be used with the #ClutterActor:minification-filter
 * and #ClutterActor:magnification-filter properties.
 */
enum ScalingFilter {
    /**
     * Linear interpolation filter
     */
    LINEAR,
    /**
     * Nearest neighbor interpolation filter
     */
    NEAREST,
    /**
     * Trilinear minification filter, with
     *   mipmap generation; this filter linearly interpolates on every axis,
     *   as well as between mipmap levels.
     */
    TRILINEAR,
}
/**
 * #ClutterScript error enumeration.
 */
enum ScriptError {
    /**
     * Type function not found
     *   or invalid
     */
    TYPE_FUNCTION,
    /**
     * Property not found or invalid
     */
    PROPERTY,
    /**
     * Invalid value
     */
    VALUE,
}
/**
 * Direction of a pointer scroll event.
 * 
 * The %CLUTTER_SCROLL_SMOOTH value implies that the #ClutterScrollEvent
 * has precise scrolling delta information.
 */
enum ScrollDirection {
    /**
     * Scroll up
     */
    UP,
    /**
     * Scroll down
     */
    DOWN,
    /**
     * Scroll left
     */
    LEFT,
    /**
     * Scroll right
     */
    RIGHT,
    /**
     * Precise scrolling delta (available in 1.10)
     */
    SMOOTH,
}
/**
 * The scroll source determines the source of the scroll event. Keep in mind
 * that the source device #ClutterInputDeviceType is not enough to infer
 * the scroll source.
 */
enum ScrollSource {
    /**
     * Source of scroll events is unknown.
     */
    UNKNOWN,
    /**
     * The scroll event is originated by a mouse wheel.
     */
    WHEEL,
    /**
     * The scroll event is originated by one or more
     *   fingers on the device (eg. touchpads).
     */
    FINGER,
    /**
     * The scroll event is originated by the
     *   motion of some device (eg. a scroll button is set).
     */
    CONTINUOUS,
}
/**
 * #ClutterShader error enumeration
 */
enum ShaderError {
    /**
     * No ASM shaders support
     */
    NO_ASM,
    /**
     * No GLSL shaders support
     */
    NO_GLSL,
    /**
     * Compilation error
     */
    COMPILE,
}
/**
 * The type of GLSL shader program
 */
enum ShaderType {
    /**
     * a vertex shader
     */
    VERTEX_SHADER,
    /**
     * a fragment shader
     */
    FRAGMENT_SHADER,
}
/**
 * The edge to snap
 */
enum SnapEdge {
    /**
     * the top edge
     */
    TOP,
    /**
     * the right edge
     */
    RIGHT,
    /**
     * the bottom edge
     */
    BOTTOM,
    /**
     * the left edge
     */
    LEFT,
}
/**
 * Named colors, for accessing global colors defined by Clutter
 */
enum StaticColor {
    /**
     * White color (ffffffff)
     */
    WHITE,
    /**
     * Black color (000000ff)
     */
    BLACK,
    /**
     * Red color (ff0000ff)
     */
    RED,
    /**
     * Dark red color (800000ff)
     */
    DARK_RED,
    /**
     * Green color (00ff00ff)
     */
    GREEN,
    /**
     * Dark green color (008000ff)
     */
    DARK_GREEN,
    /**
     * Blue color (0000ffff)
     */
    BLUE,
    /**
     * Dark blue color (000080ff)
     */
    DARK_BLUE,
    /**
     * Cyan color (00ffffff)
     */
    CYAN,
    /**
     * Dark cyan color (008080ff)
     */
    DARK_CYAN,
    /**
     * Magenta color (ff00ffff)
     */
    MAGENTA,
    /**
     * Dark magenta color (800080ff)
     */
    DARK_MAGENTA,
    /**
     * Yellow color (ffff00ff)
     */
    YELLOW,
    /**
     * Dark yellow color (808000ff)
     */
    DARK_YELLOW,
    /**
     * Gray color (a0a0a4ff)
     */
    GRAY,
    /**
     * Dark Gray color (808080ff)
     */
    DARK_GRAY,
    /**
     * Light gray color (c0c0c0ff)
     */
    LIGHT_GRAY,
    /**
     * Butter color (edd400ff)
     */
    BUTTER,
    /**
     * Light butter color (fce94fff)
     */
    BUTTER_LIGHT,
    /**
     * Dark butter color (c4a000ff)
     */
    BUTTER_DARK,
    /**
     * Orange color (f57900ff)
     */
    ORANGE,
    /**
     * Light orange color (fcaf3fff)
     */
    ORANGE_LIGHT,
    /**
     * Dark orange color (ce5c00ff)
     */
    ORANGE_DARK,
    /**
     * Chocolate color (c17d11ff)
     */
    CHOCOLATE,
    /**
     * Light chocolate color (e9b96eff)
     */
    CHOCOLATE_LIGHT,
    /**
     * Dark chocolate color (8f5902ff)
     */
    CHOCOLATE_DARK,
    /**
     * Chameleon color (73d216ff)
     */
    CHAMELEON,
    /**
     * Light chameleon color (8ae234ff)
     */
    CHAMELEON_LIGHT,
    /**
     * Dark chameleon color (4e9a06ff)
     */
    CHAMELEON_DARK,
    /**
     * Sky color (3465a4ff)
     */
    SKY_BLUE,
    /**
     * Light sky color (729fcfff)
     */
    SKY_BLUE_LIGHT,
    /**
     * Dark sky color (204a87ff)
     */
    SKY_BLUE_DARK,
    /**
     * Plum color (75507bff)
     */
    PLUM,
    /**
     * Light plum color (ad7fa8ff)
     */
    PLUM_LIGHT,
    /**
     * Dark plum color (5c3566ff)
     */
    PLUM_DARK,
    /**
     * Scarlet red color (cc0000ff)
     */
    SCARLET_RED,
    /**
     * Light scarlet red color (ef2929ff)
     */
    SCARLET_RED_LIGHT,
    /**
     * Dark scarlet red color (a40000ff)
     */
    SCARLET_RED_DARK,
    /**
     * Aluminium, first variant (eeeeecff)
     */
    ALUMINIUM_1,
    /**
     * Aluminium, second variant (d3d7cfff)
     */
    ALUMINIUM_2,
    /**
     * Aluminium, third variant (babdb6ff)
     */
    ALUMINIUM_3,
    /**
     * Aluminium, fourth variant (888a85ff)
     */
    ALUMINIUM_4,
    /**
     * Aluminium, fifth variant (555753ff)
     */
    ALUMINIUM_5,
    /**
     * Aluminium, sixth variant (2e3436ff)
     */
    ALUMINIUM_6,
    /**
     * Transparent color (00000000)
     */
    TRANSPARENT,
}
/**
 * Change the value transition of a step function.
 * 
 * See clutter_timeline_set_step_progress().
 */
enum StepMode {
    /**
     * The change in the value of a
     *   %CLUTTER_STEP progress mode should occur at the start of
     *   the transition
     */
    START,
    /**
     * The change in the value of a
     *   %CLUTTER_STEP progress mode should occur at the end of
     *   the transition
     */
    END,
}
/**
 * The alignment policies available on each axis of the #ClutterTableLayout
 */
enum TableAlignment {
    /**
     * Align the child to the top or to the
     *   left of a cell in the table, depending on the axis
     */
    START,
    /**
     * Align the child to the center of
     *   a cell in the table
     */
    CENTER,
    /**
     * Align the child to the bottom or to the
     *   right of a cell in the table, depending on the axis
     */
    END,
}
/**
 * The text direction to be used by #ClutterActor<!-- -->s
 */
enum TextDirection {
    /**
     * Use the default setting, as returned
     *   by clutter_get_default_text_direction()
     */
    DEFAULT,
    /**
     * Use left-to-right text direction
     */
    LTR,
    /**
     * Use right-to-left text direction
     */
    RTL,
}
/**
 * Error enumeration for #ClutterTexture
 */
enum TextureError {
    /**
     * OOM condition
     */
    OUT_OF_MEMORY,
    /**
     * YUV operation attempted but no YUV support
     *   found
     */
    NO_YUV,
    /**
     * The requested format for
     * clutter_texture_set_from_rgb_data or
     * clutter_texture_set_from_yuv_data is unsupported.
     */
    BAD_FORMAT,
}
/**
 * Enumaration controlling the texture quality.
 */
enum TextureQuality {
    /**
     * fastest rendering will use nearest neighbour
     *   interpolation when rendering. good setting.
     */
    LOW,
    /**
     * higher quality rendering without using
     *   extra resources.
     */
    MEDIUM,
    /**
     * render the texture with the best quality
     *   available using extra memory.
     */
    HIGH,
}
/**
 * The direction of a #ClutterTimeline
 */
enum TimelineDirection {
    /**
     * forward direction for a timeline
     */
    FORWARD,
    /**
     * backward direction for a timeline
     */
    BACKWARD,
}
/**
 * The phase of a touchpad gesture event. All gestures are guaranteed to
 * begin with an event of type %CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN,
 * followed by a number of %CLUTTER_TOUCHPAD_GESTURE_PHASE_UPDATE (possibly 0).
 * 
 * A finished gesture may have 2 possible outcomes, an event with phase
 * %CLUTTER_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is
 * considered successful, this should be used as the hint to perform any
 * permanent changes.
 * 
 * Cancelled gestures may be so for a variety of reasons, due to hardware,
 * or due to the gesture recognition layers hinting the gesture did not
 * finish resolutely (eg. a 3rd finger being added during a pinch gesture).
 * In these cases, the last event with report the phase
 * %CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint
 * to undo any visible/permanent changes that were done throughout the
 * progress of the gesture.
 * 
 * See also #ClutterTouchpadPinchEvent and #ClutterTouchpadPinchEvent.
 */
enum TouchpadGesturePhase {
    /**
     * The gesture has begun.
     */
    BEGIN,
    /**
     * The gesture has been updated.
     */
    UPDATE,
    /**
     * The gesture was finished, changes
     *   should be permanently applied.
     */
    END,
    /**
     * The gesture was cancelled, all
     *   changes should be undone.
     */
    CANCEL,
}
/**
 * The type of unit in which a value is expressed
 * 
 * This enumeration might be expanded at later date
 */
enum UnitType {
    /**
     * Unit expressed in pixels (with subpixel precision)
     */
    PIXEL,
    /**
     * Unit expressed in em
     */
    EM,
    /**
     * Unit expressed in millimeters
     */
    MM,
    /**
     * Unit expressed in points
     */
    POINT,
    /**
     * Unit expressed in centimeters
     */
    CM,
}
/**
 * The axis of the constraint that should be applied by the
 * zooming action.
 */
enum ZoomAxis {
    /**
     * Scale only on the X axis
     */
    X_AXIS,
    /**
     * Scale only on the Y axis
     */
    Y_AXIS,
    /**
     * Scale on both axis
     */
    BOTH,
}
/**
 * Flags used to signal the state of an actor.
 */
enum ActorFlags {
    /**
     * the actor will be painted (is visible, and inside
     *   a toplevel, and all parents visible)
     */
    MAPPED,
    /**
     * the resources associated to the actor have been
     *   allocated
     */
    REALIZED,
    /**
     * the actor 'reacts' to mouse events emmitting event
     *   signals
     */
    REACTIVE,
    /**
     * the actor has been shown by the application program
     */
    VISIBLE,
    /**
     * the actor provides an explicit layout management
     *   policy for its children; this flag will prevent Clutter from automatic
     *   queueing of relayout and will defer all layouting to the actor itself
     */
    NO_LAYOUT,
}
/**
 * Flags passed to the #ClutterActorClass.allocate() virtual function
 * and to the clutter_actor_allocate() function.
 */
enum AllocationFlags {
    /**
     * No flag set
     */
    ALLOCATION_NONE,
    /**
     * Whether the absolute origin of the
     *   actor has changed; this implies that any ancestor of the actor has
     *   been moved.
     */
    ABSOLUTE_ORIGIN_CHANGED,
    /**
     * Whether the allocation should be delegated
     *   to the #ClutterLayoutManager instance stored inside the
     *   #ClutterActor:layout-manager property of #ClutterActor. This flag
     *   should only be used if you are subclassing #ClutterActor and
     *   overriding the #ClutterActorClass.allocate() virtual function, but
     *   you wish to use the default implementation of the virtual function
     *   inside #ClutterActor. Added in Clutter 1.10.
     */
    DELEGATE_LAYOUT,
}
/**
 * Content repeat modes.
 */
enum ContentRepeat {
    /**
     * No repeat
     */
    NONE,
    /**
     * Repeat the content on the X axis
     */
    X_AXIS,
    /**
     * Repeat the content on the Y axis
     */
    Y_AXIS,
    /**
     * Repeat the content on both axis
     */
    BOTH,
}
/**
 * Flags passed to the ‘paint’ or ‘pick’ method of #ClutterEffect.
 */
enum EffectPaintFlags {
    /**
     * The actor or one of its children
     *   has queued a redraw before this paint. This implies that the effect
     *   should call clutter_actor_continue_paint() to chain to the next
     *   effect and can not cache any results from a previous paint.
     */
    ACTOR_DIRTY,
}
/**
 * Flags for the #ClutterEvent
 */
enum EventFlags {
    /**
     * No flag set
     */
    NONE,
    /**
     * Synthetic event
     */
    FLAG_SYNTHETIC,
}
/**
 * Runtime flags indicating specific features available via Clutter window
 * system and graphics backend.
 */
enum FeatureFlags {
    /**
     * Set if NPOTS textures supported.
     */
    TEXTURE_NPOT,
    /**
     * Set if vblank syncing supported.
     */
    SYNC_TO_VBLANK,
    /**
     * Set if YUV based textures supported.
     */
    TEXTURE_YUV,
    /**
     * Set if texture pixels can be read.
     */
    TEXTURE_READ_PIXELS,
    /**
     * Set if stage size if fixed (i.e framebuffer)
     */
    STAGE_STATIC,
    /**
     * Set if stage is able to be user resized.
     */
    STAGE_USER_RESIZE,
    /**
     * Set if stage has a graphical cursor.
     */
    STAGE_CURSOR,
    /**
     * Set if the backend supports GLSL shaders.
     */
    SHADERS_GLSL,
    /**
     * Set if the backend supports offscreen rendering.
     */
    OFFSCREEN,
    /**
     * Set if multiple stages are supported.
     */
    STAGE_MULTIPLE,
    /**
     * Set if the GLX_INTEL_swap_event is supported.
     */
    SWAP_EVENTS,
}
/**
 * Runtime flags to change the font quality. To be used with
 * clutter_set_font_flags().
 */
enum FontFlags {
    /**
     * Set to use mipmaps for the glyph cache textures.
     */
    MIPMAPPING,
    /**
     * Set to enable hinting on the glyphs.
     */
    HINTING,
}
/**
 * Masks applied to a #ClutterEvent by modifiers.
 * 
 * Note that Clutter may add internal values to events which include
 * reserved values such as %CLUTTER_MODIFIER_RESERVED_13_MASK.  Your code
 * should preserve and ignore them.  You can use %CLUTTER_MODIFIER_MASK to
 * remove all reserved values.
 */
enum ModifierType {
    /**
     * Mask applied by the Shift key
     */
    SHIFT_MASK,
    /**
     * Mask applied by the Caps Lock key
     */
    LOCK_MASK,
    /**
     * Mask applied by the Control key
     */
    CONTROL_MASK,
    /**
     * Mask applied by the first Mod key
     */
    MOD1_MASK,
    /**
     * Mask applied by the second Mod key
     */
    MOD2_MASK,
    /**
     * Mask applied by the third Mod key
     */
    MOD3_MASK,
    /**
     * Mask applied by the fourth Mod key
     */
    MOD4_MASK,
    /**
     * Mask applied by the fifth Mod key
     */
    MOD5_MASK,
    /**
     * Mask applied by the first pointer button
     */
    BUTTON1_MASK,
    /**
     * Mask applied by the second pointer button
     */
    BUTTON2_MASK,
    /**
     * Mask applied by the third pointer button
     */
    BUTTON3_MASK,
    /**
     * Mask applied by the fourth pointer button
     */
    BUTTON4_MASK,
    /**
     * Mask applied by the fifth pointer button
     */
    BUTTON5_MASK,
    MODIFIER_RESERVED_13_MASK,
    MODIFIER_RESERVED_14_MASK,
    MODIFIER_RESERVED_15_MASK,
    MODIFIER_RESERVED_16_MASK,
    MODIFIER_RESERVED_17_MASK,
    MODIFIER_RESERVED_18_MASK,
    MODIFIER_RESERVED_19_MASK,
    MODIFIER_RESERVED_20_MASK,
    MODIFIER_RESERVED_21_MASK,
    MODIFIER_RESERVED_22_MASK,
    MODIFIER_RESERVED_23_MASK,
    MODIFIER_RESERVED_24_MASK,
    MODIFIER_RESERVED_25_MASK,
    /**
     * Mask applied by the Super key
     */
    SUPER_MASK,
    /**
     * Mask applied by the Hyper key
     */
    HYPER_MASK,
    /**
     * Mask applied by the Meta key
     */
    META_MASK,
    MODIFIER_RESERVED_29_MASK,
    /**
     * Mask applied during release
     */
    RELEASE_MASK,
    /**
     * A mask covering all modifier types
     */
    MODIFIER_MASK,
}
/**
 * Possible flags to pass to clutter_actor_set_offscreen_redirect().
 */
enum OffscreenRedirect {
    /**
     * Only redirect
     *   the actor if it is semi-transparent and its has_overlaps()
     *   virtual returns %TRUE. This is the default.
     */
    AUTOMATIC_FOR_OPACITY,
    /**
     * Always redirect the actor to an
     *   offscreen buffer even if it is fully opaque.
     */
    ALWAYS,
}
/**
 * Flags to pass to clutter_threads_add_repaint_func_full().
 */
enum RepaintFlags {
    /**
     * Run the repaint function prior to
     *   painting the stages
     */
    PRE_PAINT,
    /**
     * Run the repaint function after
     *   painting the stages
     */
    POST_PAINT,
    /**
     * Ensure that a new frame
     *   is queued after adding the repaint function
     */
    QUEUE_REDRAW_ON_ADD,
}
/**
 * Flags used to notify the axes that were stopped in a #ClutterScrollEvent.
 * These can be used to trigger post-scroll effects like kinetic scrolling.
 */
enum ScrollFinishFlags {
    /**
     * no axis was stopped.
     */
    NONE,
    /**
     * The horizontal axis stopped.
     */
    HORIZONTAL,
    /**
     * The vertical axis stopped.
     */
    VERTICAL,
}
/**
 * Scroll modes.
 */
enum ScrollMode {
    /**
     * Ignore scrolling
     */
    NONE,
    /**
     * Scroll only horizontally
     */
    HORIZONTALLY,
    /**
     * Scroll only vertically
     */
    VERTICALLY,
    /**
     * Scroll in both directions
     */
    BOTH,
}
/**
 * Stage state masks, used by the #ClutterEvent of type %CLUTTER_STAGE_STATE.
 */
enum StageState {
    /**
     * Fullscreen mask
     */
    FULLSCREEN,
    /**
     * Offscreen mask (deprecated)
     */
    OFFSCREEN,
    /**
     * Activated mask
     */
    ACTIVATED,
}
/**
 * The main direction of the swipe gesture
 */
enum SwipeDirection {
    /**
     * Upwards swipe gesture
     */
    UP,
    /**
     * Downwards swipe gesture
     */
    DOWN,
    /**
     * Leftwards swipe gesture
     */
    LEFT,
    /**
     * Rightwards swipe gesture
     */
    RIGHT,
}
/**
 * Flags for clutter_texture_set_from_rgb_data() and
 * clutter_texture_set_from_yuv_data().
 */
enum TextureFlags {
    /**
     * No flags
     */
    NONE,
    /**
     * Unused flag
     */
    RGB_FLAG_BGR,
    /**
     * Unused flag
     */
    RGB_FLAG_PREMULT,
    /**
     * Unused flag
     */
    YUV_FLAG_YUV2,
}
const TODO_0: number
const TODO_1: number
const TODO_2: number
const TODO_3: number
const TODO_3270_AltCursor: number
const TODO_3270_Attn: number
const TODO_3270_BackTab: number
const TODO_3270_ChangeScreen: number
const TODO_3270_Copy: number
const TODO_3270_CursorBlink: number
const TODO_3270_CursorSelect: number
const TODO_3270_DeleteWord: number
const TODO_3270_Duplicate: number
const TODO_3270_Enter: number
const TODO_3270_EraseEOF: number
const TODO_3270_EraseInput: number
const TODO_3270_ExSelect: number
const TODO_3270_FieldMark: number
const TODO_3270_Ident: number
const TODO_3270_Jump: number
const TODO_3270_KeyClick: number
const TODO_3270_Left2: number
const TODO_3270_PA1: number
const TODO_3270_PA2: number
const TODO_3270_PA3: number
const TODO_3270_Play: number
const TODO_3270_PrintScreen: number
const TODO_3270_Quit: number
const TODO_3270_Record: number
const TODO_3270_Reset: number
const TODO_3270_Right2: number
const TODO_3270_Rule: number
const TODO_3270_Setup: number
const TODO_3270_Test: number
const TODO_4: number
const TODO_5: number
const TODO_6: number
const TODO_7: number
const TODO_8: number
const TODO_9: number
const A: number
const AE: number
const Aacute: number
const Abelowdot: number
const Abreve: number
const Abreveacute: number
const Abrevebelowdot: number
const Abrevegrave: number
const Abrevehook: number
const Abrevetilde: number
const AccessX_Enable: number
const AccessX_Feedback_Enable: number
const Acircumflex: number
const Acircumflexacute: number
const Acircumflexbelowdot: number
const Acircumflexgrave: number
const Acircumflexhook: number
const Acircumflextilde: number
const AddFavorite: number
const Adiaeresis: number
const Agrave: number
const Ahook: number
const Alt_L: number
const Alt_R: number
const Amacron: number
const Aogonek: number
const ApplicationLeft: number
const ApplicationRight: number
const Arabic_0: number
const Arabic_1: number
const Arabic_2: number
const Arabic_3: number
const Arabic_4: number
const Arabic_5: number
const Arabic_6: number
const Arabic_7: number
const Arabic_8: number
const Arabic_9: number
const Arabic_ain: number
const Arabic_alef: number
const Arabic_alefmaksura: number
const Arabic_beh: number
const Arabic_comma: number
const Arabic_dad: number
const Arabic_dal: number
const Arabic_damma: number
const Arabic_dammatan: number
const Arabic_ddal: number
const Arabic_farsi_yeh: number
const Arabic_fatha: number
const Arabic_fathatan: number
const Arabic_feh: number
const Arabic_fullstop: number
const Arabic_gaf: number
const Arabic_ghain: number
const Arabic_ha: number
const Arabic_hah: number
const Arabic_hamza: number
const Arabic_hamza_above: number
const Arabic_hamza_below: number
const Arabic_hamzaonalef: number
const Arabic_hamzaonwaw: number
const Arabic_hamzaonyeh: number
const Arabic_hamzaunderalef: number
const Arabic_heh: number
const Arabic_heh_doachashmee: number
const Arabic_heh_goal: number
const Arabic_jeem: number
const Arabic_jeh: number
const Arabic_kaf: number
const Arabic_kasra: number
const Arabic_kasratan: number
const Arabic_keheh: number
const Arabic_khah: number
const Arabic_lam: number
const Arabic_madda_above: number
const Arabic_maddaonalef: number
const Arabic_meem: number
const Arabic_noon: number
const Arabic_noon_ghunna: number
const Arabic_peh: number
const Arabic_percent: number
const Arabic_qaf: number
const Arabic_question_mark: number
const Arabic_ra: number
const Arabic_rreh: number
const Arabic_sad: number
const Arabic_seen: number
const Arabic_semicolon: number
const Arabic_shadda: number
const Arabic_sheen: number
const Arabic_sukun: number
const Arabic_superscript_alef: number
const Arabic_switch: number
const Arabic_tah: number
const Arabic_tatweel: number
const Arabic_tcheh: number
const Arabic_teh: number
const Arabic_tehmarbuta: number
const Arabic_thal: number
const Arabic_theh: number
const Arabic_tteh: number
const Arabic_veh: number
const Arabic_waw: number
const Arabic_yeh: number
const Arabic_yeh_baree: number
const Arabic_zah: number
const Arabic_zain: number
const Aring: number
const Armenian_AT: number
const Armenian_AYB: number
const Armenian_BEN: number
const Armenian_CHA: number
const Armenian_DA: number
const Armenian_DZA: number
const Armenian_E: number
const Armenian_FE: number
const Armenian_GHAT: number
const Armenian_GIM: number
const Armenian_HI: number
const Armenian_HO: number
const Armenian_INI: number
const Armenian_JE: number
const Armenian_KE: number
const Armenian_KEN: number
const Armenian_KHE: number
const Armenian_LYUN: number
const Armenian_MEN: number
const Armenian_NU: number
const Armenian_O: number
const Armenian_PE: number
const Armenian_PYUR: number
const Armenian_RA: number
const Armenian_RE: number
const Armenian_SE: number
const Armenian_SHA: number
const Armenian_TCHE: number
const Armenian_TO: number
const Armenian_TSA: number
const Armenian_TSO: number
const Armenian_TYUN: number
const Armenian_VEV: number
const Armenian_VO: number
const Armenian_VYUN: number
const Armenian_YECH: number
const Armenian_ZA: number
const Armenian_ZHE: number
const Armenian_accent: number
const Armenian_amanak: number
const Armenian_apostrophe: number
const Armenian_at: number
const Armenian_ayb: number
const Armenian_ben: number
const Armenian_but: number
const Armenian_cha: number
const Armenian_da: number
const Armenian_dza: number
const Armenian_e: number
const Armenian_exclam: number
const Armenian_fe: number
const Armenian_full_stop: number
const Armenian_ghat: number
const Armenian_gim: number
const Armenian_hi: number
const Armenian_ho: number
const Armenian_hyphen: number
const Armenian_ini: number
const Armenian_je: number
const Armenian_ke: number
const Armenian_ken: number
const Armenian_khe: number
const Armenian_ligature_ew: number
const Armenian_lyun: number
const Armenian_men: number
const Armenian_nu: number
const Armenian_o: number
const Armenian_paruyk: number
const Armenian_pe: number
const Armenian_pyur: number
const Armenian_question: number
const Armenian_ra: number
const Armenian_re: number
const Armenian_se: number
const Armenian_separation_mark: number
const Armenian_sha: number
const Armenian_shesht: number
const Armenian_tche: number
const Armenian_to: number
const Armenian_tsa: number
const Armenian_tso: number
const Armenian_tyun: number
const Armenian_verjaket: number
const Armenian_vev: number
const Armenian_vo: number
const Armenian_vyun: number
const Armenian_yech: number
const Armenian_yentamna: number
const Armenian_za: number
const Armenian_zhe: number
const Atilde: number
const AudibleBell_Enable: number
const AudioCycleTrack: number
const AudioForward: number
const AudioLowerVolume: number
const AudioMedia: number
const AudioMicMute: number
const AudioMute: number
const AudioNext: number
const AudioPause: number
const AudioPlay: number
const AudioPrev: number
const AudioRaiseVolume: number
const AudioRandomPlay: number
const AudioRecord: number
const AudioRepeat: number
const AudioRewind: number
const AudioStop: number
const Away: number
const B: number
/**
 * The middle button of a pointer device.
 */
const BUTTON_MIDDLE: number
/**
 * The primary button of a pointer device.
 * 
 * This is typically the left mouse button in a right-handed
 * mouse configuration.
 */
const BUTTON_PRIMARY: number
/**
 * The secondary button of a pointer device.
 * 
 * This is typically the right mouse button in a right-handed
 * mouse configuration.
 */
const BUTTON_SECONDARY: number
const Babovedot: number
const Back: number
const BackForward: number
const BackSpace: number
const Battery: number
const Begin: number
const Blue: number
const Bluetooth: number
const Book: number
const BounceKeys_Enable: number
const Break: number
const BrightnessAdjust: number
const Byelorussian_SHORTU: number
const Byelorussian_shortu: number
const C: number
const CD: number
const CH: number
/**
 * Cogl (internal GL abstraction utility library) backend. Can be "gl" or
 * "gles" currently
 */
const COGL: string
/**
 * Default value for "now".
 */
const CURRENT_TIME: number
const C_H: number
const C_h: number
const Cabovedot: number
const Cacute: number
const Calculator: number
const Calendar: number
const Cancel: number
const Caps_Lock: number
const Ccaron: number
const Ccedilla: number
const Ccircumflex: number
const Ch: number
const Clear: number
const ClearGrab: number
const Close: number
const Codeinput: number
const ColonSign: number
const Community: number
const ContrastAdjust: number
const Control_L: number
const Control_R: number
const Copy: number
const CruzeiroSign: number
const Cut: number
const CycleAngle: number
const Cyrillic_A: number
const Cyrillic_BE: number
const Cyrillic_CHE: number
const Cyrillic_CHE_descender: number
const Cyrillic_CHE_vertstroke: number
const Cyrillic_DE: number
const Cyrillic_DZHE: number
const Cyrillic_E: number
const Cyrillic_EF: number
const Cyrillic_EL: number
const Cyrillic_EM: number
const Cyrillic_EN: number
const Cyrillic_EN_descender: number
const Cyrillic_ER: number
const Cyrillic_ES: number
const Cyrillic_GHE: number
const Cyrillic_GHE_bar: number
const Cyrillic_HA: number
const Cyrillic_HARDSIGN: number
const Cyrillic_HA_descender: number
const Cyrillic_I: number
const Cyrillic_IE: number
const Cyrillic_IO: number
const Cyrillic_I_macron: number
const Cyrillic_JE: number
const Cyrillic_KA: number
const Cyrillic_KA_descender: number
const Cyrillic_KA_vertstroke: number
const Cyrillic_LJE: number
const Cyrillic_NJE: number
const Cyrillic_O: number
const Cyrillic_O_bar: number
const Cyrillic_PE: number
const Cyrillic_SCHWA: number
const Cyrillic_SHA: number
const Cyrillic_SHCHA: number
const Cyrillic_SHHA: number
const Cyrillic_SHORTI: number
const Cyrillic_SOFTSIGN: number
const Cyrillic_TE: number
const Cyrillic_TSE: number
const Cyrillic_U: number
const Cyrillic_U_macron: number
const Cyrillic_U_straight: number
const Cyrillic_U_straight_bar: number
const Cyrillic_VE: number
const Cyrillic_YA: number
const Cyrillic_YERU: number
const Cyrillic_YU: number
const Cyrillic_ZE: number
const Cyrillic_ZHE: number
const Cyrillic_ZHE_descender: number
const Cyrillic_a: number
const Cyrillic_be: number
const Cyrillic_che: number
const Cyrillic_che_descender: number
const Cyrillic_che_vertstroke: number
const Cyrillic_de: number
const Cyrillic_dzhe: number
const Cyrillic_e: number
const Cyrillic_ef: number
const Cyrillic_el: number
const Cyrillic_em: number
const Cyrillic_en: number
const Cyrillic_en_descender: number
const Cyrillic_er: number
const Cyrillic_es: number
const Cyrillic_ghe: number
const Cyrillic_ghe_bar: number
const Cyrillic_ha: number
const Cyrillic_ha_descender: number
const Cyrillic_hardsign: number
const Cyrillic_i: number
const Cyrillic_i_macron: number
const Cyrillic_ie: number
const Cyrillic_io: number
const Cyrillic_je: number
const Cyrillic_ka: number
const Cyrillic_ka_descender: number
const Cyrillic_ka_vertstroke: number
const Cyrillic_lje: number
const Cyrillic_nje: number
const Cyrillic_o: number
const Cyrillic_o_bar: number
const Cyrillic_pe: number
const Cyrillic_schwa: number
const Cyrillic_sha: number
const Cyrillic_shcha: number
const Cyrillic_shha: number
const Cyrillic_shorti: number
const Cyrillic_softsign: number
const Cyrillic_te: number
const Cyrillic_tse: number
const Cyrillic_u: number
const Cyrillic_u_macron: number
const Cyrillic_u_straight: number
const Cyrillic_u_straight_bar: number
const Cyrillic_ve: number
const Cyrillic_ya: number
const Cyrillic_yeru: number
const Cyrillic_yu: number
const Cyrillic_ze: number
const Cyrillic_zhe: number
const Cyrillic_zhe_descender: number
const D: number
const DOS: number
const Dabovedot: number
const Dcaron: number
const Delete: number
const Display: number
const Documents: number
const DongSign: number
const Down: number
const Dstroke: number
const E: number
const ENG: number
const ETH: number
/**
 * Continues the propagation of an event; this macro should be
 * used in event-related signals.
 */
const EVENT_PROPAGATE: boolean
/**
 * Stops the propagation of an event; this macro should be used
 * in event-related signals.
 */
const EVENT_STOP: boolean
const EZH: number
const Eabovedot: number
const Eacute: number
const Ebelowdot: number
const Ecaron: number
const Ecircumflex: number
const Ecircumflexacute: number
const Ecircumflexbelowdot: number
const Ecircumflexgrave: number
const Ecircumflexhook: number
const Ecircumflextilde: number
const EcuSign: number
const Ediaeresis: number
const Egrave: number
const Ehook: number
const Eisu_Shift: number
const Eisu_toggle: number
const Eject: number
const Emacron: number
const End: number
const Eogonek: number
const Escape: number
const Eth: number
const Etilde: number
const EuroSign: number
const Excel: number
const Execute: number
const Explorer: number
const F: number
const F1: number
const F10: number
const F11: number
const F12: number
const F13: number
const F14: number
const F15: number
const F16: number
const F17: number
const F18: number
const F19: number
const F2: number
const F20: number
const F21: number
const F22: number
const F23: number
const F24: number
const F25: number
const F26: number
const F27: number
const F28: number
const F29: number
const F3: number
const F30: number
const F31: number
const F32: number
const F33: number
const F34: number
const F35: number
const F4: number
const F5: number
const F6: number
const F7: number
const F8: number
const F9: number
const FFrancSign: number
/**
 * GL Windowing system used
 */
const FLAVOUR: string
const Fabovedot: number
const Farsi_0: number
const Farsi_1: number
const Farsi_2: number
const Farsi_3: number
const Farsi_4: number
const Farsi_5: number
const Farsi_6: number
const Farsi_7: number
const Farsi_8: number
const Farsi_9: number
const Farsi_yeh: number
const Favorites: number
const Finance: number
const Find: number
const First_Virtual_Screen: number
const Forward: number
const FrameBack: number
const FrameForward: number
const G: number
const Gabovedot: number
const Game: number
const Gbreve: number
const Gcaron: number
const Gcedilla: number
const Gcircumflex: number
const Georgian_an: number
const Georgian_ban: number
const Georgian_can: number
const Georgian_char: number
const Georgian_chin: number
const Georgian_cil: number
const Georgian_don: number
const Georgian_en: number
const Georgian_fi: number
const Georgian_gan: number
const Georgian_ghan: number
const Georgian_hae: number
const Georgian_har: number
const Georgian_he: number
const Georgian_hie: number
const Georgian_hoe: number
const Georgian_in: number
const Georgian_jhan: number
const Georgian_jil: number
const Georgian_kan: number
const Georgian_khar: number
const Georgian_las: number
const Georgian_man: number
const Georgian_nar: number
const Georgian_on: number
const Georgian_par: number
const Georgian_phar: number
const Georgian_qar: number
const Georgian_rae: number
const Georgian_san: number
const Georgian_shin: number
const Georgian_tan: number
const Georgian_tar: number
const Georgian_un: number
const Georgian_vin: number
const Georgian_we: number
const Georgian_xan: number
const Georgian_zen: number
const Georgian_zhar: number
const Go: number
const Greek_ALPHA: number
const Greek_ALPHAaccent: number
const Greek_BETA: number
const Greek_CHI: number
const Greek_DELTA: number
const Greek_EPSILON: number
const Greek_EPSILONaccent: number
const Greek_ETA: number
const Greek_ETAaccent: number
const Greek_GAMMA: number
const Greek_IOTA: number
const Greek_IOTAaccent: number
const Greek_IOTAdiaeresis: number
const Greek_IOTAdieresis: number
const Greek_KAPPA: number
const Greek_LAMBDA: number
const Greek_LAMDA: number
const Greek_MU: number
const Greek_NU: number
const Greek_OMEGA: number
const Greek_OMEGAaccent: number
const Greek_OMICRON: number
const Greek_OMICRONaccent: number
const Greek_PHI: number
const Greek_PI: number
const Greek_PSI: number
const Greek_RHO: number
const Greek_SIGMA: number
const Greek_TAU: number
const Greek_THETA: number
const Greek_UPSILON: number
const Greek_UPSILONaccent: number
const Greek_UPSILONdieresis: number
const Greek_XI: number
const Greek_ZETA: number
const Greek_accentdieresis: number
const Greek_alpha: number
const Greek_alphaaccent: number
const Greek_beta: number
const Greek_chi: number
const Greek_delta: number
const Greek_epsilon: number
const Greek_epsilonaccent: number
const Greek_eta: number
const Greek_etaaccent: number
const Greek_finalsmallsigma: number
const Greek_gamma: number
const Greek_horizbar: number
const Greek_iota: number
const Greek_iotaaccent: number
const Greek_iotaaccentdieresis: number
const Greek_iotadieresis: number
const Greek_kappa: number
const Greek_lambda: number
const Greek_lamda: number
const Greek_mu: number
const Greek_nu: number
const Greek_omega: number
const Greek_omegaaccent: number
const Greek_omicron: number
const Greek_omicronaccent: number
const Greek_phi: number
const Greek_pi: number
const Greek_psi: number
const Greek_rho: number
const Greek_sigma: number
const Greek_switch: number
const Greek_tau: number
const Greek_theta: number
const Greek_upsilon: number
const Greek_upsilonaccent: number
const Greek_upsilonaccentdieresis: number
const Greek_upsilondieresis: number
const Greek_xi: number
const Greek_zeta: number
const Green: number
const H: number
const HAS_WAYLAND_COMPOSITOR_SUPPORT: number
const Hangul: number
const Hangul_A: number
const Hangul_AE: number
const Hangul_AraeA: number
const Hangul_AraeAE: number
const Hangul_Banja: number
const Hangul_Cieuc: number
const Hangul_Codeinput: number
const Hangul_Dikeud: number
const Hangul_E: number
const Hangul_EO: number
const Hangul_EU: number
const Hangul_End: number
const Hangul_Hanja: number
const Hangul_Hieuh: number
const Hangul_I: number
const Hangul_Ieung: number
const Hangul_J_Cieuc: number
const Hangul_J_Dikeud: number
const Hangul_J_Hieuh: number
const Hangul_J_Ieung: number
const Hangul_J_Jieuj: number
const Hangul_J_Khieuq: number
const Hangul_J_Kiyeog: number
const Hangul_J_KiyeogSios: number
const Hangul_J_KkogjiDalrinIeung: number
const Hangul_J_Mieum: number
const Hangul_J_Nieun: number
const Hangul_J_NieunHieuh: number
const Hangul_J_NieunJieuj: number
const Hangul_J_PanSios: number
const Hangul_J_Phieuf: number
const Hangul_J_Pieub: number
const Hangul_J_PieubSios: number
const Hangul_J_Rieul: number
const Hangul_J_RieulHieuh: number
const Hangul_J_RieulKiyeog: number
const Hangul_J_RieulMieum: number
const Hangul_J_RieulPhieuf: number
const Hangul_J_RieulPieub: number
const Hangul_J_RieulSios: number
const Hangul_J_RieulTieut: number
const Hangul_J_Sios: number
const Hangul_J_SsangKiyeog: number
const Hangul_J_SsangSios: number
const Hangul_J_Tieut: number
const Hangul_J_YeorinHieuh: number
const Hangul_Jamo: number
const Hangul_Jeonja: number
const Hangul_Jieuj: number
const Hangul_Khieuq: number
const Hangul_Kiyeog: number
const Hangul_KiyeogSios: number
const Hangul_KkogjiDalrinIeung: number
const Hangul_Mieum: number
const Hangul_MultipleCandidate: number
const Hangul_Nieun: number
const Hangul_NieunHieuh: number
const Hangul_NieunJieuj: number
const Hangul_O: number
const Hangul_OE: number
const Hangul_PanSios: number
const Hangul_Phieuf: number
const Hangul_Pieub: number
const Hangul_PieubSios: number
const Hangul_PostHanja: number
const Hangul_PreHanja: number
const Hangul_PreviousCandidate: number
const Hangul_Rieul: number
const Hangul_RieulHieuh: number
const Hangul_RieulKiyeog: number
const Hangul_RieulMieum: number
const Hangul_RieulPhieuf: number
const Hangul_RieulPieub: number
const Hangul_RieulSios: number
const Hangul_RieulTieut: number
const Hangul_RieulYeorinHieuh: number
const Hangul_Romaja: number
const Hangul_SingleCandidate: number
const Hangul_Sios: number
const Hangul_Special: number
const Hangul_SsangDikeud: number
const Hangul_SsangJieuj: number
const Hangul_SsangKiyeog: number
const Hangul_SsangPieub: number
const Hangul_SsangSios: number
const Hangul_Start: number
const Hangul_SunkyeongeumMieum: number
const Hangul_SunkyeongeumPhieuf: number
const Hangul_SunkyeongeumPieub: number
const Hangul_Tieut: number
const Hangul_U: number
const Hangul_WA: number
const Hangul_WAE: number
const Hangul_WE: number
const Hangul_WEO: number
const Hangul_WI: number
const Hangul_YA: number
const Hangul_YAE: number
const Hangul_YE: number
const Hangul_YEO: number
const Hangul_YI: number
const Hangul_YO: number
const Hangul_YU: number
const Hangul_YeorinHieuh: number
const Hangul_switch: number
const Hankaku: number
const Hcircumflex: number
const Hebrew_switch: number
const Help: number
const Henkan: number
const Henkan_Mode: number
const Hibernate: number
const Hiragana: number
const Hiragana_Katakana: number
const History: number
const Home: number
const HomePage: number
const HotLinks: number
const Hstroke: number
const Hyper_L: number
const Hyper_R: number
const I: number
const INPUT_EVDEV: string
const INPUT_GDK: string
const INPUT_NULL: string
const INPUT_WAYLAND: string
const INPUT_X11: string
const ISO_Center_Object: number
const ISO_Continuous_Underline: number
const ISO_Discontinuous_Underline: number
const ISO_Emphasize: number
const ISO_Enter: number
const ISO_Fast_Cursor_Down: number
const ISO_Fast_Cursor_Left: number
const ISO_Fast_Cursor_Right: number
const ISO_Fast_Cursor_Up: number
const ISO_First_Group: number
const ISO_First_Group_Lock: number
const ISO_Group_Latch: number
const ISO_Group_Lock: number
const ISO_Group_Shift: number
const ISO_Last_Group: number
const ISO_Last_Group_Lock: number
const ISO_Left_Tab: number
const ISO_Level2_Latch: number
const ISO_Level3_Latch: number
const ISO_Level3_Lock: number
const ISO_Level3_Shift: number
const ISO_Level5_Latch: number
const ISO_Level5_Lock: number
const ISO_Level5_Shift: number
const ISO_Lock: number
const ISO_Move_Line_Down: number
const ISO_Move_Line_Up: number
const ISO_Next_Group: number
const ISO_Next_Group_Lock: number
const ISO_Partial_Line_Down: number
const ISO_Partial_Line_Up: number
const ISO_Partial_Space_Left: number
const ISO_Partial_Space_Right: number
const ISO_Prev_Group: number
const ISO_Prev_Group_Lock: number
const ISO_Release_Both_Margins: number
const ISO_Release_Margin_Left: number
const ISO_Release_Margin_Right: number
const ISO_Set_Margin_Left: number
const ISO_Set_Margin_Right: number
const Iabovedot: number
const Iacute: number
const Ibelowdot: number
const Ibreve: number
const Icircumflex: number
const Idiaeresis: number
const Igrave: number
const Ihook: number
const Imacron: number
const Insert: number
const Iogonek: number
const Itilde: number
const J: number
const Jcircumflex: number
const K: number
const KEY_0: number
const KEY_1: number
const KEY_2: number
const KEY_3: number
const KEY_3270_AltCursor: number
const KEY_3270_Attn: number
const KEY_3270_BackTab: number
const KEY_3270_ChangeScreen: number
const KEY_3270_Copy: number
const KEY_3270_CursorBlink: number
const KEY_3270_CursorSelect: number
const KEY_3270_DeleteWord: number
const KEY_3270_Duplicate: number
const KEY_3270_Enter: number
const KEY_3270_EraseEOF: number
const KEY_3270_EraseInput: number
const KEY_3270_ExSelect: number
const KEY_3270_FieldMark: number
const KEY_3270_Ident: number
const KEY_3270_Jump: number
const KEY_3270_KeyClick: number
const KEY_3270_Left2: number
const KEY_3270_PA1: number
const KEY_3270_PA2: number
const KEY_3270_PA3: number
const KEY_3270_Play: number
const KEY_3270_PrintScreen: number
const KEY_3270_Quit: number
const KEY_3270_Record: number
const KEY_3270_Reset: number
const KEY_3270_Right2: number
const KEY_3270_Rule: number
const KEY_3270_Setup: number
const KEY_3270_Test: number
const KEY_4: number
const KEY_5: number
const KEY_6: number
const KEY_7: number
const KEY_8: number
const KEY_9: number
const KEY_A: number
const KEY_AE: number
const KEY_Aacute: number
const KEY_Abelowdot: number
const KEY_Abreve: number
const KEY_Abreveacute: number
const KEY_Abrevebelowdot: number
const KEY_Abrevegrave: number
const KEY_Abrevehook: number
const KEY_Abrevetilde: number
const KEY_AccessX_Enable: number
const KEY_AccessX_Feedback_Enable: number
const KEY_Acircumflex: number
const KEY_Acircumflexacute: number
const KEY_Acircumflexbelowdot: number
const KEY_Acircumflexgrave: number
const KEY_Acircumflexhook: number
const KEY_Acircumflextilde: number
const KEY_AddFavorite: number
const KEY_Adiaeresis: number
const KEY_Agrave: number
const KEY_Ahook: number
const KEY_Alt_L: number
const KEY_Alt_R: number
const KEY_Amacron: number
const KEY_Aogonek: number
const KEY_ApplicationLeft: number
const KEY_ApplicationRight: number
const KEY_Arabic_0: number
const KEY_Arabic_1: number
const KEY_Arabic_2: number
const KEY_Arabic_3: number
const KEY_Arabic_4: number
const KEY_Arabic_5: number
const KEY_Arabic_6: number
const KEY_Arabic_7: number
const KEY_Arabic_8: number
const KEY_Arabic_9: number
const KEY_Arabic_ain: number
const KEY_Arabic_alef: number
const KEY_Arabic_alefmaksura: number
const KEY_Arabic_beh: number
const KEY_Arabic_comma: number
const KEY_Arabic_dad: number
const KEY_Arabic_dal: number
const KEY_Arabic_damma: number
const KEY_Arabic_dammatan: number
const KEY_Arabic_ddal: number
const KEY_Arabic_farsi_yeh: number
const KEY_Arabic_fatha: number
const KEY_Arabic_fathatan: number
const KEY_Arabic_feh: number
const KEY_Arabic_fullstop: number
const KEY_Arabic_gaf: number
const KEY_Arabic_ghain: number
const KEY_Arabic_ha: number
const KEY_Arabic_hah: number
const KEY_Arabic_hamza: number
const KEY_Arabic_hamza_above: number
const KEY_Arabic_hamza_below: number
const KEY_Arabic_hamzaonalef: number
const KEY_Arabic_hamzaonwaw: number
const KEY_Arabic_hamzaonyeh: number
const KEY_Arabic_hamzaunderalef: number
const KEY_Arabic_heh: number
const KEY_Arabic_heh_doachashmee: number
const KEY_Arabic_heh_goal: number
const KEY_Arabic_jeem: number
const KEY_Arabic_jeh: number
const KEY_Arabic_kaf: number
const KEY_Arabic_kasra: number
const KEY_Arabic_kasratan: number
const KEY_Arabic_keheh: number
const KEY_Arabic_khah: number
const KEY_Arabic_lam: number
const KEY_Arabic_madda_above: number
const KEY_Arabic_maddaonalef: number
const KEY_Arabic_meem: number
const KEY_Arabic_noon: number
const KEY_Arabic_noon_ghunna: number
const KEY_Arabic_peh: number
const KEY_Arabic_percent: number
const KEY_Arabic_qaf: number
const KEY_Arabic_question_mark: number
const KEY_Arabic_ra: number
const KEY_Arabic_rreh: number
const KEY_Arabic_sad: number
const KEY_Arabic_seen: number
const KEY_Arabic_semicolon: number
const KEY_Arabic_shadda: number
const KEY_Arabic_sheen: number
const KEY_Arabic_sukun: number
const KEY_Arabic_superscript_alef: number
const KEY_Arabic_switch: number
const KEY_Arabic_tah: number
const KEY_Arabic_tatweel: number
const KEY_Arabic_tcheh: number
const KEY_Arabic_teh: number
const KEY_Arabic_tehmarbuta: number
const KEY_Arabic_thal: number
const KEY_Arabic_theh: number
const KEY_Arabic_tteh: number
const KEY_Arabic_veh: number
const KEY_Arabic_waw: number
const KEY_Arabic_yeh: number
const KEY_Arabic_yeh_baree: number
const KEY_Arabic_zah: number
const KEY_Arabic_zain: number
const KEY_Aring: number
const KEY_Armenian_AT: number
const KEY_Armenian_AYB: number
const KEY_Armenian_BEN: number
const KEY_Armenian_CHA: number
const KEY_Armenian_DA: number
const KEY_Armenian_DZA: number
const KEY_Armenian_E: number
const KEY_Armenian_FE: number
const KEY_Armenian_GHAT: number
const KEY_Armenian_GIM: number
const KEY_Armenian_HI: number
const KEY_Armenian_HO: number
const KEY_Armenian_INI: number
const KEY_Armenian_JE: number
const KEY_Armenian_KE: number
const KEY_Armenian_KEN: number
const KEY_Armenian_KHE: number
const KEY_Armenian_LYUN: number
const KEY_Armenian_MEN: number
const KEY_Armenian_NU: number
const KEY_Armenian_O: number
const KEY_Armenian_PE: number
const KEY_Armenian_PYUR: number
const KEY_Armenian_RA: number
const KEY_Armenian_RE: number
const KEY_Armenian_SE: number
const KEY_Armenian_SHA: number
const KEY_Armenian_TCHE: number
const KEY_Armenian_TO: number
const KEY_Armenian_TSA: number
const KEY_Armenian_TSO: number
const KEY_Armenian_TYUN: number
const KEY_Armenian_VEV: number
const KEY_Armenian_VO: number
const KEY_Armenian_VYUN: number
const KEY_Armenian_YECH: number
const KEY_Armenian_ZA: number
const KEY_Armenian_ZHE: number
const KEY_Armenian_accent: number
const KEY_Armenian_amanak: number
const KEY_Armenian_apostrophe: number
const KEY_Armenian_at: number
const KEY_Armenian_ayb: number
const KEY_Armenian_ben: number
const KEY_Armenian_but: number
const KEY_Armenian_cha: number
const KEY_Armenian_da: number
const KEY_Armenian_dza: number
const KEY_Armenian_e: number
const KEY_Armenian_exclam: number
const KEY_Armenian_fe: number
const KEY_Armenian_full_stop: number
const KEY_Armenian_ghat: number
const KEY_Armenian_gim: number
const KEY_Armenian_hi: number
const KEY_Armenian_ho: number
const KEY_Armenian_hyphen: number
const KEY_Armenian_ini: number
const KEY_Armenian_je: number
const KEY_Armenian_ke: number
const KEY_Armenian_ken: number
const KEY_Armenian_khe: number
const KEY_Armenian_ligature_ew: number
const KEY_Armenian_lyun: number
const KEY_Armenian_men: number
const KEY_Armenian_nu: number
const KEY_Armenian_o: number
const KEY_Armenian_paruyk: number
const KEY_Armenian_pe: number
const KEY_Armenian_pyur: number
const KEY_Armenian_question: number
const KEY_Armenian_ra: number
const KEY_Armenian_re: number
const KEY_Armenian_se: number
const KEY_Armenian_separation_mark: number
const KEY_Armenian_sha: number
const KEY_Armenian_shesht: number
const KEY_Armenian_tche: number
const KEY_Armenian_to: number
const KEY_Armenian_tsa: number
const KEY_Armenian_tso: number
const KEY_Armenian_tyun: number
const KEY_Armenian_verjaket: number
const KEY_Armenian_vev: number
const KEY_Armenian_vo: number
const KEY_Armenian_vyun: number
const KEY_Armenian_yech: number
const KEY_Armenian_yentamna: number
const KEY_Armenian_za: number
const KEY_Armenian_zhe: number
const KEY_Atilde: number
const KEY_AudibleBell_Enable: number
const KEY_AudioCycleTrack: number
const KEY_AudioForward: number
const KEY_AudioLowerVolume: number
const KEY_AudioMedia: number
const KEY_AudioMicMute: number
const KEY_AudioMute: number
const KEY_AudioNext: number
const KEY_AudioPause: number
const KEY_AudioPlay: number
const KEY_AudioPrev: number
const KEY_AudioRaiseVolume: number
const KEY_AudioRandomPlay: number
const KEY_AudioRecord: number
const KEY_AudioRepeat: number
const KEY_AudioRewind: number
const KEY_AudioStop: number
const KEY_Away: number
const KEY_B: number
const KEY_Babovedot: number
const KEY_Back: number
const KEY_BackForward: number
const KEY_BackSpace: number
const KEY_Battery: number
const KEY_Begin: number
const KEY_Blue: number
const KEY_Bluetooth: number
const KEY_Book: number
const KEY_BounceKeys_Enable: number
const KEY_Break: number
const KEY_BrightnessAdjust: number
const KEY_Byelorussian_SHORTU: number
const KEY_Byelorussian_shortu: number
const KEY_C: number
const KEY_CD: number
const KEY_CH: number
const KEY_C_H: number
const KEY_C_h: number
const KEY_Cabovedot: number
const KEY_Cacute: number
const KEY_Calculator: number
const KEY_Calendar: number
const KEY_Cancel: number
const KEY_Caps_Lock: number
const KEY_Ccaron: number
const KEY_Ccedilla: number
const KEY_Ccircumflex: number
const KEY_Ch: number
const KEY_Clear: number
const KEY_ClearGrab: number
const KEY_Close: number
const KEY_Codeinput: number
const KEY_ColonSign: number
const KEY_Community: number
const KEY_ContrastAdjust: number
const KEY_Control_L: number
const KEY_Control_R: number
const KEY_Copy: number
const KEY_CruzeiroSign: number
const KEY_Cut: number
const KEY_CycleAngle: number
const KEY_Cyrillic_A: number
const KEY_Cyrillic_BE: number
const KEY_Cyrillic_CHE: number
const KEY_Cyrillic_CHE_descender: number
const KEY_Cyrillic_CHE_vertstroke: number
const KEY_Cyrillic_DE: number
const KEY_Cyrillic_DZHE: number
const KEY_Cyrillic_E: number
const KEY_Cyrillic_EF: number
const KEY_Cyrillic_EL: number
const KEY_Cyrillic_EM: number
const KEY_Cyrillic_EN: number
const KEY_Cyrillic_EN_descender: number
const KEY_Cyrillic_ER: number
const KEY_Cyrillic_ES: number
const KEY_Cyrillic_GHE: number
const KEY_Cyrillic_GHE_bar: number
const KEY_Cyrillic_HA: number
const KEY_Cyrillic_HARDSIGN: number
const KEY_Cyrillic_HA_descender: number
const KEY_Cyrillic_I: number
const KEY_Cyrillic_IE: number
const KEY_Cyrillic_IO: number
const KEY_Cyrillic_I_macron: number
const KEY_Cyrillic_JE: number
const KEY_Cyrillic_KA: number
const KEY_Cyrillic_KA_descender: number
const KEY_Cyrillic_KA_vertstroke: number
const KEY_Cyrillic_LJE: number
const KEY_Cyrillic_NJE: number
const KEY_Cyrillic_O: number
const KEY_Cyrillic_O_bar: number
const KEY_Cyrillic_PE: number
const KEY_Cyrillic_SCHWA: number
const KEY_Cyrillic_SHA: number
const KEY_Cyrillic_SHCHA: number
const KEY_Cyrillic_SHHA: number
const KEY_Cyrillic_SHORTI: number
const KEY_Cyrillic_SOFTSIGN: number
const KEY_Cyrillic_TE: number
const KEY_Cyrillic_TSE: number
const KEY_Cyrillic_U: number
const KEY_Cyrillic_U_macron: number
const KEY_Cyrillic_U_straight: number
const KEY_Cyrillic_U_straight_bar: number
const KEY_Cyrillic_VE: number
const KEY_Cyrillic_YA: number
const KEY_Cyrillic_YERU: number
const KEY_Cyrillic_YU: number
const KEY_Cyrillic_ZE: number
const KEY_Cyrillic_ZHE: number
const KEY_Cyrillic_ZHE_descender: number
const KEY_Cyrillic_a: number
const KEY_Cyrillic_be: number
const KEY_Cyrillic_che: number
const KEY_Cyrillic_che_descender: number
const KEY_Cyrillic_che_vertstroke: number
const KEY_Cyrillic_de: number
const KEY_Cyrillic_dzhe: number
const KEY_Cyrillic_e: number
const KEY_Cyrillic_ef: number
const KEY_Cyrillic_el: number
const KEY_Cyrillic_em: number
const KEY_Cyrillic_en: number
const KEY_Cyrillic_en_descender: number
const KEY_Cyrillic_er: number
const KEY_Cyrillic_es: number
const KEY_Cyrillic_ghe: number
const KEY_Cyrillic_ghe_bar: number
const KEY_Cyrillic_ha: number
const KEY_Cyrillic_ha_descender: number
const KEY_Cyrillic_hardsign: number
const KEY_Cyrillic_i: number
const KEY_Cyrillic_i_macron: number
const KEY_Cyrillic_ie: number
const KEY_Cyrillic_io: number
const KEY_Cyrillic_je: number
const KEY_Cyrillic_ka: number
const KEY_Cyrillic_ka_descender: number
const KEY_Cyrillic_ka_vertstroke: number
const KEY_Cyrillic_lje: number
const KEY_Cyrillic_nje: number
const KEY_Cyrillic_o: number
const KEY_Cyrillic_o_bar: number
const KEY_Cyrillic_pe: number
const KEY_Cyrillic_schwa: number
const KEY_Cyrillic_sha: number
const KEY_Cyrillic_shcha: number
const KEY_Cyrillic_shha: number
const KEY_Cyrillic_shorti: number
const KEY_Cyrillic_softsign: number
const KEY_Cyrillic_te: number
const KEY_Cyrillic_tse: number
const KEY_Cyrillic_u: number
const KEY_Cyrillic_u_macron: number
const KEY_Cyrillic_u_straight: number
const KEY_Cyrillic_u_straight_bar: number
const KEY_Cyrillic_ve: number
const KEY_Cyrillic_ya: number
const KEY_Cyrillic_yeru: number
const KEY_Cyrillic_yu: number
const KEY_Cyrillic_ze: number
const KEY_Cyrillic_zhe: number
const KEY_Cyrillic_zhe_descender: number
const KEY_D: number
const KEY_DOS: number
const KEY_Dabovedot: number
const KEY_Dcaron: number
const KEY_Delete: number
const KEY_Display: number
const KEY_Documents: number
const KEY_DongSign: number
const KEY_Down: number
const KEY_Dstroke: number
const KEY_E: number
const KEY_ENG: number
const KEY_ETH: number
const KEY_EZH: number
const KEY_Eabovedot: number
const KEY_Eacute: number
const KEY_Ebelowdot: number
const KEY_Ecaron: number
const KEY_Ecircumflex: number
const KEY_Ecircumflexacute: number
const KEY_Ecircumflexbelowdot: number
const KEY_Ecircumflexgrave: number
const KEY_Ecircumflexhook: number
const KEY_Ecircumflextilde: number
const KEY_EcuSign: number
const KEY_Ediaeresis: number
const KEY_Egrave: number
const KEY_Ehook: number
const KEY_Eisu_Shift: number
const KEY_Eisu_toggle: number
const KEY_Eject: number
const KEY_Emacron: number
const KEY_End: number
const KEY_Eogonek: number
const KEY_Escape: number
const KEY_Eth: number
const KEY_Etilde: number
const KEY_EuroSign: number
const KEY_Excel: number
const KEY_Execute: number
const KEY_Explorer: number
const KEY_F: number
const KEY_F1: number
const KEY_F10: number
const KEY_F11: number
const KEY_F12: number
const KEY_F13: number
const KEY_F14: number
const KEY_F15: number
const KEY_F16: number
const KEY_F17: number
const KEY_F18: number
const KEY_F19: number
const KEY_F2: number
const KEY_F20: number
const KEY_F21: number
const KEY_F22: number
const KEY_F23: number
const KEY_F24: number
const KEY_F25: number
const KEY_F26: number
const KEY_F27: number
const KEY_F28: number
const KEY_F29: number
const KEY_F3: number
const KEY_F30: number
const KEY_F31: number
const KEY_F32: number
const KEY_F33: number
const KEY_F34: number
const KEY_F35: number
const KEY_F4: number
const KEY_F5: number
const KEY_F6: number
const KEY_F7: number
const KEY_F8: number
const KEY_F9: number
const KEY_FFrancSign: number
const KEY_Fabovedot: number
const KEY_Farsi_0: number
const KEY_Farsi_1: number
const KEY_Farsi_2: number
const KEY_Farsi_3: number
const KEY_Farsi_4: number
const KEY_Farsi_5: number
const KEY_Farsi_6: number
const KEY_Farsi_7: number
const KEY_Farsi_8: number
const KEY_Farsi_9: number
const KEY_Farsi_yeh: number
const KEY_Favorites: number
const KEY_Finance: number
const KEY_Find: number
const KEY_First_Virtual_Screen: number
const KEY_Forward: number
const KEY_FrameBack: number
const KEY_FrameForward: number
const KEY_G: number
const KEY_Gabovedot: number
const KEY_Game: number
const KEY_Gbreve: number
const KEY_Gcaron: number
const KEY_Gcedilla: number
const KEY_Gcircumflex: number
const KEY_Georgian_an: number
const KEY_Georgian_ban: number
const KEY_Georgian_can: number
const KEY_Georgian_char: number
const KEY_Georgian_chin: number
const KEY_Georgian_cil: number
const KEY_Georgian_don: number
const KEY_Georgian_en: number
const KEY_Georgian_fi: number
const KEY_Georgian_gan: number
const KEY_Georgian_ghan: number
const KEY_Georgian_hae: number
const KEY_Georgian_har: number
const KEY_Georgian_he: number
const KEY_Georgian_hie: number
const KEY_Georgian_hoe: number
const KEY_Georgian_in: number
const KEY_Georgian_jhan: number
const KEY_Georgian_jil: number
const KEY_Georgian_kan: number
const KEY_Georgian_khar: number
const KEY_Georgian_las: number
const KEY_Georgian_man: number
const KEY_Georgian_nar: number
const KEY_Georgian_on: number
const KEY_Georgian_par: number
const KEY_Georgian_phar: number
const KEY_Georgian_qar: number
const KEY_Georgian_rae: number
const KEY_Georgian_san: number
const KEY_Georgian_shin: number
const KEY_Georgian_tan: number
const KEY_Georgian_tar: number
const KEY_Georgian_un: number
const KEY_Georgian_vin: number
const KEY_Georgian_we: number
const KEY_Georgian_xan: number
const KEY_Georgian_zen: number
const KEY_Georgian_zhar: number
const KEY_Go: number
const KEY_Greek_ALPHA: number
const KEY_Greek_ALPHAaccent: number
const KEY_Greek_BETA: number
const KEY_Greek_CHI: number
const KEY_Greek_DELTA: number
const KEY_Greek_EPSILON: number
const KEY_Greek_EPSILONaccent: number
const KEY_Greek_ETA: number
const KEY_Greek_ETAaccent: number
const KEY_Greek_GAMMA: number
const KEY_Greek_IOTA: number
const KEY_Greek_IOTAaccent: number
const KEY_Greek_IOTAdiaeresis: number
const KEY_Greek_IOTAdieresis: number
const KEY_Greek_KAPPA: number
const KEY_Greek_LAMBDA: number
const KEY_Greek_LAMDA: number
const KEY_Greek_MU: number
const KEY_Greek_NU: number
const KEY_Greek_OMEGA: number
const KEY_Greek_OMEGAaccent: number
const KEY_Greek_OMICRON: number
const KEY_Greek_OMICRONaccent: number
const KEY_Greek_PHI: number
const KEY_Greek_PI: number
const KEY_Greek_PSI: number
const KEY_Greek_RHO: number
const KEY_Greek_SIGMA: number
const KEY_Greek_TAU: number
const KEY_Greek_THETA: number
const KEY_Greek_UPSILON: number
const KEY_Greek_UPSILONaccent: number
const KEY_Greek_UPSILONdieresis: number
const KEY_Greek_XI: number
const KEY_Greek_ZETA: number
const KEY_Greek_accentdieresis: number
const KEY_Greek_alpha: number
const KEY_Greek_alphaaccent: number
const KEY_Greek_beta: number
const KEY_Greek_chi: number
const KEY_Greek_delta: number
const KEY_Greek_epsilon: number
const KEY_Greek_epsilonaccent: number
const KEY_Greek_eta: number
const KEY_Greek_etaaccent: number
const KEY_Greek_finalsmallsigma: number
const KEY_Greek_gamma: number
const KEY_Greek_horizbar: number
const KEY_Greek_iota: number
const KEY_Greek_iotaaccent: number
const KEY_Greek_iotaaccentdieresis: number
const KEY_Greek_iotadieresis: number
const KEY_Greek_kappa: number
const KEY_Greek_lambda: number
const KEY_Greek_lamda: number
const KEY_Greek_mu: number
const KEY_Greek_nu: number
const KEY_Greek_omega: number
const KEY_Greek_omegaaccent: number
const KEY_Greek_omicron: number
const KEY_Greek_omicronaccent: number
const KEY_Greek_phi: number
const KEY_Greek_pi: number
const KEY_Greek_psi: number
const KEY_Greek_rho: number
const KEY_Greek_sigma: number
const KEY_Greek_switch: number
const KEY_Greek_tau: number
const KEY_Greek_theta: number
const KEY_Greek_upsilon: number
const KEY_Greek_upsilonaccent: number
const KEY_Greek_upsilonaccentdieresis: number
const KEY_Greek_upsilondieresis: number
const KEY_Greek_xi: number
const KEY_Greek_zeta: number
const KEY_Green: number
const KEY_H: number
const KEY_Hangul: number
const KEY_Hangul_A: number
const KEY_Hangul_AE: number
const KEY_Hangul_AraeA: number
const KEY_Hangul_AraeAE: number
const KEY_Hangul_Banja: number
const KEY_Hangul_Cieuc: number
const KEY_Hangul_Codeinput: number
const KEY_Hangul_Dikeud: number
const KEY_Hangul_E: number
const KEY_Hangul_EO: number
const KEY_Hangul_EU: number
const KEY_Hangul_End: number
const KEY_Hangul_Hanja: number
const KEY_Hangul_Hieuh: number
const KEY_Hangul_I: number
const KEY_Hangul_Ieung: number
const KEY_Hangul_J_Cieuc: number
const KEY_Hangul_J_Dikeud: number
const KEY_Hangul_J_Hieuh: number
const KEY_Hangul_J_Ieung: number
const KEY_Hangul_J_Jieuj: number
const KEY_Hangul_J_Khieuq: number
const KEY_Hangul_J_Kiyeog: number
const KEY_Hangul_J_KiyeogSios: number
const KEY_Hangul_J_KkogjiDalrinIeung: number
const KEY_Hangul_J_Mieum: number
const KEY_Hangul_J_Nieun: number
const KEY_Hangul_J_NieunHieuh: number
const KEY_Hangul_J_NieunJieuj: number
const KEY_Hangul_J_PanSios: number
const KEY_Hangul_J_Phieuf: number
const KEY_Hangul_J_Pieub: number
const KEY_Hangul_J_PieubSios: number
const KEY_Hangul_J_Rieul: number
const KEY_Hangul_J_RieulHieuh: number
const KEY_Hangul_J_RieulKiyeog: number
const KEY_Hangul_J_RieulMieum: number
const KEY_Hangul_J_RieulPhieuf: number
const KEY_Hangul_J_RieulPieub: number
const KEY_Hangul_J_RieulSios: number
const KEY_Hangul_J_RieulTieut: number
const KEY_Hangul_J_Sios: number
const KEY_Hangul_J_SsangKiyeog: number
const KEY_Hangul_J_SsangSios: number
const KEY_Hangul_J_Tieut: number
const KEY_Hangul_J_YeorinHieuh: number
const KEY_Hangul_Jamo: number
const KEY_Hangul_Jeonja: number
const KEY_Hangul_Jieuj: number
const KEY_Hangul_Khieuq: number
const KEY_Hangul_Kiyeog: number
const KEY_Hangul_KiyeogSios: number
const KEY_Hangul_KkogjiDalrinIeung: number
const KEY_Hangul_Mieum: number
const KEY_Hangul_MultipleCandidate: number
const KEY_Hangul_Nieun: number
const KEY_Hangul_NieunHieuh: number
const KEY_Hangul_NieunJieuj: number
const KEY_Hangul_O: number
const KEY_Hangul_OE: number
const KEY_Hangul_PanSios: number
const KEY_Hangul_Phieuf: number
const KEY_Hangul_Pieub: number
const KEY_Hangul_PieubSios: number
const KEY_Hangul_PostHanja: number
const KEY_Hangul_PreHanja: number
const KEY_Hangul_PreviousCandidate: number
const KEY_Hangul_Rieul: number
const KEY_Hangul_RieulHieuh: number
const KEY_Hangul_RieulKiyeog: number
const KEY_Hangul_RieulMieum: number
const KEY_Hangul_RieulPhieuf: number
const KEY_Hangul_RieulPieub: number
const KEY_Hangul_RieulSios: number
const KEY_Hangul_RieulTieut: number
const KEY_Hangul_RieulYeorinHieuh: number
const KEY_Hangul_Romaja: number
const KEY_Hangul_SingleCandidate: number
const KEY_Hangul_Sios: number
const KEY_Hangul_Special: number
const KEY_Hangul_SsangDikeud: number
const KEY_Hangul_SsangJieuj: number
const KEY_Hangul_SsangKiyeog: number
const KEY_Hangul_SsangPieub: number
const KEY_Hangul_SsangSios: number
const KEY_Hangul_Start: number
const KEY_Hangul_SunkyeongeumMieum: number
const KEY_Hangul_SunkyeongeumPhieuf: number
const KEY_Hangul_SunkyeongeumPieub: number
const KEY_Hangul_Tieut: number
const KEY_Hangul_U: number
const KEY_Hangul_WA: number
const KEY_Hangul_WAE: number
const KEY_Hangul_WE: number
const KEY_Hangul_WEO: number
const KEY_Hangul_WI: number
const KEY_Hangul_YA: number
const KEY_Hangul_YAE: number
const KEY_Hangul_YE: number
const KEY_Hangul_YEO: number
const KEY_Hangul_YI: number
const KEY_Hangul_YO: number
const KEY_Hangul_YU: number
const KEY_Hangul_YeorinHieuh: number
const KEY_Hangul_switch: number
const KEY_Hankaku: number
const KEY_Hcircumflex: number
const KEY_Hebrew_switch: number
const KEY_Help: number
const KEY_Henkan: number
const KEY_Henkan_Mode: number
const KEY_Hibernate: number
const KEY_Hiragana: number
const KEY_Hiragana_Katakana: number
const KEY_History: number
const KEY_Home: number
const KEY_HomePage: number
const KEY_HotLinks: number
const KEY_Hstroke: number
const KEY_Hyper_L: number
const KEY_Hyper_R: number
const KEY_I: number
const KEY_ISO_Center_Object: number
const KEY_ISO_Continuous_Underline: number
const KEY_ISO_Discontinuous_Underline: number
const KEY_ISO_Emphasize: number
const KEY_ISO_Enter: number
const KEY_ISO_Fast_Cursor_Down: number
const KEY_ISO_Fast_Cursor_Left: number
const KEY_ISO_Fast_Cursor_Right: number
const KEY_ISO_Fast_Cursor_Up: number
const KEY_ISO_First_Group: number
const KEY_ISO_First_Group_Lock: number
const KEY_ISO_Group_Latch: number
const KEY_ISO_Group_Lock: number
const KEY_ISO_Group_Shift: number
const KEY_ISO_Last_Group: number
const KEY_ISO_Last_Group_Lock: number
const KEY_ISO_Left_Tab: number
const KEY_ISO_Level2_Latch: number
const KEY_ISO_Level3_Latch: number
const KEY_ISO_Level3_Lock: number
const KEY_ISO_Level3_Shift: number
const KEY_ISO_Level5_Latch: number
const KEY_ISO_Level5_Lock: number
const KEY_ISO_Level5_Shift: number
const KEY_ISO_Lock: number
const KEY_ISO_Move_Line_Down: number
const KEY_ISO_Move_Line_Up: number
const KEY_ISO_Next_Group: number
const KEY_ISO_Next_Group_Lock: number
const KEY_ISO_Partial_Line_Down: number
const KEY_ISO_Partial_Line_Up: number
const KEY_ISO_Partial_Space_Left: number
const KEY_ISO_Partial_Space_Right: number
const KEY_ISO_Prev_Group: number
const KEY_ISO_Prev_Group_Lock: number
const KEY_ISO_Release_Both_Margins: number
const KEY_ISO_Release_Margin_Left: number
const KEY_ISO_Release_Margin_Right: number
const KEY_ISO_Set_Margin_Left: number
const KEY_ISO_Set_Margin_Right: number
const KEY_Iabovedot: number
const KEY_Iacute: number
const KEY_Ibelowdot: number
const KEY_Ibreve: number
const KEY_Icircumflex: number
const KEY_Idiaeresis: number
const KEY_Igrave: number
const KEY_Ihook: number
const KEY_Imacron: number
const KEY_Insert: number
const KEY_Iogonek: number
const KEY_Itilde: number
const KEY_J: number
const KEY_Jcircumflex: number
const KEY_K: number
const KEY_KP_0: number
const KEY_KP_1: number
const KEY_KP_2: number
const KEY_KP_3: number
const KEY_KP_4: number
const KEY_KP_5: number
const KEY_KP_6: number
const KEY_KP_7: number
const KEY_KP_8: number
const KEY_KP_9: number
const KEY_KP_Add: number
const KEY_KP_Begin: number
const KEY_KP_Decimal: number
const KEY_KP_Delete: number
const KEY_KP_Divide: number
const KEY_KP_Down: number
const KEY_KP_End: number
const KEY_KP_Enter: number
const KEY_KP_Equal: number
const KEY_KP_F1: number
const KEY_KP_F2: number
const KEY_KP_F3: number
const KEY_KP_F4: number
const KEY_KP_Home: number
const KEY_KP_Insert: number
const KEY_KP_Left: number
const KEY_KP_Multiply: number
const KEY_KP_Next: number
const KEY_KP_Page_Down: number
const KEY_KP_Page_Up: number
const KEY_KP_Prior: number
const KEY_KP_Right: number
const KEY_KP_Separator: number
const KEY_KP_Space: number
const KEY_KP_Subtract: number
const KEY_KP_Tab: number
const KEY_KP_Up: number
const KEY_Kana_Lock: number
const KEY_Kana_Shift: number
const KEY_Kanji: number
const KEY_Kanji_Bangou: number
const KEY_Katakana: number
const KEY_KbdBrightnessDown: number
const KEY_KbdBrightnessUp: number
const KEY_KbdLightOnOff: number
const KEY_Kcedilla: number
const KEY_Korean_Won: number
const KEY_L: number
const KEY_L1: number
const KEY_L10: number
const KEY_L2: number
const KEY_L3: number
const KEY_L4: number
const KEY_L5: number
const KEY_L6: number
const KEY_L7: number
const KEY_L8: number
const KEY_L9: number
const KEY_Lacute: number
const KEY_Last_Virtual_Screen: number
const KEY_Launch0: number
const KEY_Launch1: number
const KEY_Launch2: number
const KEY_Launch3: number
const KEY_Launch4: number
const KEY_Launch5: number
const KEY_Launch6: number
const KEY_Launch7: number
const KEY_Launch8: number
const KEY_Launch9: number
const KEY_LaunchA: number
const KEY_LaunchB: number
const KEY_LaunchC: number
const KEY_LaunchD: number
const KEY_LaunchE: number
const KEY_LaunchF: number
const KEY_Lbelowdot: number
const KEY_Lcaron: number
const KEY_Lcedilla: number
const KEY_Left: number
const KEY_LightBulb: number
const KEY_Linefeed: number
const KEY_LiraSign: number
const KEY_LogGrabInfo: number
const KEY_LogOff: number
const KEY_LogWindowTree: number
const KEY_Lstroke: number
const KEY_M: number
const KEY_Mabovedot: number
const KEY_Macedonia_DSE: number
const KEY_Macedonia_GJE: number
const KEY_Macedonia_KJE: number
const KEY_Macedonia_dse: number
const KEY_Macedonia_gje: number
const KEY_Macedonia_kje: number
const KEY_Mae_Koho: number
const KEY_Mail: number
const KEY_MailForward: number
const KEY_Market: number
const KEY_Massyo: number
const KEY_Meeting: number
const KEY_Memo: number
const KEY_Menu: number
const KEY_MenuKB: number
const KEY_MenuPB: number
const KEY_Messenger: number
const KEY_Meta_L: number
const KEY_Meta_R: number
const KEY_MillSign: number
const KEY_ModeLock: number
const KEY_Mode_switch: number
const KEY_MonBrightnessDown: number
const KEY_MonBrightnessUp: number
const KEY_MouseKeys_Accel_Enable: number
const KEY_MouseKeys_Enable: number
const KEY_Muhenkan: number
const KEY_Multi_key: number
const KEY_MultipleCandidate: number
const KEY_Music: number
const KEY_MyComputer: number
const KEY_MySites: number
const KEY_N: number
const KEY_Nacute: number
const KEY_NairaSign: number
const KEY_Ncaron: number
const KEY_Ncedilla: number
const KEY_New: number
const KEY_NewSheqelSign: number
const KEY_News: number
const KEY_Next: number
const KEY_Next_VMode: number
const KEY_Next_Virtual_Screen: number
const KEY_Ntilde: number
const KEY_Num_Lock: number
const KEY_O: number
const KEY_OE: number
const KEY_Oacute: number
const KEY_Obarred: number
const KEY_Obelowdot: number
const KEY_Ocaron: number
const KEY_Ocircumflex: number
const KEY_Ocircumflexacute: number
const KEY_Ocircumflexbelowdot: number
const KEY_Ocircumflexgrave: number
const KEY_Ocircumflexhook: number
const KEY_Ocircumflextilde: number
const KEY_Odiaeresis: number
const KEY_Odoubleacute: number
const KEY_OfficeHome: number
const KEY_Ograve: number
const KEY_Ohook: number
const KEY_Ohorn: number
const KEY_Ohornacute: number
const KEY_Ohornbelowdot: number
const KEY_Ohorngrave: number
const KEY_Ohornhook: number
const KEY_Ohorntilde: number
const KEY_Omacron: number
const KEY_Ooblique: number
const KEY_Open: number
const KEY_OpenURL: number
const KEY_Option: number
const KEY_Oslash: number
const KEY_Otilde: number
const KEY_Overlay1_Enable: number
const KEY_Overlay2_Enable: number
const KEY_P: number
const KEY_Pabovedot: number
const KEY_Page_Down: number
const KEY_Page_Up: number
const KEY_Paste: number
const KEY_Pause: number
const KEY_PesetaSign: number
const KEY_Phone: number
const KEY_Pictures: number
const KEY_Pointer_Accelerate: number
const KEY_Pointer_Button1: number
const KEY_Pointer_Button2: number
const KEY_Pointer_Button3: number
const KEY_Pointer_Button4: number
const KEY_Pointer_Button5: number
const KEY_Pointer_Button_Dflt: number
const KEY_Pointer_DblClick1: number
const KEY_Pointer_DblClick2: number
const KEY_Pointer_DblClick3: number
const KEY_Pointer_DblClick4: number
const KEY_Pointer_DblClick5: number
const KEY_Pointer_DblClick_Dflt: number
const KEY_Pointer_DfltBtnNext: number
const KEY_Pointer_DfltBtnPrev: number
const KEY_Pointer_Down: number
const KEY_Pointer_DownLeft: number
const KEY_Pointer_DownRight: number
const KEY_Pointer_Drag1: number
const KEY_Pointer_Drag2: number
const KEY_Pointer_Drag3: number
const KEY_Pointer_Drag4: number
const KEY_Pointer_Drag5: number
const KEY_Pointer_Drag_Dflt: number
const KEY_Pointer_EnableKeys: number
const KEY_Pointer_Left: number
const KEY_Pointer_Right: number
const KEY_Pointer_Up: number
const KEY_Pointer_UpLeft: number
const KEY_Pointer_UpRight: number
const KEY_PowerDown: number
const KEY_PowerOff: number
const KEY_Prev_VMode: number
const KEY_Prev_Virtual_Screen: number
const KEY_PreviousCandidate: number
const KEY_Print: number
const KEY_Prior: number
const KEY_Q: number
const KEY_R: number
const KEY_R1: number
const KEY_R10: number
const KEY_R11: number
const KEY_R12: number
const KEY_R13: number
const KEY_R14: number
const KEY_R15: number
const KEY_R2: number
const KEY_R3: number
const KEY_R4: number
const KEY_R5: number
const KEY_R6: number
const KEY_R7: number
const KEY_R8: number
const KEY_R9: number
const KEY_Racute: number
const KEY_Rcaron: number
const KEY_Rcedilla: number
const KEY_Red: number
const KEY_Redo: number
const KEY_Refresh: number
const KEY_Reload: number
const KEY_RepeatKeys_Enable: number
const KEY_Reply: number
const KEY_Return: number
const KEY_Right: number
const KEY_RockerDown: number
const KEY_RockerEnter: number
const KEY_RockerUp: number
const KEY_Romaji: number
const KEY_RotateWindows: number
const KEY_RotationKB: number
const KEY_RotationPB: number
const KEY_RupeeSign: number
const KEY_S: number
const KEY_SCHWA: number
const KEY_Sabovedot: number
const KEY_Sacute: number
const KEY_Save: number
const KEY_Scaron: number
const KEY_Scedilla: number
const KEY_Scircumflex: number
const KEY_ScreenSaver: number
const KEY_ScrollClick: number
const KEY_ScrollDown: number
const KEY_ScrollUp: number
const KEY_Scroll_Lock: number
const KEY_Search: number
const KEY_Select: number
const KEY_SelectButton: number
const KEY_Send: number
const KEY_Serbian_DJE: number
const KEY_Serbian_DZE: number
const KEY_Serbian_JE: number
const KEY_Serbian_LJE: number
const KEY_Serbian_NJE: number
const KEY_Serbian_TSHE: number
const KEY_Serbian_dje: number
const KEY_Serbian_dze: number
const KEY_Serbian_je: number
const KEY_Serbian_lje: number
const KEY_Serbian_nje: number
const KEY_Serbian_tshe: number
const KEY_Shift_L: number
const KEY_Shift_Lock: number
const KEY_Shift_R: number
const KEY_Shop: number
const KEY_SingleCandidate: number
const KEY_Sinh_a: number
const KEY_Sinh_aa: number
const KEY_Sinh_aa2: number
const KEY_Sinh_ae: number
const KEY_Sinh_ae2: number
const KEY_Sinh_aee: number
const KEY_Sinh_aee2: number
const KEY_Sinh_ai: number
const KEY_Sinh_ai2: number
const KEY_Sinh_al: number
const KEY_Sinh_au: number
const KEY_Sinh_au2: number
const KEY_Sinh_ba: number
const KEY_Sinh_bha: number
const KEY_Sinh_ca: number
const KEY_Sinh_cha: number
const KEY_Sinh_dda: number
const KEY_Sinh_ddha: number
const KEY_Sinh_dha: number
const KEY_Sinh_dhha: number
const KEY_Sinh_e: number
const KEY_Sinh_e2: number
const KEY_Sinh_ee: number
const KEY_Sinh_ee2: number
const KEY_Sinh_fa: number
const KEY_Sinh_ga: number
const KEY_Sinh_gha: number
const KEY_Sinh_h2: number
const KEY_Sinh_ha: number
const KEY_Sinh_i: number
const KEY_Sinh_i2: number
const KEY_Sinh_ii: number
const KEY_Sinh_ii2: number
const KEY_Sinh_ja: number
const KEY_Sinh_jha: number
const KEY_Sinh_jnya: number
const KEY_Sinh_ka: number
const KEY_Sinh_kha: number
const KEY_Sinh_kunddaliya: number
const KEY_Sinh_la: number
const KEY_Sinh_lla: number
const KEY_Sinh_lu: number
const KEY_Sinh_lu2: number
const KEY_Sinh_luu: number
const KEY_Sinh_luu2: number
const KEY_Sinh_ma: number
const KEY_Sinh_mba: number
const KEY_Sinh_na: number
const KEY_Sinh_ndda: number
const KEY_Sinh_ndha: number
const KEY_Sinh_ng: number
const KEY_Sinh_ng2: number
const KEY_Sinh_nga: number
const KEY_Sinh_nja: number
const KEY_Sinh_nna: number
const KEY_Sinh_nya: number
const KEY_Sinh_o: number
const KEY_Sinh_o2: number
const KEY_Sinh_oo: number
const KEY_Sinh_oo2: number
const KEY_Sinh_pa: number
const KEY_Sinh_pha: number
const KEY_Sinh_ra: number
const KEY_Sinh_ri: number
const KEY_Sinh_rii: number
const KEY_Sinh_ru2: number
const KEY_Sinh_ruu2: number
const KEY_Sinh_sa: number
const KEY_Sinh_sha: number
const KEY_Sinh_ssha: number
const KEY_Sinh_tha: number
const KEY_Sinh_thha: number
const KEY_Sinh_tta: number
const KEY_Sinh_ttha: number
const KEY_Sinh_u: number
const KEY_Sinh_u2: number
const KEY_Sinh_uu: number
const KEY_Sinh_uu2: number
const KEY_Sinh_va: number
const KEY_Sinh_ya: number
const KEY_Sleep: number
const KEY_SlowKeys_Enable: number
const KEY_Spell: number
const KEY_SplitScreen: number
const KEY_Standby: number
const KEY_Start: number
const KEY_StickyKeys_Enable: number
const KEY_Stop: number
const KEY_Subtitle: number
const KEY_Super_L: number
const KEY_Super_R: number
const KEY_Support: number
const KEY_Suspend: number
const KEY_Switch_VT_1: number
const KEY_Switch_VT_10: number
const KEY_Switch_VT_11: number
const KEY_Switch_VT_12: number
const KEY_Switch_VT_2: number
const KEY_Switch_VT_3: number
const KEY_Switch_VT_4: number
const KEY_Switch_VT_5: number
const KEY_Switch_VT_6: number
const KEY_Switch_VT_7: number
const KEY_Switch_VT_8: number
const KEY_Switch_VT_9: number
const KEY_Sys_Req: number
const KEY_T: number
const KEY_THORN: number
const KEY_Tab: number
const KEY_Tabovedot: number
const KEY_TaskPane: number
const KEY_Tcaron: number
const KEY_Tcedilla: number
const KEY_Terminal: number
const KEY_Terminate_Server: number
const KEY_Thai_baht: number
const KEY_Thai_bobaimai: number
const KEY_Thai_chochan: number
const KEY_Thai_chochang: number
const KEY_Thai_choching: number
const KEY_Thai_chochoe: number
const KEY_Thai_dochada: number
const KEY_Thai_dodek: number
const KEY_Thai_fofa: number
const KEY_Thai_fofan: number
const KEY_Thai_hohip: number
const KEY_Thai_honokhuk: number
const KEY_Thai_khokhai: number
const KEY_Thai_khokhon: number
const KEY_Thai_khokhuat: number
const KEY_Thai_khokhwai: number
const KEY_Thai_khorakhang: number
const KEY_Thai_kokai: number
const KEY_Thai_lakkhangyao: number
const KEY_Thai_lekchet: number
const KEY_Thai_lekha: number
const KEY_Thai_lekhok: number
const KEY_Thai_lekkao: number
const KEY_Thai_leknung: number
const KEY_Thai_lekpaet: number
const KEY_Thai_leksam: number
const KEY_Thai_leksi: number
const KEY_Thai_leksong: number
const KEY_Thai_leksun: number
const KEY_Thai_lochula: number
const KEY_Thai_loling: number
const KEY_Thai_lu: number
const KEY_Thai_maichattawa: number
const KEY_Thai_maiek: number
const KEY_Thai_maihanakat: number
const KEY_Thai_maihanakat_maitho: number
const KEY_Thai_maitaikhu: number
const KEY_Thai_maitho: number
const KEY_Thai_maitri: number
const KEY_Thai_maiyamok: number
const KEY_Thai_moma: number
const KEY_Thai_ngongu: number
const KEY_Thai_nikhahit: number
const KEY_Thai_nonen: number
const KEY_Thai_nonu: number
const KEY_Thai_oang: number
const KEY_Thai_paiyannoi: number
const KEY_Thai_phinthu: number
const KEY_Thai_phophan: number
const KEY_Thai_phophung: number
const KEY_Thai_phosamphao: number
const KEY_Thai_popla: number
const KEY_Thai_rorua: number
const KEY_Thai_ru: number
const KEY_Thai_saraa: number
const KEY_Thai_saraaa: number
const KEY_Thai_saraae: number
const KEY_Thai_saraaimaimalai: number
const KEY_Thai_saraaimaimuan: number
const KEY_Thai_saraam: number
const KEY_Thai_sarae: number
const KEY_Thai_sarai: number
const KEY_Thai_saraii: number
const KEY_Thai_sarao: number
const KEY_Thai_sarau: number
const KEY_Thai_saraue: number
const KEY_Thai_sarauee: number
const KEY_Thai_sarauu: number
const KEY_Thai_sorusi: number
const KEY_Thai_sosala: number
const KEY_Thai_soso: number
const KEY_Thai_sosua: number
const KEY_Thai_thanthakhat: number
const KEY_Thai_thonangmontho: number
const KEY_Thai_thophuthao: number
const KEY_Thai_thothahan: number
const KEY_Thai_thothan: number
const KEY_Thai_thothong: number
const KEY_Thai_thothung: number
const KEY_Thai_topatak: number
const KEY_Thai_totao: number
const KEY_Thai_wowaen: number
const KEY_Thai_yoyak: number
const KEY_Thai_yoying: number
const KEY_Thorn: number
const KEY_Time: number
const KEY_ToDoList: number
const KEY_Tools: number
const KEY_TopMenu: number
const KEY_TouchpadOff: number
const KEY_TouchpadOn: number
const KEY_TouchpadToggle: number
const KEY_Touroku: number
const KEY_Travel: number
const KEY_Tslash: number
const KEY_U: number
const KEY_UWB: number
const KEY_Uacute: number
const KEY_Ubelowdot: number
const KEY_Ubreve: number
const KEY_Ucircumflex: number
const KEY_Udiaeresis: number
const KEY_Udoubleacute: number
const KEY_Ugrave: number
const KEY_Uhook: number
const KEY_Uhorn: number
const KEY_Uhornacute: number
const KEY_Uhornbelowdot: number
const KEY_Uhorngrave: number
const KEY_Uhornhook: number
const KEY_Uhorntilde: number
const KEY_Ukrainian_GHE_WITH_UPTURN: number
const KEY_Ukrainian_I: number
const KEY_Ukrainian_IE: number
const KEY_Ukrainian_YI: number
const KEY_Ukrainian_ghe_with_upturn: number
const KEY_Ukrainian_i: number
const KEY_Ukrainian_ie: number
const KEY_Ukrainian_yi: number
const KEY_Ukranian_I: number
const KEY_Ukranian_JE: number
const KEY_Ukranian_YI: number
const KEY_Ukranian_i: number
const KEY_Ukranian_je: number
const KEY_Ukranian_yi: number
const KEY_Umacron: number
const KEY_Undo: number
const KEY_Ungrab: number
const KEY_Uogonek: number
const KEY_Up: number
const KEY_Uring: number
const KEY_User1KB: number
const KEY_User2KB: number
const KEY_UserPB: number
const KEY_Utilde: number
const KEY_V: number
const KEY_VendorHome: number
const KEY_Video: number
const KEY_View: number
const KEY_VoidSymbol: number
const KEY_W: number
const KEY_WLAN: number
const KEY_WWW: number
const KEY_Wacute: number
const KEY_WakeUp: number
const KEY_Wcircumflex: number
const KEY_Wdiaeresis: number
const KEY_WebCam: number
const KEY_Wgrave: number
const KEY_WheelButton: number
const KEY_WindowClear: number
const KEY_WonSign: number
const KEY_Word: number
const KEY_X: number
const KEY_Xabovedot: number
const KEY_Xfer: number
const KEY_Y: number
const KEY_Yacute: number
const KEY_Ybelowdot: number
const KEY_Ycircumflex: number
const KEY_Ydiaeresis: number
const KEY_Yellow: number
const KEY_Ygrave: number
const KEY_Yhook: number
const KEY_Ytilde: number
const KEY_Z: number
const KEY_Zabovedot: number
const KEY_Zacute: number
const KEY_Zcaron: number
const KEY_Zen_Koho: number
const KEY_Zenkaku: number
const KEY_Zenkaku_Hankaku: number
const KEY_ZoomIn: number
const KEY_ZoomOut: number
const KEY_Zstroke: number
const KEY_a: number
const KEY_aacute: number
const KEY_abelowdot: number
const KEY_abovedot: number
const KEY_abreve: number
const KEY_abreveacute: number
const KEY_abrevebelowdot: number
const KEY_abrevegrave: number
const KEY_abrevehook: number
const KEY_abrevetilde: number
const KEY_acircumflex: number
const KEY_acircumflexacute: number
const KEY_acircumflexbelowdot: number
const KEY_acircumflexgrave: number
const KEY_acircumflexhook: number
const KEY_acircumflextilde: number
const KEY_acute: number
const KEY_adiaeresis: number
const KEY_ae: number
const KEY_agrave: number
const KEY_ahook: number
const KEY_amacron: number
const KEY_ampersand: number
const KEY_aogonek: number
const KEY_apostrophe: number
const KEY_approxeq: number
const KEY_approximate: number
const KEY_aring: number
const KEY_asciicircum: number
const KEY_asciitilde: number
const KEY_asterisk: number
const KEY_at: number
const KEY_atilde: number
const KEY_b: number
const KEY_babovedot: number
const KEY_backslash: number
const KEY_ballotcross: number
const KEY_bar: number
const KEY_because: number
const KEY_blank: number
const KEY_botintegral: number
const KEY_botleftparens: number
const KEY_botleftsqbracket: number
const KEY_botleftsummation: number
const KEY_botrightparens: number
const KEY_botrightsqbracket: number
const KEY_botrightsummation: number
const KEY_bott: number
const KEY_botvertsummationconnector: number
const KEY_braceleft: number
const KEY_braceright: number
const KEY_bracketleft: number
const KEY_bracketright: number
const KEY_braille_blank: number
const KEY_braille_dot_1: number
const KEY_braille_dot_10: number
const KEY_braille_dot_2: number
const KEY_braille_dot_3: number
const KEY_braille_dot_4: number
const KEY_braille_dot_5: number
const KEY_braille_dot_6: number
const KEY_braille_dot_7: number
const KEY_braille_dot_8: number
const KEY_braille_dot_9: number
const KEY_braille_dots_1: number
const KEY_braille_dots_12: number
const KEY_braille_dots_123: number
const KEY_braille_dots_1234: number
const KEY_braille_dots_12345: number
const KEY_braille_dots_123456: number
const KEY_braille_dots_1234567: number
const KEY_braille_dots_12345678: number
const KEY_braille_dots_1234568: number
const KEY_braille_dots_123457: number
const KEY_braille_dots_1234578: number
const KEY_braille_dots_123458: number
const KEY_braille_dots_12346: number
const KEY_braille_dots_123467: number
const KEY_braille_dots_1234678: number
const KEY_braille_dots_123468: number
const KEY_braille_dots_12347: number
const KEY_braille_dots_123478: number
const KEY_braille_dots_12348: number
const KEY_braille_dots_1235: number
const KEY_braille_dots_12356: number
const KEY_braille_dots_123567: number
const KEY_braille_dots_1235678: number
const KEY_braille_dots_123568: number
const KEY_braille_dots_12357: number
const KEY_braille_dots_123578: number
const KEY_braille_dots_12358: number
const KEY_braille_dots_1236: number
const KEY_braille_dots_12367: number
const KEY_braille_dots_123678: number
const KEY_braille_dots_12368: number
const KEY_braille_dots_1237: number
const KEY_braille_dots_12378: number
const KEY_braille_dots_1238: number
const KEY_braille_dots_124: number
const KEY_braille_dots_1245: number
const KEY_braille_dots_12456: number
const KEY_braille_dots_124567: number
const KEY_braille_dots_1245678: number
const KEY_braille_dots_124568: number
const KEY_braille_dots_12457: number
const KEY_braille_dots_124578: number
const KEY_braille_dots_12458: number
const KEY_braille_dots_1246: number
const KEY_braille_dots_12467: number
const KEY_braille_dots_124678: number
const KEY_braille_dots_12468: number
const KEY_braille_dots_1247: number
const KEY_braille_dots_12478: number
const KEY_braille_dots_1248: number
const KEY_braille_dots_125: number
const KEY_braille_dots_1256: number
const KEY_braille_dots_12567: number
const KEY_braille_dots_125678: number
const KEY_braille_dots_12568: number
const KEY_braille_dots_1257: number
const KEY_braille_dots_12578: number
const KEY_braille_dots_1258: number
const KEY_braille_dots_126: number
const KEY_braille_dots_1267: number
const KEY_braille_dots_12678: number
const KEY_braille_dots_1268: number
const KEY_braille_dots_127: number
const KEY_braille_dots_1278: number
const KEY_braille_dots_128: number
const KEY_braille_dots_13: number
const KEY_braille_dots_134: number
const KEY_braille_dots_1345: number
const KEY_braille_dots_13456: number
const KEY_braille_dots_134567: number
const KEY_braille_dots_1345678: number
const KEY_braille_dots_134568: number
const KEY_braille_dots_13457: number
const KEY_braille_dots_134578: number
const KEY_braille_dots_13458: number
const KEY_braille_dots_1346: number
const KEY_braille_dots_13467: number
const KEY_braille_dots_134678: number
const KEY_braille_dots_13468: number
const KEY_braille_dots_1347: number
const KEY_braille_dots_13478: number
const KEY_braille_dots_1348: number
const KEY_braille_dots_135: number
const KEY_braille_dots_1356: number
const KEY_braille_dots_13567: number
const KEY_braille_dots_135678: number
const KEY_braille_dots_13568: number
const KEY_braille_dots_1357: number
const KEY_braille_dots_13578: number
const KEY_braille_dots_1358: number
const KEY_braille_dots_136: number
const KEY_braille_dots_1367: number
const KEY_braille_dots_13678: number
const KEY_braille_dots_1368: number
const KEY_braille_dots_137: number
const KEY_braille_dots_1378: number
const KEY_braille_dots_138: number
const KEY_braille_dots_14: number
const KEY_braille_dots_145: number
const KEY_braille_dots_1456: number
const KEY_braille_dots_14567: number
const KEY_braille_dots_145678: number
const KEY_braille_dots_14568: number
const KEY_braille_dots_1457: number
const KEY_braille_dots_14578: number
const KEY_braille_dots_1458: number
const KEY_braille_dots_146: number
const KEY_braille_dots_1467: number
const KEY_braille_dots_14678: number
const KEY_braille_dots_1468: number
const KEY_braille_dots_147: number
const KEY_braille_dots_1478: number
const KEY_braille_dots_148: number
const KEY_braille_dots_15: number
const KEY_braille_dots_156: number
const KEY_braille_dots_1567: number
const KEY_braille_dots_15678: number
const KEY_braille_dots_1568: number
const KEY_braille_dots_157: number
const KEY_braille_dots_1578: number
const KEY_braille_dots_158: number
const KEY_braille_dots_16: number
const KEY_braille_dots_167: number
const KEY_braille_dots_1678: number
const KEY_braille_dots_168: number
const KEY_braille_dots_17: number
const KEY_braille_dots_178: number
const KEY_braille_dots_18: number
const KEY_braille_dots_2: number
const KEY_braille_dots_23: number
const KEY_braille_dots_234: number
const KEY_braille_dots_2345: number
const KEY_braille_dots_23456: number
const KEY_braille_dots_234567: number
const KEY_braille_dots_2345678: number
const KEY_braille_dots_234568: number
const KEY_braille_dots_23457: number
const KEY_braille_dots_234578: number
const KEY_braille_dots_23458: number
const KEY_braille_dots_2346: number
const KEY_braille_dots_23467: number
const KEY_braille_dots_234678: number
const KEY_braille_dots_23468: number
const KEY_braille_dots_2347: number
const KEY_braille_dots_23478: number
const KEY_braille_dots_2348: number
const KEY_braille_dots_235: number
const KEY_braille_dots_2356: number
const KEY_braille_dots_23567: number
const KEY_braille_dots_235678: number
const KEY_braille_dots_23568: number
const KEY_braille_dots_2357: number
const KEY_braille_dots_23578: number
const KEY_braille_dots_2358: number
const KEY_braille_dots_236: number
const KEY_braille_dots_2367: number
const KEY_braille_dots_23678: number
const KEY_braille_dots_2368: number
const KEY_braille_dots_237: number
const KEY_braille_dots_2378: number
const KEY_braille_dots_238: number
const KEY_braille_dots_24: number
const KEY_braille_dots_245: number
const KEY_braille_dots_2456: number
const KEY_braille_dots_24567: number
const KEY_braille_dots_245678: number
const KEY_braille_dots_24568: number
const KEY_braille_dots_2457: number
const KEY_braille_dots_24578: number
const KEY_braille_dots_2458: number
const KEY_braille_dots_246: number
const KEY_braille_dots_2467: number
const KEY_braille_dots_24678: number
const KEY_braille_dots_2468: number
const KEY_braille_dots_247: number
const KEY_braille_dots_2478: number
const KEY_braille_dots_248: number
const KEY_braille_dots_25: number
const KEY_braille_dots_256: number
const KEY_braille_dots_2567: number
const KEY_braille_dots_25678: number
const KEY_braille_dots_2568: number
const KEY_braille_dots_257: number
const KEY_braille_dots_2578: number
const KEY_braille_dots_258: number
const KEY_braille_dots_26: number
const KEY_braille_dots_267: number
const KEY_braille_dots_2678: number
const KEY_braille_dots_268: number
const KEY_braille_dots_27: number
const KEY_braille_dots_278: number
const KEY_braille_dots_28: number
const KEY_braille_dots_3: number
const KEY_braille_dots_34: number
const KEY_braille_dots_345: number
const KEY_braille_dots_3456: number
const KEY_braille_dots_34567: number
const KEY_braille_dots_345678: number
const KEY_braille_dots_34568: number
const KEY_braille_dots_3457: number
const KEY_braille_dots_34578: number
const KEY_braille_dots_3458: number
const KEY_braille_dots_346: number
const KEY_braille_dots_3467: number
const KEY_braille_dots_34678: number
const KEY_braille_dots_3468: number
const KEY_braille_dots_347: number
const KEY_braille_dots_3478: number
const KEY_braille_dots_348: number
const KEY_braille_dots_35: number
const KEY_braille_dots_356: number
const KEY_braille_dots_3567: number
const KEY_braille_dots_35678: number
const KEY_braille_dots_3568: number
const KEY_braille_dots_357: number
const KEY_braille_dots_3578: number
const KEY_braille_dots_358: number
const KEY_braille_dots_36: number
const KEY_braille_dots_367: number
const KEY_braille_dots_3678: number
const KEY_braille_dots_368: number
const KEY_braille_dots_37: number
const KEY_braille_dots_378: number
const KEY_braille_dots_38: number
const KEY_braille_dots_4: number
const KEY_braille_dots_45: number
const KEY_braille_dots_456: number
const KEY_braille_dots_4567: number
const KEY_braille_dots_45678: number
const KEY_braille_dots_4568: number
const KEY_braille_dots_457: number
const KEY_braille_dots_4578: number
const KEY_braille_dots_458: number
const KEY_braille_dots_46: number
const KEY_braille_dots_467: number
const KEY_braille_dots_4678: number
const KEY_braille_dots_468: number
const KEY_braille_dots_47: number
const KEY_braille_dots_478: number
const KEY_braille_dots_48: number
const KEY_braille_dots_5: number
const KEY_braille_dots_56: number
const KEY_braille_dots_567: number
const KEY_braille_dots_5678: number
const KEY_braille_dots_568: number
const KEY_braille_dots_57: number
const KEY_braille_dots_578: number
const KEY_braille_dots_58: number
const KEY_braille_dots_6: number
const KEY_braille_dots_67: number
const KEY_braille_dots_678: number
const KEY_braille_dots_68: number
const KEY_braille_dots_7: number
const KEY_braille_dots_78: number
const KEY_braille_dots_8: number
const KEY_breve: number
const KEY_brokenbar: number
const KEY_c: number
const KEY_c_h: number
const KEY_cabovedot: number
const KEY_cacute: number
const KEY_careof: number
const KEY_caret: number
const KEY_caron: number
const KEY_ccaron: number
const KEY_ccedilla: number
const KEY_ccircumflex: number
const KEY_cedilla: number
const KEY_cent: number
const KEY_ch: number
const KEY_checkerboard: number
const KEY_checkmark: number
const KEY_circle: number
const KEY_club: number
const KEY_colon: number
const KEY_comma: number
const KEY_containsas: number
const KEY_copyright: number
const KEY_cr: number
const KEY_crossinglines: number
const KEY_cuberoot: number
const KEY_currency: number
const KEY_cursor: number
const KEY_d: number
const KEY_dabovedot: number
const KEY_dagger: number
const KEY_dcaron: number
const KEY_dead_A: number
const KEY_dead_E: number
const KEY_dead_I: number
const KEY_dead_O: number
const KEY_dead_U: number
const KEY_dead_a: number
const KEY_dead_abovecomma: number
const KEY_dead_abovedot: number
const KEY_dead_abovereversedcomma: number
const KEY_dead_abovering: number
const KEY_dead_aboveverticalline: number
const KEY_dead_acute: number
const KEY_dead_belowbreve: number
const KEY_dead_belowcircumflex: number
const KEY_dead_belowcomma: number
const KEY_dead_belowdiaeresis: number
const KEY_dead_belowdot: number
const KEY_dead_belowmacron: number
const KEY_dead_belowring: number
const KEY_dead_belowtilde: number
const KEY_dead_belowverticalline: number
const KEY_dead_breve: number
const KEY_dead_capital_schwa: number
const KEY_dead_caron: number
const KEY_dead_cedilla: number
const KEY_dead_circumflex: number
const KEY_dead_currency: number
const KEY_dead_dasia: number
const KEY_dead_diaeresis: number
const KEY_dead_doubleacute: number
const KEY_dead_doublegrave: number
const KEY_dead_e: number
const KEY_dead_grave: number
const KEY_dead_greek: number
const KEY_dead_hook: number
const KEY_dead_horn: number
const KEY_dead_i: number
const KEY_dead_invertedbreve: number
const KEY_dead_iota: number
const KEY_dead_longsolidusoverlay: number
const KEY_dead_lowline: number
const KEY_dead_macron: number
const KEY_dead_o: number
const KEY_dead_ogonek: number
const KEY_dead_perispomeni: number
const KEY_dead_psili: number
const KEY_dead_semivoiced_sound: number
const KEY_dead_small_schwa: number
const KEY_dead_stroke: number
const KEY_dead_tilde: number
const KEY_dead_u: number
const KEY_dead_voiced_sound: number
const KEY_decimalpoint: number
const KEY_degree: number
const KEY_diaeresis: number
const KEY_diamond: number
const KEY_digitspace: number
const KEY_dintegral: number
const KEY_division: number
const KEY_dollar: number
const KEY_doubbaselinedot: number
const KEY_doubleacute: number
const KEY_doubledagger: number
const KEY_doublelowquotemark: number
const KEY_downarrow: number
const KEY_downcaret: number
const KEY_downshoe: number
const KEY_downstile: number
const KEY_downtack: number
const KEY_dstroke: number
const KEY_e: number
const KEY_eabovedot: number
const KEY_eacute: number
const KEY_ebelowdot: number
const KEY_ecaron: number
const KEY_ecircumflex: number
const KEY_ecircumflexacute: number
const KEY_ecircumflexbelowdot: number
const KEY_ecircumflexgrave: number
const KEY_ecircumflexhook: number
const KEY_ecircumflextilde: number
const KEY_ediaeresis: number
const KEY_egrave: number
const KEY_ehook: number
const KEY_eightsubscript: number
const KEY_eightsuperior: number
const KEY_elementof: number
const KEY_ellipsis: number
const KEY_em3space: number
const KEY_em4space: number
const KEY_emacron: number
const KEY_emdash: number
const KEY_emfilledcircle: number
const KEY_emfilledrect: number
const KEY_emopencircle: number
const KEY_emopenrectangle: number
const KEY_emptyset: number
const KEY_emspace: number
const KEY_endash: number
const KEY_enfilledcircbullet: number
const KEY_enfilledsqbullet: number
const KEY_eng: number
const KEY_enopencircbullet: number
const KEY_enopensquarebullet: number
const KEY_enspace: number
const KEY_eogonek: number
const KEY_equal: number
const KEY_eth: number
const KEY_etilde: number
const KEY_exclam: number
const KEY_exclamdown: number
const KEY_ezh: number
const KEY_f: number
const KEY_fabovedot: number
const KEY_femalesymbol: number
const KEY_ff: number
const KEY_figdash: number
const KEY_filledlefttribullet: number
const KEY_filledrectbullet: number
const KEY_filledrighttribullet: number
const KEY_filledtribulletdown: number
const KEY_filledtribulletup: number
const KEY_fiveeighths: number
const KEY_fivesixths: number
const KEY_fivesubscript: number
const KEY_fivesuperior: number
const KEY_fourfifths: number
const KEY_foursubscript: number
const KEY_foursuperior: number
const KEY_fourthroot: number
const KEY_function: number
const KEY_g: number
const KEY_gabovedot: number
const KEY_gbreve: number
const KEY_gcaron: number
const KEY_gcedilla: number
const KEY_gcircumflex: number
const KEY_grave: number
const KEY_greater: number
const KEY_greaterthanequal: number
const KEY_guillemotleft: number
const KEY_guillemotright: number
const KEY_h: number
const KEY_hairspace: number
const KEY_hcircumflex: number
const KEY_heart: number
const KEY_hebrew_aleph: number
const KEY_hebrew_ayin: number
const KEY_hebrew_bet: number
const KEY_hebrew_beth: number
const KEY_hebrew_chet: number
const KEY_hebrew_dalet: number
const KEY_hebrew_daleth: number
const KEY_hebrew_doublelowline: number
const KEY_hebrew_finalkaph: number
const KEY_hebrew_finalmem: number
const KEY_hebrew_finalnun: number
const KEY_hebrew_finalpe: number
const KEY_hebrew_finalzade: number
const KEY_hebrew_finalzadi: number
const KEY_hebrew_gimel: number
const KEY_hebrew_gimmel: number
const KEY_hebrew_he: number
const KEY_hebrew_het: number
const KEY_hebrew_kaph: number
const KEY_hebrew_kuf: number
const KEY_hebrew_lamed: number
const KEY_hebrew_mem: number
const KEY_hebrew_nun: number
const KEY_hebrew_pe: number
const KEY_hebrew_qoph: number
const KEY_hebrew_resh: number
const KEY_hebrew_samech: number
const KEY_hebrew_samekh: number
const KEY_hebrew_shin: number
const KEY_hebrew_taf: number
const KEY_hebrew_taw: number
const KEY_hebrew_tet: number
const KEY_hebrew_teth: number
const KEY_hebrew_waw: number
const KEY_hebrew_yod: number
const KEY_hebrew_zade: number
const KEY_hebrew_zadi: number
const KEY_hebrew_zain: number
const KEY_hebrew_zayin: number
const KEY_hexagram: number
const KEY_horizconnector: number
const KEY_horizlinescan1: number
const KEY_horizlinescan3: number
const KEY_horizlinescan5: number
const KEY_horizlinescan7: number
const KEY_horizlinescan9: number
const KEY_hstroke: number
const KEY_ht: number
const KEY_hyphen: number
const KEY_i: number
const KEY_iTouch: number
const KEY_iacute: number
const KEY_ibelowdot: number
const KEY_ibreve: number
const KEY_icircumflex: number
const KEY_identical: number
const KEY_idiaeresis: number
const KEY_idotless: number
const KEY_ifonlyif: number
const KEY_igrave: number
const KEY_ihook: number
const KEY_imacron: number
const KEY_implies: number
const KEY_includedin: number
const KEY_includes: number
const KEY_infinity: number
const KEY_integral: number
const KEY_intersection: number
const KEY_iogonek: number
const KEY_itilde: number
const KEY_j: number
const KEY_jcircumflex: number
const KEY_jot: number
const KEY_k: number
const KEY_kana_A: number
const KEY_kana_CHI: number
const KEY_kana_E: number
const KEY_kana_FU: number
const KEY_kana_HA: number
const KEY_kana_HE: number
const KEY_kana_HI: number
const KEY_kana_HO: number
const KEY_kana_HU: number
const KEY_kana_I: number
const KEY_kana_KA: number
const KEY_kana_KE: number
const KEY_kana_KI: number
const KEY_kana_KO: number
const KEY_kana_KU: number
const KEY_kana_MA: number
const KEY_kana_ME: number
const KEY_kana_MI: number
const KEY_kana_MO: number
const KEY_kana_MU: number
const KEY_kana_N: number
const KEY_kana_NA: number
const KEY_kana_NE: number
const KEY_kana_NI: number
const KEY_kana_NO: number
const KEY_kana_NU: number
const KEY_kana_O: number
const KEY_kana_RA: number
const KEY_kana_RE: number
const KEY_kana_RI: number
const KEY_kana_RO: number
const KEY_kana_RU: number
const KEY_kana_SA: number
const KEY_kana_SE: number
const KEY_kana_SHI: number
const KEY_kana_SO: number
const KEY_kana_SU: number
const KEY_kana_TA: number
const KEY_kana_TE: number
const KEY_kana_TI: number
const KEY_kana_TO: number
const KEY_kana_TSU: number
const KEY_kana_TU: number
const KEY_kana_U: number
const KEY_kana_WA: number
const KEY_kana_WO: number
const KEY_kana_YA: number
const KEY_kana_YO: number
const KEY_kana_YU: number
const KEY_kana_a: number
const KEY_kana_closingbracket: number
const KEY_kana_comma: number
const KEY_kana_conjunctive: number
const KEY_kana_e: number
const KEY_kana_fullstop: number
const KEY_kana_i: number
const KEY_kana_middledot: number
const KEY_kana_o: number
const KEY_kana_openingbracket: number
const KEY_kana_switch: number
const KEY_kana_tsu: number
const KEY_kana_tu: number
const KEY_kana_u: number
const KEY_kana_ya: number
const KEY_kana_yo: number
const KEY_kana_yu: number
const KEY_kappa: number
const KEY_kcedilla: number
const KEY_kra: number
const KEY_l: number
const KEY_lacute: number
const KEY_latincross: number
const KEY_lbelowdot: number
const KEY_lcaron: number
const KEY_lcedilla: number
const KEY_leftanglebracket: number
const KEY_leftarrow: number
const KEY_leftcaret: number
const KEY_leftdoublequotemark: number
const KEY_leftmiddlecurlybrace: number
const KEY_leftopentriangle: number
const KEY_leftpointer: number
const KEY_leftradical: number
const KEY_leftshoe: number
const KEY_leftsinglequotemark: number
const KEY_leftt: number
const KEY_lefttack: number
const KEY_less: number
const KEY_lessthanequal: number
const KEY_lf: number
const KEY_logicaland: number
const KEY_logicalor: number
const KEY_lowleftcorner: number
const KEY_lowrightcorner: number
const KEY_lstroke: number
const KEY_m: number
const KEY_mabovedot: number
const KEY_macron: number
const KEY_malesymbol: number
const KEY_maltesecross: number
const KEY_marker: number
const KEY_masculine: number
const KEY_minus: number
const KEY_minutes: number
const KEY_mu: number
const KEY_multiply: number
const KEY_musicalflat: number
const KEY_musicalsharp: number
const KEY_n: number
const KEY_nabla: number
const KEY_nacute: number
const KEY_ncaron: number
const KEY_ncedilla: number
const KEY_ninesubscript: number
const KEY_ninesuperior: number
const KEY_nl: number
const KEY_nobreakspace: number
const KEY_notapproxeq: number
const KEY_notelementof: number
const KEY_notequal: number
const KEY_notidentical: number
const KEY_notsign: number
const KEY_ntilde: number
const KEY_numbersign: number
const KEY_numerosign: number
const KEY_o: number
const KEY_oacute: number
const KEY_obarred: number
const KEY_obelowdot: number
const KEY_ocaron: number
const KEY_ocircumflex: number
const KEY_ocircumflexacute: number
const KEY_ocircumflexbelowdot: number
const KEY_ocircumflexgrave: number
const KEY_ocircumflexhook: number
const KEY_ocircumflextilde: number
const KEY_odiaeresis: number
const KEY_odoubleacute: number
const KEY_oe: number
const KEY_ogonek: number
const KEY_ograve: number
const KEY_ohook: number
const KEY_ohorn: number
const KEY_ohornacute: number
const KEY_ohornbelowdot: number
const KEY_ohorngrave: number
const KEY_ohornhook: number
const KEY_ohorntilde: number
const KEY_omacron: number
const KEY_oneeighth: number
const KEY_onefifth: number
const KEY_onehalf: number
const KEY_onequarter: number
const KEY_onesixth: number
const KEY_onesubscript: number
const KEY_onesuperior: number
const KEY_onethird: number
const KEY_ooblique: number
const KEY_openrectbullet: number
const KEY_openstar: number
const KEY_opentribulletdown: number
const KEY_opentribulletup: number
const KEY_ordfeminine: number
const KEY_oslash: number
const KEY_otilde: number
const KEY_overbar: number
const KEY_overline: number
const KEY_p: number
const KEY_pabovedot: number
const KEY_paragraph: number
const KEY_parenleft: number
const KEY_parenright: number
const KEY_partdifferential: number
const KEY_partialderivative: number
const KEY_percent: number
const KEY_period: number
const KEY_periodcentered: number
const KEY_permille: number
const KEY_phonographcopyright: number
const KEY_plus: number
const KEY_plusminus: number
const KEY_prescription: number
const KEY_prolongedsound: number
const KEY_punctspace: number
const KEY_q: number
const KEY_quad: number
const KEY_question: number
const KEY_questiondown: number
const KEY_quotedbl: number
const KEY_quoteleft: number
const KEY_quoteright: number
const KEY_r: number
const KEY_racute: number
const KEY_radical: number
const KEY_rcaron: number
const KEY_rcedilla: number
const KEY_registered: number
const KEY_rightanglebracket: number
const KEY_rightarrow: number
const KEY_rightcaret: number
const KEY_rightdoublequotemark: number
const KEY_rightmiddlecurlybrace: number
const KEY_rightmiddlesummation: number
const KEY_rightopentriangle: number
const KEY_rightpointer: number
const KEY_rightshoe: number
const KEY_rightsinglequotemark: number
const KEY_rightt: number
const KEY_righttack: number
const KEY_s: number
const KEY_sabovedot: number
const KEY_sacute: number
const KEY_scaron: number
const KEY_scedilla: number
const KEY_schwa: number
const KEY_scircumflex: number
const KEY_script_switch: number
const KEY_seconds: number
const KEY_section: number
const KEY_semicolon: number
const KEY_semivoicedsound: number
const KEY_seveneighths: number
const KEY_sevensubscript: number
const KEY_sevensuperior: number
const KEY_signaturemark: number
const KEY_signifblank: number
const KEY_similarequal: number
const KEY_singlelowquotemark: number
const KEY_sixsubscript: number
const KEY_sixsuperior: number
const KEY_slash: number
const KEY_soliddiamond: number
const KEY_space: number
const KEY_squareroot: number
const KEY_ssharp: number
const KEY_sterling: number
const KEY_stricteq: number
const KEY_t: number
const KEY_tabovedot: number
const KEY_tcaron: number
const KEY_tcedilla: number
const KEY_telephone: number
const KEY_telephonerecorder: number
const KEY_therefore: number
const KEY_thinspace: number
const KEY_thorn: number
const KEY_threeeighths: number
const KEY_threefifths: number
const KEY_threequarters: number
const KEY_threesubscript: number
const KEY_threesuperior: number
const KEY_tintegral: number
const KEY_topintegral: number
const KEY_topleftparens: number
const KEY_topleftradical: number
const KEY_topleftsqbracket: number
const KEY_topleftsummation: number
const KEY_toprightparens: number
const KEY_toprightsqbracket: number
const KEY_toprightsummation: number
const KEY_topt: number
const KEY_topvertsummationconnector: number
const KEY_trademark: number
const KEY_trademarkincircle: number
const KEY_tslash: number
const KEY_twofifths: number
const KEY_twosubscript: number
const KEY_twosuperior: number
const KEY_twothirds: number
const KEY_u: number
const KEY_uacute: number
const KEY_ubelowdot: number
const KEY_ubreve: number
const KEY_ucircumflex: number
const KEY_udiaeresis: number
const KEY_udoubleacute: number
const KEY_ugrave: number
const KEY_uhook: number
const KEY_uhorn: number
const KEY_uhornacute: number
const KEY_uhornbelowdot: number
const KEY_uhorngrave: number
const KEY_uhornhook: number
const KEY_uhorntilde: number
const KEY_umacron: number
const KEY_underbar: number
const KEY_underscore: number
const KEY_union: number
const KEY_uogonek: number
const KEY_uparrow: number
const KEY_upcaret: number
const KEY_upleftcorner: number
const KEY_uprightcorner: number
const KEY_upshoe: number
const KEY_upstile: number
const KEY_uptack: number
const KEY_uring: number
const KEY_utilde: number
const KEY_v: number
const KEY_variation: number
const KEY_vertbar: number
const KEY_vertconnector: number
const KEY_voicedsound: number
const KEY_vt: number
const KEY_w: number
const KEY_wacute: number
const KEY_wcircumflex: number
const KEY_wdiaeresis: number
const KEY_wgrave: number
const KEY_x: number
const KEY_xabovedot: number
const KEY_y: number
const KEY_yacute: number
const KEY_ybelowdot: number
const KEY_ycircumflex: number
const KEY_ydiaeresis: number
const KEY_yen: number
const KEY_ygrave: number
const KEY_yhook: number
const KEY_ytilde: number
const KEY_z: number
const KEY_zabovedot: number
const KEY_zacute: number
const KEY_zcaron: number
const KEY_zerosubscript: number
const KEY_zerosuperior: number
const KEY_zstroke: number
const KP_0: number
const KP_1: number
const KP_2: number
const KP_3: number
const KP_4: number
const KP_5: number
const KP_6: number
const KP_7: number
const KP_8: number
const KP_9: number
const KP_Add: number
const KP_Begin: number
const KP_Decimal: number
const KP_Delete: number
const KP_Divide: number
const KP_Down: number
const KP_End: number
const KP_Enter: number
const KP_Equal: number
const KP_F1: number
const KP_F2: number
const KP_F3: number
const KP_F4: number
const KP_Home: number
const KP_Insert: number
const KP_Left: number
const KP_Multiply: number
const KP_Next: number
const KP_Page_Down: number
const KP_Page_Up: number
const KP_Prior: number
const KP_Right: number
const KP_Separator: number
const KP_Space: number
const KP_Subtract: number
const KP_Tab: number
const KP_Up: number
const Kana_Lock: number
const Kana_Shift: number
const Kanji: number
const Kanji_Bangou: number
const Katakana: number
const KbdBrightnessDown: number
const KbdBrightnessUp: number
const KbdLightOnOff: number
const Kcedilla: number
const Korean_Won: number
const L: number
const L1: number
const L10: number
const L2: number
const L3: number
const L4: number
const L5: number
const L6: number
const L7: number
const L8: number
const L9: number
const Lacute: number
const Last_Virtual_Screen: number
const Launch0: number
const Launch1: number
const Launch2: number
const Launch3: number
const Launch4: number
const Launch5: number
const Launch6: number
const Launch7: number
const Launch8: number
const Launch9: number
const LaunchA: number
const LaunchB: number
const LaunchC: number
const LaunchD: number
const LaunchE: number
const LaunchF: number
const Lbelowdot: number
const Lcaron: number
const Lcedilla: number
const Left: number
const LightBulb: number
const Linefeed: number
const LiraSign: number
const LogGrabInfo: number
const LogOff: number
const LogWindowTree: number
const Lstroke: number
const M: number
/**
 * The major version of the Clutter library (1, if %CLUTTER_VERSION is 1.2.3)
 */
const MAJOR_VERSION: number
/**
 * The micro version of the Clutter library (3, if %CLUTTER_VERSION is 1.2.3)
 */
const MICRO_VERSION: number
/**
 * The minor version of the Clutter library (2, if %CLUTTER_VERSION is 1.2.3)
 */
const MINOR_VERSION: number
const Mabovedot: number
const Macedonia_DSE: number
const Macedonia_GJE: number
const Macedonia_KJE: number
const Macedonia_dse: number
const Macedonia_gje: number
const Macedonia_kje: number
const Mae_Koho: number
const Mail: number
const MailForward: number
const Market: number
const Massyo: number
const Meeting: number
const Memo: number
const Menu: number
const MenuKB: number
const MenuPB: number
const Messenger: number
const Meta_L: number
const Meta_R: number
const MillSign: number
const ModeLock: number
const Mode_switch: number
const MonBrightnessDown: number
const MonBrightnessUp: number
const MouseKeys_Accel_Enable: number
const MouseKeys_Enable: number
const Muhenkan: number
const Multi_key: number
const MultipleCandidate: number
const Music: number
const MyComputer: number
const MySites: number
const N: number
/**
 * Set to 1 if Clutter was built without FPU (i.e fixed math), 0 otherwise
 */
const NO_FPU: number
const Nacute: number
const NairaSign: number
const Ncaron: number
const Ncedilla: number
const New: number
const NewSheqelSign: number
const News: number
const Next: number
const Next_VMode: number
const Next_Virtual_Screen: number
const Ntilde: number
const Num_Lock: number
const O: number
const OE: number
const Oacute: number
const Obarred: number
const Obelowdot: number
const Ocaron: number
const Ocircumflex: number
const Ocircumflexacute: number
const Ocircumflexbelowdot: number
const Ocircumflexgrave: number
const Ocircumflexhook: number
const Ocircumflextilde: number
const Odiaeresis: number
const Odoubleacute: number
const OfficeHome: number
const Ograve: number
const Ohook: number
const Ohorn: number
const Ohornacute: number
const Ohornbelowdot: number
const Ohorngrave: number
const Ohornhook: number
const Ohorntilde: number
const Omacron: number
const Ooblique: number
const Open: number
const OpenURL: number
const Option: number
const Oslash: number
const Otilde: number
const Overlay1_Enable: number
const Overlay2_Enable: number
const P: number
const PATH_RELATIVE: number
/**
 * Priority of the redraws. This is chosen to be lower than the GTK+
 * redraw and resize priorities, because in application with both
 * GTK+ and Clutter it's more likely that the Clutter part will be
 * continually animating (and thus able to starve GTK+) than
 * vice-versa.
 */
const PRIORITY_REDRAW: number
const Pabovedot: number
const Page_Down: number
const Page_Up: number
const Paste: number
const Pause: number
const PesetaSign: number
const Phone: number
const Pictures: number
const Pointer_Accelerate: number
const Pointer_Button1: number
const Pointer_Button2: number
const Pointer_Button3: number
const Pointer_Button4: number
const Pointer_Button5: number
const Pointer_Button_Dflt: number
const Pointer_DblClick1: number
const Pointer_DblClick2: number
const Pointer_DblClick3: number
const Pointer_DblClick4: number
const Pointer_DblClick5: number
const Pointer_DblClick_Dflt: number
const Pointer_DfltBtnNext: number
const Pointer_DfltBtnPrev: number
const Pointer_Down: number
const Pointer_DownLeft: number
const Pointer_DownRight: number
const Pointer_Drag1: number
const Pointer_Drag2: number
const Pointer_Drag3: number
const Pointer_Drag4: number
const Pointer_Drag5: number
const Pointer_Drag_Dflt: number
const Pointer_EnableKeys: number
const Pointer_Left: number
const Pointer_Right: number
const Pointer_Up: number
const Pointer_UpLeft: number
const Pointer_UpRight: number
const PowerDown: number
const PowerOff: number
const Prev_VMode: number
const Prev_Virtual_Screen: number
const PreviousCandidate: number
const Print: number
const Prior: number
const Q: number
const R: number
const R1: number
const R10: number
const R11: number
const R12: number
const R13: number
const R14: number
const R15: number
const R2: number
const R3: number
const R4: number
const R5: number
const R6: number
const R7: number
const R8: number
const R9: number
const Racute: number
const Rcaron: number
const Rcedilla: number
const Red: number
const Redo: number
const Refresh: number
const Reload: number
const RepeatKeys_Enable: number
const Reply: number
const Return: number
const Right: number
const RockerDown: number
const RockerEnter: number
const RockerUp: number
const Romaji: number
const RotateWindows: number
const RotationKB: number
const RotationPB: number
const RupeeSign: number
const S: number
const SCHWA: number
/**
 * The default GObject type for the Clutter stage.
 */
const STAGE_TYPE: string
const Sabovedot: number
const Sacute: number
const Save: number
const Scaron: number
const Scedilla: number
const Scircumflex: number
const ScreenSaver: number
const ScrollClick: number
const ScrollDown: number
const ScrollUp: number
const Scroll_Lock: number
const Search: number
const Select: number
const SelectButton: number
const Send: number
const Serbian_DJE: number
const Serbian_DZE: number
const Serbian_JE: number
const Serbian_LJE: number
const Serbian_NJE: number
const Serbian_TSHE: number
const Serbian_dje: number
const Serbian_dze: number
const Serbian_je: number
const Serbian_lje: number
const Serbian_nje: number
const Serbian_tshe: number
const Shift_L: number
const Shift_Lock: number
const Shift_R: number
const Shop: number
const SingleCandidate: number
const Sinh_a: number
const Sinh_aa: number
const Sinh_aa2: number
const Sinh_ae: number
const Sinh_ae2: number
const Sinh_aee: number
const Sinh_aee2: number
const Sinh_ai: number
const Sinh_ai2: number
const Sinh_al: number
const Sinh_au: number
const Sinh_au2: number
const Sinh_ba: number
const Sinh_bha: number
const Sinh_ca: number
const Sinh_cha: number
const Sinh_dda: number
const Sinh_ddha: number
const Sinh_dha: number
const Sinh_dhha: number
const Sinh_e: number
const Sinh_e2: number
const Sinh_ee: number
const Sinh_ee2: number
const Sinh_fa: number
const Sinh_ga: number
const Sinh_gha: number
const Sinh_h2: number
const Sinh_ha: number
const Sinh_i: number
const Sinh_i2: number
const Sinh_ii: number
const Sinh_ii2: number
const Sinh_ja: number
const Sinh_jha: number
const Sinh_jnya: number
const Sinh_ka: number
const Sinh_kha: number
const Sinh_kunddaliya: number
const Sinh_la: number
const Sinh_lla: number
const Sinh_lu: number
const Sinh_lu2: number
const Sinh_luu: number
const Sinh_luu2: number
const Sinh_ma: number
const Sinh_mba: number
const Sinh_na: number
const Sinh_ndda: number
const Sinh_ndha: number
const Sinh_ng: number
const Sinh_ng2: number
const Sinh_nga: number
const Sinh_nja: number
const Sinh_nna: number
const Sinh_nya: number
const Sinh_o: number
const Sinh_o2: number
const Sinh_oo: number
const Sinh_oo2: number
const Sinh_pa: number
const Sinh_pha: number
const Sinh_ra: number
const Sinh_ri: number
const Sinh_rii: number
const Sinh_ru2: number
const Sinh_ruu2: number
const Sinh_sa: number
const Sinh_sha: number
const Sinh_ssha: number
const Sinh_tha: number
const Sinh_thha: number
const Sinh_tta: number
const Sinh_ttha: number
const Sinh_u: number
const Sinh_u2: number
const Sinh_uu: number
const Sinh_uu2: number
const Sinh_va: number
const Sinh_ya: number
const Sleep: number
const SlowKeys_Enable: number
const Spell: number
const SplitScreen: number
const Standby: number
const Start: number
const StickyKeys_Enable: number
const Stop: number
const Subtitle: number
const Super_L: number
const Super_R: number
const Support: number
const Suspend: number
const Switch_VT_1: number
const Switch_VT_10: number
const Switch_VT_11: number
const Switch_VT_12: number
const Switch_VT_2: number
const Switch_VT_3: number
const Switch_VT_4: number
const Switch_VT_5: number
const Switch_VT_6: number
const Switch_VT_7: number
const Switch_VT_8: number
const Switch_VT_9: number
const Sys_Req: number
const T: number
const THORN: number
const Tab: number
const Tabovedot: number
const TaskPane: number
const Tcaron: number
const Tcedilla: number
const Terminal: number
const Terminate_Server: number
const Thai_baht: number
const Thai_bobaimai: number
const Thai_chochan: number
const Thai_chochang: number
const Thai_choching: number
const Thai_chochoe: number
const Thai_dochada: number
const Thai_dodek: number
const Thai_fofa: number
const Thai_fofan: number
const Thai_hohip: number
const Thai_honokhuk: number
const Thai_khokhai: number
const Thai_khokhon: number
const Thai_khokhuat: number
const Thai_khokhwai: number
const Thai_khorakhang: number
const Thai_kokai: number
const Thai_lakkhangyao: number
const Thai_lekchet: number
const Thai_lekha: number
const Thai_lekhok: number
const Thai_lekkao: number
const Thai_leknung: number
const Thai_lekpaet: number
const Thai_leksam: number
const Thai_leksi: number
const Thai_leksong: number
const Thai_leksun: number
const Thai_lochula: number
const Thai_loling: number
const Thai_lu: number
const Thai_maichattawa: number
const Thai_maiek: number
const Thai_maihanakat: number
const Thai_maihanakat_maitho: number
const Thai_maitaikhu: number
const Thai_maitho: number
const Thai_maitri: number
const Thai_maiyamok: number
const Thai_moma: number
const Thai_ngongu: number
const Thai_nikhahit: number
const Thai_nonen: number
const Thai_nonu: number
const Thai_oang: number
const Thai_paiyannoi: number
const Thai_phinthu: number
const Thai_phophan: number
const Thai_phophung: number
const Thai_phosamphao: number
const Thai_popla: number
const Thai_rorua: number
const Thai_ru: number
const Thai_saraa: number
const Thai_saraaa: number
const Thai_saraae: number
const Thai_saraaimaimalai: number
const Thai_saraaimaimuan: number
const Thai_saraam: number
const Thai_sarae: number
const Thai_sarai: number
const Thai_saraii: number
const Thai_sarao: number
const Thai_sarau: number
const Thai_saraue: number
const Thai_sarauee: number
const Thai_sarauu: number
const Thai_sorusi: number
const Thai_sosala: number
const Thai_soso: number
const Thai_sosua: number
const Thai_thanthakhat: number
const Thai_thonangmontho: number
const Thai_thophuthao: number
const Thai_thothahan: number
const Thai_thothan: number
const Thai_thothong: number
const Thai_thothung: number
const Thai_topatak: number
const Thai_totao: number
const Thai_wowaen: number
const Thai_yoyak: number
const Thai_yoying: number
const Thorn: number
const Time: number
const ToDoList: number
const Tools: number
const TopMenu: number
const TouchpadOff: number
const TouchpadOn: number
const TouchpadToggle: number
const Touroku: number
const Travel: number
const Tslash: number
const U: number
const UWB: number
const Uacute: number
const Ubelowdot: number
const Ubreve: number
const Ucircumflex: number
const Udiaeresis: number
const Udoubleacute: number
const Ugrave: number
const Uhook: number
const Uhorn: number
const Uhornacute: number
const Uhornbelowdot: number
const Uhorngrave: number
const Uhornhook: number
const Uhorntilde: number
const Ukrainian_GHE_WITH_UPTURN: number
const Ukrainian_I: number
const Ukrainian_IE: number
const Ukrainian_YI: number
const Ukrainian_ghe_with_upturn: number
const Ukrainian_i: number
const Ukrainian_ie: number
const Ukrainian_yi: number
const Ukranian_I: number
const Ukranian_JE: number
const Ukranian_YI: number
const Ukranian_i: number
const Ukranian_je: number
const Ukranian_yi: number
const Umacron: number
const Undo: number
const Ungrab: number
const Uogonek: number
const Up: number
const Uring: number
const User1KB: number
const User2KB: number
const UserPB: number
const Utilde: number
const V: number
/**
 * The full version of the Clutter library, like 1.2.3
 */
const VERSION: number
/**
 * Numerically encoded version of the Clutter library, like 0x010203
 */
const VERSION_HEX: number
/**
 * The full version of the Clutter library, in string form (suited for
 * string concatenation)
 */
const VERSION_S: string
const VendorHome: number
const Video: number
const View: number
const VoidSymbol: number
const W: number
const WINDOWING_EGL: string
const WINDOWING_GDK: string
const WINDOWING_GLX: string
const WINDOWING_WAYLAND: string
const WINDOWING_X11: string
const WLAN: number
const WWW: number
const Wacute: number
const WakeUp: number
const Wcircumflex: number
const Wdiaeresis: number
const WebCam: number
const Wgrave: number
const WheelButton: number
const WindowClear: number
const WonSign: number
const Word: number
const X: number
const Xabovedot: number
const Xfer: number
const Y: number
const Yacute: number
const Ybelowdot: number
const Ycircumflex: number
const Ydiaeresis: number
const Yellow: number
const Ygrave: number
const Yhook: number
const Ytilde: number
const Z: number
const Zabovedot: number
const Zacute: number
const Zcaron: number
const Zen_Koho: number
const Zenkaku: number
const Zenkaku_Hankaku: number
const ZoomIn: number
const ZoomOut: number
const Zstroke: number
const a: number
const aacute: number
const abelowdot: number
const abovedot: number
const abreve: number
const abreveacute: number
const abrevebelowdot: number
const abrevegrave: number
const abrevehook: number
const abrevetilde: number
const acircumflex: number
const acircumflexacute: number
const acircumflexbelowdot: number
const acircumflexgrave: number
const acircumflexhook: number
const acircumflextilde: number
const acute: number
const adiaeresis: number
const ae: number
const agrave: number
const ahook: number
const amacron: number
const ampersand: number
const aogonek: number
const apostrophe: number
const approxeq: number
const approximate: number
const aring: number
const asciicircum: number
const asciitilde: number
const asterisk: number
const at: number
const atilde: number
const b: number
const babovedot: number
const backslash: number
const ballotcross: number
const bar: number
const because: number
const blank: number
const botintegral: number
const botleftparens: number
const botleftsqbracket: number
const botleftsummation: number
const botrightparens: number
const botrightsqbracket: number
const botrightsummation: number
const bott: number
const botvertsummationconnector: number
const braceleft: number
const braceright: number
const bracketleft: number
const bracketright: number
const braille_blank: number
const braille_dot_1: number
const braille_dot_10: number
const braille_dot_2: number
const braille_dot_3: number
const braille_dot_4: number
const braille_dot_5: number
const braille_dot_6: number
const braille_dot_7: number
const braille_dot_8: number
const braille_dot_9: number
const braille_dots_1: number
const braille_dots_12: number
const braille_dots_123: number
const braille_dots_1234: number
const braille_dots_12345: number
const braille_dots_123456: number
const braille_dots_1234567: number
const braille_dots_12345678: number
const braille_dots_1234568: number
const braille_dots_123457: number
const braille_dots_1234578: number
const braille_dots_123458: number
const braille_dots_12346: number
const braille_dots_123467: number
const braille_dots_1234678: number
const braille_dots_123468: number
const braille_dots_12347: number
const braille_dots_123478: number
const braille_dots_12348: number
const braille_dots_1235: number
const braille_dots_12356: number
const braille_dots_123567: number
const braille_dots_1235678: number
const braille_dots_123568: number
const braille_dots_12357: number
const braille_dots_123578: number
const braille_dots_12358: number
const braille_dots_1236: number
const braille_dots_12367: number
const braille_dots_123678: number
const braille_dots_12368: number
const braille_dots_1237: number
const braille_dots_12378: number
const braille_dots_1238: number
const braille_dots_124: number
const braille_dots_1245: number
const braille_dots_12456: number
const braille_dots_124567: number
const braille_dots_1245678: number
const braille_dots_124568: number
const braille_dots_12457: number
const braille_dots_124578: number
const braille_dots_12458: number
const braille_dots_1246: number
const braille_dots_12467: number
const braille_dots_124678: number
const braille_dots_12468: number
const braille_dots_1247: number
const braille_dots_12478: number
const braille_dots_1248: number
const braille_dots_125: number
const braille_dots_1256: number
const braille_dots_12567: number
const braille_dots_125678: number
const braille_dots_12568: number
const braille_dots_1257: number
const braille_dots_12578: number
const braille_dots_1258: number
const braille_dots_126: number
const braille_dots_1267: number
const braille_dots_12678: number
const braille_dots_1268: number
const braille_dots_127: number
const braille_dots_1278: number
const braille_dots_128: number
const braille_dots_13: number
const braille_dots_134: number
const braille_dots_1345: number
const braille_dots_13456: number
const braille_dots_134567: number
const braille_dots_1345678: number
const braille_dots_134568: number
const braille_dots_13457: number
const braille_dots_134578: number
const braille_dots_13458: number
const braille_dots_1346: number
const braille_dots_13467: number
const braille_dots_134678: number
const braille_dots_13468: number
const braille_dots_1347: number
const braille_dots_13478: number
const braille_dots_1348: number
const braille_dots_135: number
const braille_dots_1356: number
const braille_dots_13567: number
const braille_dots_135678: number
const braille_dots_13568: number
const braille_dots_1357: number
const braille_dots_13578: number
const braille_dots_1358: number
const braille_dots_136: number
const braille_dots_1367: number
const braille_dots_13678: number
const braille_dots_1368: number
const braille_dots_137: number
const braille_dots_1378: number
const braille_dots_138: number
const braille_dots_14: number
const braille_dots_145: number
const braille_dots_1456: number
const braille_dots_14567: number
const braille_dots_145678: number
const braille_dots_14568: number
const braille_dots_1457: number
const braille_dots_14578: number
const braille_dots_1458: number
const braille_dots_146: number
const braille_dots_1467: number
const braille_dots_14678: number
const braille_dots_1468: number
const braille_dots_147: number
const braille_dots_1478: number
const braille_dots_148: number
const braille_dots_15: number
const braille_dots_156: number
const braille_dots_1567: number
const braille_dots_15678: number
const braille_dots_1568: number
const braille_dots_157: number
const braille_dots_1578: number
const braille_dots_158: number
const braille_dots_16: number
const braille_dots_167: number
const braille_dots_1678: number
const braille_dots_168: number
const braille_dots_17: number
const braille_dots_178: number
const braille_dots_18: number
const braille_dots_2: number
const braille_dots_23: number
const braille_dots_234: number
const braille_dots_2345: number
const braille_dots_23456: number
const braille_dots_234567: number
const braille_dots_2345678: number
const braille_dots_234568: number
const braille_dots_23457: number
const braille_dots_234578: number
const braille_dots_23458: number
const braille_dots_2346: number
const braille_dots_23467: number
const braille_dots_234678: number
const braille_dots_23468: number
const braille_dots_2347: number
const braille_dots_23478: number
const braille_dots_2348: number
const braille_dots_235: number
const braille_dots_2356: number
const braille_dots_23567: number
const braille_dots_235678: number
const braille_dots_23568: number
const braille_dots_2357: number
const braille_dots_23578: number
const braille_dots_2358: number
const braille_dots_236: number
const braille_dots_2367: number
const braille_dots_23678: number
const braille_dots_2368: number
const braille_dots_237: number
const braille_dots_2378: number
const braille_dots_238: number
const braille_dots_24: number
const braille_dots_245: number
const braille_dots_2456: number
const braille_dots_24567: number
const braille_dots_245678: number
const braille_dots_24568: number
const braille_dots_2457: number
const braille_dots_24578: number
const braille_dots_2458: number
const braille_dots_246: number
const braille_dots_2467: number
const braille_dots_24678: number
const braille_dots_2468: number
const braille_dots_247: number
const braille_dots_2478: number
const braille_dots_248: number
const braille_dots_25: number
const braille_dots_256: number
const braille_dots_2567: number
const braille_dots_25678: number
const braille_dots_2568: number
const braille_dots_257: number
const braille_dots_2578: number
const braille_dots_258: number
const braille_dots_26: number
const braille_dots_267: number
const braille_dots_2678: number
const braille_dots_268: number
const braille_dots_27: number
const braille_dots_278: number
const braille_dots_28: number
const braille_dots_3: number
const braille_dots_34: number
const braille_dots_345: number
const braille_dots_3456: number
const braille_dots_34567: number
const braille_dots_345678: number
const braille_dots_34568: number
const braille_dots_3457: number
const braille_dots_34578: number
const braille_dots_3458: number
const braille_dots_346: number
const braille_dots_3467: number
const braille_dots_34678: number
const braille_dots_3468: number
const braille_dots_347: number
const braille_dots_3478: number
const braille_dots_348: number
const braille_dots_35: number
const braille_dots_356: number
const braille_dots_3567: number
const braille_dots_35678: number
const braille_dots_3568: number
const braille_dots_357: number
const braille_dots_3578: number
const braille_dots_358: number
const braille_dots_36: number
const braille_dots_367: number
const braille_dots_3678: number
const braille_dots_368: number
const braille_dots_37: number
const braille_dots_378: number
const braille_dots_38: number
const braille_dots_4: number
const braille_dots_45: number
const braille_dots_456: number
const braille_dots_4567: number
const braille_dots_45678: number
const braille_dots_4568: number
const braille_dots_457: number
const braille_dots_4578: number
const braille_dots_458: number
const braille_dots_46: number
const braille_dots_467: number
const braille_dots_4678: number
const braille_dots_468: number
const braille_dots_47: number
const braille_dots_478: number
const braille_dots_48: number
const braille_dots_5: number
const braille_dots_56: number
const braille_dots_567: number
const braille_dots_5678: number
const braille_dots_568: number
const braille_dots_57: number
const braille_dots_578: number
const braille_dots_58: number
const braille_dots_6: number
const braille_dots_67: number
const braille_dots_678: number
const braille_dots_68: number
const braille_dots_7: number
const braille_dots_78: number
const braille_dots_8: number
const breve: number
const brokenbar: number
const c: number
const c_h: number
const cabovedot: number
const cacute: number
const careof: number
const caret: number
const caron: number
const ccaron: number
const ccedilla: number
const ccircumflex: number
const cedilla: number
const cent: number
const ch: number
const checkerboard: number
const checkmark: number
const circle: number
const club: number
const colon: number
const comma: number
const containsas: number
const copyright: number
const cr: number
const crossinglines: number
const cuberoot: number
const currency: number
const cursor: number
const d: number
const dabovedot: number
const dagger: number
const dcaron: number
const dead_A: number
const dead_E: number
const dead_I: number
const dead_O: number
const dead_U: number
const dead_a: number
const dead_abovecomma: number
const dead_abovedot: number
const dead_abovereversedcomma: number
const dead_abovering: number
const dead_aboveverticalline: number
const dead_acute: number
const dead_belowbreve: number
const dead_belowcircumflex: number
const dead_belowcomma: number
const dead_belowdiaeresis: number
const dead_belowdot: number
const dead_belowmacron: number
const dead_belowring: number
const dead_belowtilde: number
const dead_belowverticalline: number
const dead_breve: number
const dead_capital_schwa: number
const dead_caron: number
const dead_cedilla: number
const dead_circumflex: number
const dead_currency: number
const dead_dasia: number
const dead_diaeresis: number
const dead_doubleacute: number
const dead_doublegrave: number
const dead_e: number
const dead_grave: number
const dead_greek: number
const dead_hook: number
const dead_horn: number
const dead_i: number
const dead_invertedbreve: number
const dead_iota: number
const dead_longsolidusoverlay: number
const dead_lowline: number
const dead_macron: number
const dead_o: number
const dead_ogonek: number
const dead_perispomeni: number
const dead_psili: number
const dead_semivoiced_sound: number
const dead_small_schwa: number
const dead_stroke: number
const dead_tilde: number
const dead_u: number
const dead_voiced_sound: number
const decimalpoint: number
const degree: number
const diaeresis: number
const diamond: number
const digitspace: number
const dintegral: number
const division: number
const dollar: number
const doubbaselinedot: number
const doubleacute: number
const doubledagger: number
const doublelowquotemark: number
const downarrow: number
const downcaret: number
const downshoe: number
const downstile: number
const downtack: number
const dstroke: number
const e: number
const eabovedot: number
const eacute: number
const ebelowdot: number
const ecaron: number
const ecircumflex: number
const ecircumflexacute: number
const ecircumflexbelowdot: number
const ecircumflexgrave: number
const ecircumflexhook: number
const ecircumflextilde: number
const ediaeresis: number
const egrave: number
const ehook: number
const eightsubscript: number
const eightsuperior: number
const elementof: number
const ellipsis: number
const em3space: number
const em4space: number
const emacron: number
const emdash: number
const emfilledcircle: number
const emfilledrect: number
const emopencircle: number
const emopenrectangle: number
const emptyset: number
const emspace: number
const endash: number
const enfilledcircbullet: number
const enfilledsqbullet: number
const eng: number
const enopencircbullet: number
const enopensquarebullet: number
const enspace: number
const eogonek: number
const equal: number
const eth: number
const etilde: number
const exclam: number
const exclamdown: number
const ezh: number
const f: number
const fabovedot: number
const femalesymbol: number
const ff: number
const figdash: number
const filledlefttribullet: number
const filledrectbullet: number
const filledrighttribullet: number
const filledtribulletdown: number
const filledtribulletup: number
const fiveeighths: number
const fivesixths: number
const fivesubscript: number
const fivesuperior: number
const fourfifths: number
const foursubscript: number
const foursuperior: number
const fourthroot: number
const function_: number
const g: number
const gabovedot: number
const gbreve: number
const gcaron: number
const gcedilla: number
const gcircumflex: number
const grave: number
const greater: number
const greaterthanequal: number
const guillemotleft: number
const guillemotright: number
const h: number
const hairspace: number
const hcircumflex: number
const heart: number
const hebrew_aleph: number
const hebrew_ayin: number
const hebrew_bet: number
const hebrew_beth: number
const hebrew_chet: number
const hebrew_dalet: number
const hebrew_daleth: number
const hebrew_doublelowline: number
const hebrew_finalkaph: number
const hebrew_finalmem: number
const hebrew_finalnun: number
const hebrew_finalpe: number
const hebrew_finalzade: number
const hebrew_finalzadi: number
const hebrew_gimel: number
const hebrew_gimmel: number
const hebrew_he: number
const hebrew_het: number
const hebrew_kaph: number
const hebrew_kuf: number
const hebrew_lamed: number
const hebrew_mem: number
const hebrew_nun: number
const hebrew_pe: number
const hebrew_qoph: number
const hebrew_resh: number
const hebrew_samech: number
const hebrew_samekh: number
const hebrew_shin: number
const hebrew_taf: number
const hebrew_taw: number
const hebrew_tet: number
const hebrew_teth: number
const hebrew_waw: number
const hebrew_yod: number
const hebrew_zade: number
const hebrew_zadi: number
const hebrew_zain: number
const hebrew_zayin: number
const hexagram: number
const horizconnector: number
const horizlinescan1: number
const horizlinescan3: number
const horizlinescan5: number
const horizlinescan7: number
const horizlinescan9: number
const hstroke: number
const ht: number
const hyphen: number
const i: number
const iTouch: number
const iacute: number
const ibelowdot: number
const ibreve: number
const icircumflex: number
const identical: number
const idiaeresis: number
const idotless: number
const ifonlyif: number
const igrave: number
const ihook: number
const imacron: number
const implies: number
const includedin: number
const includes: number
const infinity: number
const integral: number
const intersection: number
const iogonek: number
const itilde: number
const j: number
const jcircumflex: number
const jot: number
const k: number
const kana_A: number
const kana_CHI: number
const kana_E: number
const kana_FU: number
const kana_HA: number
const kana_HE: number
const kana_HI: number
const kana_HO: number
const kana_HU: number
const kana_I: number
const kana_KA: number
const kana_KE: number
const kana_KI: number
const kana_KO: number
const kana_KU: number
const kana_MA: number
const kana_ME: number
const kana_MI: number
const kana_MO: number
const kana_MU: number
const kana_N: number
const kana_NA: number
const kana_NE: number
const kana_NI: number
const kana_NO: number
const kana_NU: number
const kana_O: number
const kana_RA: number
const kana_RE: number
const kana_RI: number
const kana_RO: number
const kana_RU: number
const kana_SA: number
const kana_SE: number
const kana_SHI: number
const kana_SO: number
const kana_SU: number
const kana_TA: number
const kana_TE: number
const kana_TI: number
const kana_TO: number
const kana_TSU: number
const kana_TU: number
const kana_U: number
const kana_WA: number
const kana_WO: number
const kana_YA: number
const kana_YO: number
const kana_YU: number
const kana_a: number
const kana_closingbracket: number
const kana_comma: number
const kana_conjunctive: number
const kana_e: number
const kana_fullstop: number
const kana_i: number
const kana_middledot: number
const kana_o: number
const kana_openingbracket: number
const kana_switch: number
const kana_tsu: number
const kana_tu: number
const kana_u: number
const kana_ya: number
const kana_yo: number
const kana_yu: number
const kappa: number
const kcedilla: number
const kra: number
const l: number
const lacute: number
const latincross: number
const lbelowdot: number
const lcaron: number
const lcedilla: number
const leftanglebracket: number
const leftarrow: number
const leftcaret: number
const leftdoublequotemark: number
const leftmiddlecurlybrace: number
const leftopentriangle: number
const leftpointer: number
const leftradical: number
const leftshoe: number
const leftsinglequotemark: number
const leftt: number
const lefttack: number
const less: number
const lessthanequal: number
const lf: number
const logicaland: number
const logicalor: number
const lowleftcorner: number
const lowrightcorner: number
const lstroke: number
const m: number
const mabovedot: number
const macron: number
const malesymbol: number
const maltesecross: number
const marker: number
const masculine: number
const minus: number
const minutes: number
const mu: number
const multiply: number
const musicalflat: number
const musicalsharp: number
const n: number
const nabla: number
const nacute: number
const ncaron: number
const ncedilla: number
const ninesubscript: number
const ninesuperior: number
const nl: number
const nobreakspace: number
const notapproxeq: number
const notelementof: number
const notequal: number
const notidentical: number
const notsign: number
const ntilde: number
const numbersign: number
const numerosign: number
const o: number
const oacute: number
const obarred: number
const obelowdot: number
const ocaron: number
const ocircumflex: number
const ocircumflexacute: number
const ocircumflexbelowdot: number
const ocircumflexgrave: number
const ocircumflexhook: number
const ocircumflextilde: number
const odiaeresis: number
const odoubleacute: number
const oe: number
const ogonek: number
const ograve: number
const ohook: number
const ohorn: number
const ohornacute: number
const ohornbelowdot: number
const ohorngrave: number
const ohornhook: number
const ohorntilde: number
const omacron: number
const oneeighth: number
const onefifth: number
const onehalf: number
const onequarter: number
const onesixth: number
const onesubscript: number
const onesuperior: number
const onethird: number
const ooblique: number
const openrectbullet: number
const openstar: number
const opentribulletdown: number
const opentribulletup: number
const ordfeminine: number
const oslash: number
const otilde: number
const overbar: number
const overline: number
const p: number
const pabovedot: number
const paragraph: number
const parenleft: number
const parenright: number
const partdifferential: number
const partialderivative: number
const percent: number
const period: number
const periodcentered: number
const permille: number
const phonographcopyright: number
const plus: number
const plusminus: number
const prescription: number
const prolongedsound: number
const punctspace: number
const q: number
const quad: number
const question: number
const questiondown: number
const quotedbl: number
const quoteleft: number
const quoteright: number
const r: number
const racute: number
const radical: number
const rcaron: number
const rcedilla: number
const registered: number
const rightanglebracket: number
const rightarrow: number
const rightcaret: number
const rightdoublequotemark: number
const rightmiddlecurlybrace: number
const rightmiddlesummation: number
const rightopentriangle: number
const rightpointer: number
const rightshoe: number
const rightsinglequotemark: number
const rightt: number
const righttack: number
const s: number
const sabovedot: number
const sacute: number
const scaron: number
const scedilla: number
const schwa: number
const scircumflex: number
const script_switch: number
const seconds: number
const section: number
const semicolon: number
const semivoicedsound: number
const seveneighths: number
const sevensubscript: number
const sevensuperior: number
const signaturemark: number
const signifblank: number
const similarequal: number
const singlelowquotemark: number
const sixsubscript: number
const sixsuperior: number
const slash: number
const soliddiamond: number
const space: number
const squareroot: number
const ssharp: number
const sterling: number
const stricteq: number
const t: number
const tabovedot: number
const tcaron: number
const tcedilla: number
const telephone: number
const telephonerecorder: number
const therefore: number
const thinspace: number
const thorn: number
const threeeighths: number
const threefifths: number
const threequarters: number
const threesubscript: number
const threesuperior: number
const tintegral: number
const topintegral: number
const topleftparens: number
const topleftradical: number
const topleftsqbracket: number
const topleftsummation: number
const toprightparens: number
const toprightsqbracket: number
const toprightsummation: number
const topt: number
const topvertsummationconnector: number
const trademark: number
const trademarkincircle: number
const tslash: number
const twofifths: number
const twosubscript: number
const twosuperior: number
const twothirds: number
const u: number
const uacute: number
const ubelowdot: number
const ubreve: number
const ucircumflex: number
const udiaeresis: number
const udoubleacute: number
const ugrave: number
const uhook: number
const uhorn: number
const uhornacute: number
const uhornbelowdot: number
const uhorngrave: number
const uhornhook: number
const uhorntilde: number
const umacron: number
const underbar: number
const underscore: number
const union: number
const uogonek: number
const uparrow: number
const upcaret: number
const upleftcorner: number
const uprightcorner: number
const upshoe: number
const upstile: number
const uptack: number
const uring: number
const utilde: number
const v: number
const variation: number
const vertbar: number
const vertconnector: number
const voicedsound: number
const vt: number
const w: number
const wacute: number
const wcircumflex: number
const wdiaeresis: number
const wgrave: number
const x: number
const xabovedot: number
const y: number
const yacute: number
const ybelowdot: number
const ycircumflex: number
const ydiaeresis: number
const yen: number
const ygrave: number
const yhook: number
const ytilde: number
const z: number
const zabovedot: number
const zacute: number
const zcaron: number
const zerosubscript: number
const zerosuperior: number
const zstroke: number
function actorBoxAlloc(): ActorBox
function baseInit(): void
function cairoClear(cr: cairo.Context): void
function cairoSetSourceColor(cr: cairo.Context, color: Color): void
function checkVersion(major: number, minor: number, micro: number): boolean
function checkWindowingBackend(backendType: string): boolean
function clearGlyphCache(): void
function colorFromHls(hue: number, luminance: number, saturation: number): /* color */ Color
function colorFromPixel(pixel: number): /* color */ Color
function colorFromString(str: string): [ /* returnType */ boolean, /* color */ Color ]
function colorGetStatic(color: StaticColor): Color
function containerClassFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
function containerClassListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
function disableAccessibility(): void
function doEvent(event: Event): void
function eventAddFilter(stage: Stage | null, func: EventFilterFunc): number
function eventGet(): Event
function eventPeek(): Event
function eventRemoveFilter(id: number): void
function eventsPending(): boolean
function featureAvailable(feature: FeatureFlags): boolean
function featureGetAll(): FeatureFlags
function frameSourceAdd(priority: number, fps: number, func: GLib.SourceFunc): number
function getAccessibilityEnabled(): boolean
function getActorByGid(id: number): Actor
function getCurrentEvent(): Event
function getCurrentEventTime(): number
function getDebugEnabled(): boolean
function getDefaultBackend(): Backend
function getDefaultFrameRate(): number
function getDefaultTextDirection(): TextDirection
function getFontFlags(): FontFlags
function getFontMap(): Pango.FontMap
function getInputDeviceForId(id: number): InputDevice
function getKeyboardGrab(): Actor
function getMotionEventsEnabled(): boolean
function getPointerGrab(): Actor
function getScriptId(gobject: GObject.Object): string
function getShowFps(): boolean
function getTimestamp(): number
function grabKeyboard(actor: Actor): void
function grabPointer(actor: Actor): void
function grabPointerForDevice(actor: Actor, id: number): void
function imageErrorQuark(): GLib.Quark
function init(argv?: string[] | null): [ /* returnType */ InitError, /* argv */ string[] | null ]
function initErrorQuark(): GLib.Quark
function initWithArgs(argv?: string[] | null, parameterString?: string | null, entries?: GLib.OptionEntry[] | null, translationDomain?: string | null): [ /* returnType */ InitError, /* argv */ string[] | null ]
function keysymToUnicode(keyval: number): number
function main(): void
function mainLevel(): number
function mainQuit(): void
function matrixAlloc(): Matrix
function pointZero(): Point
function rectZero(): Rect
function redraw(stage: Stage): void
function scriptErrorQuark(): GLib.Quark
function setDefaultFrameRate(framesPerSec: number): void
function setFontFlags(flags: FontFlags): void
function setMotionEventsEnabled(enable: boolean): void
function setWindowingBackend(backendType: string): void
function shaderErrorQuark(): GLib.Quark
function testAddDataFull(testPath: string, testFunc: GLib.TestDataFunc): void
function testCheckActorAtPoint(stage: Actor, point: Point, actor: Actor): [ /* returnType */ boolean, /* result */ Actor | null ]
function testCheckColorAtPoint(stage: Actor, point: Point, color: Color): [ /* returnType */ boolean, /* result */ Color ]
function testGetStage(): Actor
function testInit(argc: number, argv: string): void
function testRun(): number
function textureErrorQuark(): GLib.Quark
function threadsAddFrameSource(priority: number, fps: number, func: GLib.SourceFunc): number
function threadsAddIdle(priority: number, func: GLib.SourceFunc): number
function threadsAddRepaintFunc(func: GLib.SourceFunc): number
function threadsAddRepaintFuncFull(flags: RepaintFlags, func: GLib.SourceFunc): number
function threadsAddTimeout(priority: number, interval: number, func: GLib.SourceFunc): number
function threadsEnter(): void
function threadsInit(): void
function threadsLeave(): void
function threadsRemoveRepaintFunc(handleId: number): void
function ungrabKeyboard(): void
function ungrabPointer(): void
function ungrabPointerForDevice(id: number): void
function unicodeToKeysym(wc: number): number
function unitsFromCm(cm: number): /* units */ Units
function unitsFromEm(em: number): /* units */ Units
function unitsFromEmForFont(fontName: string | null, em: number): /* units */ Units
function unitsFromMm(mm: number): /* units */ Units
function unitsFromPixels(px: number): /* units */ Units
function unitsFromPt(pt: number): /* units */ Units
function unitsFromString(str: string): [ /* returnType */ boolean, /* units */ Units ]
function utilNextP2(a: number): number
function valueDupPaintNode(value: any): PaintNode
function valueGetColor(value: any): Color
function valueGetPaintNode(value: any): PaintNode
function valueGetShaderFloat(value: any): number[]
function valueGetShaderInt(value: any): number[]
function valueGetShaderMatrix(value: any): number[]
function valueGetUnits(value: any): Units
function valueSetColor(value: any, color: Color): void
function valueSetPaintNode(value: any, node?: PaintNode | null): void
function valueSetShaderFloat(value: any, floats: number[]): void
function valueSetShaderInt(value: any, ints: number[]): void
function valueSetShaderMatrix(value: any, matrix: number[]): void
function valueSetUnits(value: any, units: Units): void
function valueTakePaintNode(value: any, node?: PaintNode | null): void
/**
 * Creates a #ClutterActor using the `item` in the model.
 * 
 * The usual way to implement this function is to create a #ClutterActor
 * instance and then bind the #GObject properties to the actor properties
 * of interest, using g_object_bind_property(). This way, when the `item`
 * in the #GListModel changes, the #ClutterActor changes as well.
 */
interface ActorCreateChildFunc {
    (item: GObject.Object): Actor
}
/**
 * A function returning a value depending on the position of
 * the #ClutterTimeline bound to `alpha`.
 */
interface AlphaFunc {
    (alpha: Alpha): number
}
/**
 * This function is passed to clutter_behaviour_actors_foreach() and
 * will be called for each actor driven by `behaviour`.
 */
interface BehaviourForeachFunc {
    (behaviour: Behaviour, actor: Actor): void
}
/**
 * The prototype for the callback function registered with
 * clutter_binding_pool_install_action() and invoked by
 * clutter_binding_pool_activate().
 */
interface BindingActionFunc {
    (gobject: GObject.Object, actionName: string, keyVal: number, modifiers: ModifierType): boolean
}
/**
 * Generic callback
 */
interface Callback {
    (actor: Actor): void
}
/**
 * A function pointer type used by event filters that are added with
 * clutter_event_add_filter().
 */
interface EventFilterFunc {
    (event: Event): boolean
}
/**
 * Filters the content of a row in the model.
 */
interface ModelFilterFunc {
    (model: Model, iter: ModelIter): boolean
}
/**
 * Iterates on the content of a row in the model
 */
interface ModelForeachFunc {
    (model: Model, iter: ModelIter): boolean
}
/**
 * Compares the content of two rows in the model.
 */
interface ModelSortFunc {
    (model: Model, a: any, b: any): number
}
/**
 * This function is passed to clutter_path_foreach() and will be
 * called for each node contained in the path.
 */
interface PathCallback {
    (node: PathNode): void
}
/**
 * Prototype of the progress function used to compute the value
 * between the two ends `a` and `b` of an interval depending on
 * the value of `progress`.
 * 
 * The #GValue in `retval` is already initialized with the same
 * type as `a` and `b`.
 * 
 * This function will be called by #ClutterInterval if the
 * type of the values of the interval was registered using
 * clutter_interval_register_progress_func().
 */
interface ProgressFunc {
    (a: any, b: any, progress: number, retval: any): boolean
}
/**
 * This is the signature of a function used to connect signals.  It is used
 * by the clutter_script_connect_signals_full() function.  It is mainly
 * intended for interpreted language bindings, but could be useful where the
 * programmer wants more control over the signal connection process.
 */
interface ScriptConnectFunc {
    (script: Script, object: GObject.Object, signalName: string, handlerName: string, connectObject: GObject.Object, flags: GObject.ConnectFlags): void
}
/**
 * A function for defining a custom progress.
 */
interface TimelineProgressFunc {
    (timeline: Timeline, elapsed: number, total: number): number
}
class Animatable {
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    static name: string
}
class Container {
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Retrieves all the children of `container`.
     */
    getChildren(): Actor[]
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
}
class Content {
    /* Methods of Clutter-1.0.Clutter.Content */
    /**
     * Retrieves the natural size of the `content,` if any.
     * 
     * The natural size of a #ClutterContent is defined as the size the content
     * would have regardless of the allocation of the actor that is painting it,
     * for instance the size of an image data.
     */
    getPreferredSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Invalidates a #ClutterContent.
     * 
     * This function should be called by #ClutterContent implementations when
     * they change the way a the content should be painted regardless of the
     * actor state.
     */
    invalidate(): void
    /* Signals of Clutter-1.0.Clutter.Content */
    /**
     * This signal is emitted each time a #ClutterContent implementation is
     * assigned to a #ClutterActor.
     */
    connect(sigName: "attached", callback: ((actor: Actor) => void)): number
    on(sigName: "attached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "attached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "attached", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "attached", actor: Actor): void
    /**
     * This signal is emitted each time a #ClutterContent implementation is
     * removed from a #ClutterActor.
     */
    connect(sigName: "detached", callback: ((actor: Actor) => void)): number
    on(sigName: "detached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "detached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "detached", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "detached", actor: Actor): void
    static name: string
}
class Media {
    /* Properties of Clutter-1.0.Clutter.Media */
    /**
     * The volume of the audio, as a normalized value between
     * 0.0 and 1.0.
     */
    audioVolume: number
    /**
     * The fill level of the buffer for the current stream,
     * as a value between 0.0 and 1.0.
     */
    readonly bufferFill: number
    /**
     * Whether the current stream is seekable.
     */
    readonly canSeek: boolean
    /**
     * The duration of the current stream, in seconds
     */
    readonly duration: number
    /**
     * Whether the #ClutterMedia actor is playing.
     */
    playing: boolean
    /**
     * The current progress of the playback, as a normalized
     * value between 0.0 and 1.0.
     */
    progress: number
    /**
     * The font used to display subtitles. The font description has to
     * follow the same grammar as the one recognized by
     * pango_font_description_from_string().
     */
    subtitleFontName: string
    /**
     * The location of a subtitle file, expressed as a valid URI.
     */
    subtitleUri: string
    /**
     * The location of a media file, expressed as a valid URI.
     */
    uri: string
    /* Methods of Clutter-1.0.Clutter.Media */
    /**
     * Retrieves the playback volume of `media`.
     */
    getAudioVolume(): number
    /**
     * Retrieves the amount of the stream that is buffered.
     */
    getBufferFill(): number
    /**
     * Retrieves whether `media` is seekable or not.
     */
    getCanSeek(): boolean
    /**
     * Retrieves the duration of the media stream that `media` represents.
     */
    getDuration(): number
    /**
     * Retrieves the playing status of `media`.
     */
    getPlaying(): boolean
    /**
     * Retrieves the playback progress of `media`.
     */
    getProgress(): number
    /**
     * Retrieves the font name currently used.
     */
    getSubtitleFontName(): string
    /**
     * Retrieves the URI of the subtitle file in use.
     */
    getSubtitleUri(): string
    /**
     * Retrieves the URI from `media`.
     */
    getUri(): string
    /**
     * Sets the playback volume of `media` to `volume`.
     */
    setAudioVolume(volume: number): void
    /**
     * Sets the source of `media` using a file path.
     */
    setFilename(filename: string): void
    /**
     * Starts or stops playing of `media`.
     *  
     * The implementation might be asynchronous, so the way to know whether
     * the actual playing state of the `media` is to use the #GObject::notify
     * signal on the #ClutterMedia:playing property and then retrieve the
     * current state with clutter_media_get_playing(). ClutterGstVideoTexture
     * in clutter-gst is an example of such an asynchronous implementation.
     */
    setPlaying(playing: boolean): void
    /**
     * Sets the playback progress of `media`. The `progress` is
     * a normalized value between 0.0 (begin) and 1.0 (end).
     */
    setProgress(progress: number): void
    /**
     * Sets the font used by the subtitle renderer. The `font_name` string must be
     * either %NULL, which means that the default font name of the underlying
     * implementation will be used; or must follow the grammar recognized by
     * pango_font_description_from_string() like:
     * 
     * |[
     *   clutter_media_set_subtitle_font_name (media, "Sans 24pt");
     * ```
     * 
     */
    setSubtitleFontName(fontName: string): void
    /**
     * Sets the location of a subtitle file to display while playing `media`.
     */
    setSubtitleUri(uri: string): void
    /**
     * Sets the URI of `media` to `uri`.
     */
    setUri(uri: string): void
    /* Signals of Clutter-1.0.Clutter.Media */
    /**
     * The ::eos signal is emitted each time the media stream ends.
     */
    connect(sigName: "eos", callback: (() => void)): number
    on(sigName: "eos", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "eos", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "eos", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "eos"): void
    /**
     * The ::error signal is emitted each time an error occurred.
     */
    connect(sigName: "error", callback: ((error: GLib.Error) => void)): number
    on(sigName: "error", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "error", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "error", callback: (error: GLib.Error) => void): NodeJS.EventEmitter
    emit(sigName: "error", error: GLib.Error): void
    static name: string
}
class Scriptable {
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    static name: string
}
interface Action_ConstructProps extends ActorMeta_ConstructProps {
}
class Action {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Action_ConstructProps)
    _init (config?: Action_ConstructProps): void
    static $gtype: GObject.Type
}
interface Actor_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions?: Action
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity?: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX?: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY?: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor?: Color
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform?: Matrix
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip?: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect?: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation?: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints?: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content?: Content
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity?: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat?: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth?: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect?: Effect
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet?: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX?: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY?: number
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height?: number
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager?: LayoutManager
    magnificationFilter?: ScalingFilter
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom?: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft?: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight?: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop?: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight?: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet?: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth?: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet?: boolean
    minificationFilter?: ScalingFilter
    /**
     * The name of the actor
     */
    name?: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight?: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet?: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth?: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet?: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect?: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity?: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint?: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ?: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position?: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive?: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode?: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX?: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY?: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ?: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX?: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY?: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ?: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity?: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX?: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY?: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity?: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX?: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY?: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ?: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent?: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size?: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection?: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform?: Matrix
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX?: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY?: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ?: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible?: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width?: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x?: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign?: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand?: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y?: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign?: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand?: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition?: number
}
class Actor {
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Actor_ConstructProps)
    _init (config?: Actor_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Actor
    static $gtype: GObject.Type
}
interface ActorMeta_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled?: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name?: string
}
class ActorMeta {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ActorMeta_ConstructProps)
    _init (config?: ActorMeta_ConstructProps): void
    static $gtype: GObject.Type
}
interface AlignConstraint_ConstructProps extends Constraint_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.AlignConstraint */
    /**
     * The axis to be used to compute the alignment
     */
    alignAxis?: AlignAxis
    /**
     * The alignment factor, as a normalized value between 0.0 and 1.0
     * 
     * The factor depends on the #ClutterAlignConstraint:align-axis property:
     * with an align-axis value of %CLUTTER_ALIGN_X_AXIS, 0.0 means left and
     * 1.0 means right; with a value of %CLUTTER_ALIGN_Y_AXIS, 0.0 means top
     * and 1.0 means bottom.
     */
    factor?: number
    /**
     * The #ClutterActor used as the source for the alignment.
     * 
     * The #ClutterActor must not be a child or a grandchild of the actor
     * using the constraint.
     */
    source?: Actor
}
class AlignConstraint {
    /* Properties of Clutter-1.0.Clutter.AlignConstraint */
    /**
     * The axis to be used to compute the alignment
     */
    alignAxis: AlignAxis
    /**
     * The alignment factor, as a normalized value between 0.0 and 1.0
     * 
     * The factor depends on the #ClutterAlignConstraint:align-axis property:
     * with an align-axis value of %CLUTTER_ALIGN_X_AXIS, 0.0 means left and
     * 1.0 means right; with a value of %CLUTTER_ALIGN_Y_AXIS, 0.0 means top
     * and 1.0 means bottom.
     */
    factor: number
    /**
     * The #ClutterActor used as the source for the alignment.
     * 
     * The #ClutterActor must not be a child or a grandchild of the actor
     * using the constraint.
     */
    source: Actor
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.AlignConstraint */
    /**
     * Retrieves the value set using clutter_align_constraint_set_align_axis()
     */
    getAlignAxis(): AlignAxis
    /**
     * Retrieves the factor set using clutter_align_constraint_set_factor()
     */
    getFactor(): number
    /**
     * Retrieves the source of the alignment
     */
    getSource(): Actor
    /**
     * Sets the axis to which the alignment refers to
     */
    setAlignAxis(axis: AlignAxis): void
    /**
     * Sets the alignment factor of the constraint
     * 
     * The factor depends on the #ClutterAlignConstraint:align-axis property
     * and it is a value between 0.0 (meaning left, when
     * #ClutterAlignConstraint:align-axis is set to %CLUTTER_ALIGN_X_AXIS; or
     * meaning top, when #ClutterAlignConstraint:align-axis is set to
     * %CLUTTER_ALIGN_Y_AXIS) and 1.0 (meaning right, when
     * #ClutterAlignConstraint:align-axis is set to %CLUTTER_ALIGN_X_AXIS; or
     * meaning bottom, when #ClutterAlignConstraint:align-axis is set to
     * %CLUTTER_ALIGN_Y_AXIS). A value of 0.5 aligns in the middle in either
     * cases
     */
    setFactor(factor: number): void
    /**
     * Sets the source of the alignment constraint
     */
    setSource(source?: Actor | null): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::align-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::align-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::align-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::align-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::align-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AlignConstraint_ConstructProps)
    _init (config?: AlignConstraint_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(source: Actor | null, axis: AlignAxis, factor: number): AlignConstraint
    static $gtype: GObject.Type
}
interface Alpha_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Alpha */
    /**
     * The progress function logical id - either a value from the
     * #ClutterAnimationMode enumeration or a value returned by
     * clutter_alpha_register_func().
     * 
     * If %CLUTTER_CUSTOM_MODE is used then the function set using
     * clutter_alpha_set_closure() or clutter_alpha_set_func()
     * will be used.
     */
    mode?: number
    /**
     * A #ClutterTimeline instance used to drive the alpha function.
     */
    timeline?: Timeline
}
class Alpha {
    /* Properties of Clutter-1.0.Clutter.Alpha */
    /**
     * The alpha value as computed by the alpha function. The linear
     * interval is 0.0 to 1.0, but the Alpha allows overshooting by
     * one unit in each direction, so the valid interval is -1.0 to 2.0.
     */
    readonly alpha: number
    /**
     * The progress function logical id - either a value from the
     * #ClutterAnimationMode enumeration or a value returned by
     * clutter_alpha_register_func().
     * 
     * If %CLUTTER_CUSTOM_MODE is used then the function set using
     * clutter_alpha_set_closure() or clutter_alpha_set_func()
     * will be used.
     */
    mode: number
    /**
     * A #ClutterTimeline instance used to drive the alpha function.
     */
    timeline: Timeline
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Alpha */
    /**
     * Query the current alpha value.
     */
    getAlpha(): number
    /**
     * Retrieves the #ClutterAnimationMode used by `alpha`.
     */
    getMode(): number
    /**
     * Gets the #ClutterTimeline bound to `alpha`.
     */
    getTimeline(): Timeline
    /**
     * Sets the #GClosure used to compute the alpha value at each
     * frame of the #ClutterTimeline bound to `alpha`.
     */
    setClosure(closure: Function): void
    /**
     * Sets the #ClutterAlphaFunc function used to compute
     * the alpha value at each frame of the #ClutterTimeline
     * bound to `alpha`.
     * 
     * This function will not register `func` as a global alpha function.
     */
    setFunc(func: AlphaFunc): void
    /**
     * Sets the progress function of `alpha` using the symbolic value
     * of `mode,` as taken by the #ClutterAnimationMode enumeration or
     * using the value returned by clutter_alpha_register_func().
     */
    setMode(mode: number): void
    /**
     * Binds `alpha` to `timeline`.
     */
    setTimeline(timeline: Timeline): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::timeline", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeline", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Alpha_ConstructProps)
    _init (config?: Alpha_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Alpha
    static newFull(timeline: Timeline, mode: number): Alpha
    static newWithFunc(timeline: Timeline, func: AlphaFunc): Alpha
    /**
     * #GClosure variant of clutter_alpha_register_func().
     * 
     * Registers a global alpha function and returns its logical id
     * to be used by clutter_alpha_set_mode() or by #ClutterAnimation.
     * 
     * The logical id is always greater than %CLUTTER_ANIMATION_LAST.
     */
    static registerFunc(closure: Function): number
    static $gtype: GObject.Type
}
interface Animation_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Animation */
    /**
     * The #ClutterAlpha used by the animation.
     */
    alpha?: Alpha
    /**
     * The duration of the animation, expressed in milliseconds.
     */
    duration?: number
    /**
     * Whether the animation should loop.
     */
    loop?: boolean
    /**
     * The animation mode, either a value from #ClutterAnimationMode
     * or a value returned by clutter_alpha_register_func(). The
     * default value is %CLUTTER_LINEAR.
     */
    mode?: number
    /**
     * The #GObject to which the animation applies.
     */
    object?: GObject.Object
    /**
     * The #ClutterTimeline used by the animation.
     */
    timeline?: Timeline
}
class Animation {
    /* Properties of Clutter-1.0.Clutter.Animation */
    /**
     * The #ClutterAlpha used by the animation.
     */
    alpha: Alpha
    /**
     * The duration of the animation, expressed in milliseconds.
     */
    duration: number
    /**
     * Whether the animation should loop.
     */
    loop: boolean
    /**
     * The animation mode, either a value from #ClutterAnimationMode
     * or a value returned by clutter_alpha_register_func(). The
     * default value is %CLUTTER_LINEAR.
     */
    mode: number
    /**
     * The #GObject to which the animation applies.
     */
    object: GObject.Object
    /**
     * The #ClutterTimeline used by the animation.
     */
    timeline: Timeline
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Animation */
    /**
     * Adds a single property with name `property_name` to the
     * animation `animation`.  For more information about animations,
     * see clutter_actor_animate().
     * 
     * This method returns the animation primarily to make chained
     * calls convenient in language bindings.
     */
    bind(propertyName: string, final: any): Animation
    /**
     * Binds `interval` to the `property_name` of the #GObject
     * attached to `animation`. The #ClutterAnimation will take
     * ownership of the passed #ClutterInterval.  For more information
     * about animations, see clutter_actor_animate().
     * 
     * If you need to update the interval instance use
     * clutter_animation_update_interval() instead.
     */
    bindInterval(propertyName: string, interval: Interval): Animation
    /**
     * Emits the ::completed signal on `animation`
     * 
     * When using this function with a #ClutterAnimation created
     * by the clutter_actor_animate() family of functions, `animation`
     * will be unreferenced and it will not be valid anymore,
     * unless g_object_ref() was called before calling this function
     * or unless a reference was taken inside a handler for the
     * #ClutterAnimation::completed signal
     */
    completed(): void
    /**
     * Retrieves the #ClutterAlpha used by `animation`.
     */
    getAlpha(): Alpha
    /**
     * Retrieves the duration of `animation,` in milliseconds.
     */
    getDuration(): number
    /**
     * Retrieves the #ClutterInterval associated to `property_name`
     * inside `animation`.
     */
    getInterval(propertyName: string): Interval
    /**
     * Retrieves whether `animation` is looping.
     */
    getLoop(): boolean
    /**
     * Retrieves the animation mode of `animation,` as set by
     * clutter_animation_set_mode().
     */
    getMode(): number
    /**
     * Retrieves the #GObject attached to `animation`.
     */
    getObject(): GObject.Object
    /**
     * Retrieves the #ClutterTimeline used by `animation`
     */
    getTimeline(): Timeline
    /**
     * Checks whether `animation` is controlling `property_name`.
     */
    hasProperty(propertyName: string): boolean
    /**
     * Sets `alpha` as the #ClutterAlpha used by `animation`.
     * 
     * If `alpha` is not %NULL, the #ClutterAnimation will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /**
     * Sets the duration of `animation` in milliseconds.
     * 
     * This function will set #ClutterAnimation:alpha and
     * #ClutterAnimation:timeline if needed.
     */
    setDuration(msecs: number): void
    /**
     * Sets whether `animation` should loop over itself once finished.
     * 
     * A looping #ClutterAnimation will not emit the #ClutterAnimation::completed
     * signal when finished.
     * 
     * This function will set #ClutterAnimation:alpha and
     * #ClutterAnimation:timeline if needed.
     */
    setLoop(loop: boolean): void
    /**
     * Sets the animation `mode` of `animation`. The animation `mode` is
     * a logical id, either coming from the #ClutterAnimationMode enumeration
     * or the return value of clutter_alpha_register_func().
     * 
     * This function will also set #ClutterAnimation:alpha if needed.
     */
    setMode(mode: number): void
    /**
     * Attaches `animation` to `object`. The #ClutterAnimation will take a
     * reference on `object`.
     */
    setObject(object: GObject.Object): void
    /**
     * Sets the #ClutterTimeline used by `animation`.
     * 
     * This function will take a reference on the passed `timeline`.
     */
    setTimeline(timeline?: Timeline | null): void
    /**
     * Removes `property_name` from the list of animated properties.
     */
    unbindProperty(propertyName: string): void
    /**
     * Updates the `final` value of the interval for `property_name`
     */
    update(propertyName: string, final: any): Animation
    /**
     * Changes the `interval` for `property_name`. The #ClutterAnimation
     * will take ownership of the passed #ClutterInterval.
     */
    updateInterval(propertyName: string, interval: Interval): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Animation */
    /**
     * The ::completed signal is emitted once the animation has
     * been completed.
     * 
     * The `animation` instance is guaranteed to be valid for the entire
     * duration of the signal emission chain.
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /**
     * The ::started signal is emitted once the animation has been
     * started
     */
    connect(sigName: "started", callback: (() => void)): number
    on(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "started", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "started"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::object", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::object", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::object", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::object", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::object", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::timeline", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeline", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Animation_ConstructProps)
    _init (config?: Animation_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Animation
    static $gtype: GObject.Type
}
interface Animator_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Animator */
    /**
     * The duration of the #ClutterTimeline used by the #ClutterAnimator
     * to drive the animation
     */
    duration?: number
    /**
     * The #ClutterTimeline used by the #ClutterAnimator to drive the
     * animation
     */
    timeline?: Timeline
}
class Animator {
    /* Properties of Clutter-1.0.Clutter.Animator */
    /**
     * The duration of the #ClutterTimeline used by the #ClutterAnimator
     * to drive the animation
     */
    duration: number
    /**
     * The #ClutterTimeline used by the #ClutterAnimator to drive the
     * animation
     */
    timeline: Timeline
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Animator */
    /**
     * Compute the value for a managed property at a given progress.
     * 
     * If the property is an ease-in property, the current value of the property
     * on the object will be used as the starting point for computation.
     */
    computeValue(object: GObject.Object, propertyName: string, progress: number, value: any): boolean
    /**
     * Retrieves the current duration of an animator
     */
    getDuration(): number
    /**
     * Returns a list of pointers to opaque structures with accessor functions
     * that describe the keys added to an animator.
     */
    getKeys(object: GObject.Object | null, propertyName: string | null, progress: number): AnimatorKey[]
    /**
     * Get the timeline hooked up for driving the #ClutterAnimator
     */
    getTimeline(): Timeline
    /**
     * Checks if a property value is to be eased into the animation.
     */
    propertyGetEaseIn(object: GObject.Object, propertyName: string): boolean
    /**
     * Get the interpolation used by animator for a property on a particular
     * object.
     */
    propertyGetInterpolation(object: GObject.Object, propertyName: string): Interpolation
    /**
     * Sets whether a property value is to be eased into the animation.
     */
    propertySetEaseIn(object: GObject.Object, propertyName: string, easeIn: boolean): void
    /**
     * Set the interpolation method to use, %CLUTTER_INTERPOLATION_LINEAR causes
     * the values to linearly change between the values, and
     * %CLUTTER_INTERPOLATION_CUBIC causes the values to smoothly change between
     * the values.
     */
    propertySetInterpolation(object: GObject.Object, propertyName: string, interpolation: Interpolation): void
    /**
     * Removes all keys matching the conditions specificed in the arguments.
     */
    removeKey(object: GObject.Object | null, propertyName: string | null, progress: number): void
    /**
     * Runs the timeline of the #ClutterAnimator with a duration in msecs
     * as specified.
     */
    setDuration(duration: number): void
    /**
     * Sets a single key in the #ClutterAnimator for the `property_name` of
     * `object` at `progress`.
     * 
     * See also: clutter_animator_set()
     */
    setKey(object: GObject.Object, propertyName: string, mode: number, progress: number, value: any): Animator
    /**
     * Sets an external timeline that will be used for driving the animation
     */
    setTimeline(timeline: Timeline): void
    /**
     * Start the ClutterAnimator, this is a thin wrapper that rewinds
     * and starts the animators current timeline.
     */
    start(): Timeline
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::timeline", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeline", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::timeline", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Animator_ConstructProps)
    _init (config?: Animator_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Animator
    static $gtype: GObject.Type
}
interface Backend_ConstructProps extends GObject.Object_ConstructProps {
}
class Backend {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Backend */
    /**
     * Retrieves the distance used to verify a double click event
     */
    getDoubleClickDistance(): number
    /**
     * Gets the maximum time between two button press events, as set
     * by clutter_backend_set_double_click_time().
     */
    getDoubleClickTime(): number
    /**
     * Retrieves the default font name as set by
     * clutter_backend_set_font_name().
     */
    getFontName(): string
    /**
     * Retrieves the font options for `backend`.
     */
    getFontOptions(): cairo.FontOptions
    /**
     * Gets the resolution for font handling on the screen.
     * 
     * The resolution is a scale factor between points specified in a
     * #PangoFontDescription and cairo units. The default value is 96.0,
     * meaning that a 10 point font will be 13 units
     * high (10 * 96. / 72. = 13.3).
     * 
     * Clutter will set the resolution using the current backend when
     * initializing; the resolution is also stored in the
     * #ClutterSettings:font-dpi property.
     */
    getResolution(): number
    /**
     * Sets the maximum distance used to verify a double click event.
     */
    setDoubleClickDistance(distance: number): void
    /**
     * Sets the maximum time between two button press events, used to
     * verify whether it's a double click event or not.
     */
    setDoubleClickTime(msec: number): void
    /**
     * Sets the default font to be used by Clutter. The `font_name` string
     * must either be %NULL, which means that the font name from the
     * default #ClutterBackend will be used; or be something that can
     * be parsed by the pango_font_description_from_string() function.
     */
    setFontName(fontName: string): void
    /**
     * Sets the new font options for `backend`. The #ClutterBackend will
     * copy the #cairo_font_options_t.
     * 
     * If `options` is %NULL, the first following call to
     * clutter_backend_get_font_options() will return the default font
     * options for `backend`.
     * 
     * This function is intended for actors creating a Pango layout
     * using the PangoCairo API.
     */
    setFontOptions(options: cairo.FontOptions): void
    /**
     * Sets the resolution for font handling on the screen. This is a
     * scale factor between points specified in a #PangoFontDescription
     * and cairo units. The default value is 96, meaning that a 10 point
     * font will be 13 units high. (10 * 96. / 72. = 13.3).
     * 
     * Applications should never need to call this function.
     */
    setResolution(dpi: number): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.Backend */
    /**
     * The ::font-changed signal is emitted each time the font options
     * have been changed through #ClutterSettings.
     */
    connect(sigName: "font-changed", callback: (() => void)): number
    on(sigName: "font-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "font-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "font-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "font-changed"): void
    /**
     * The ::resolution-changed signal is emitted each time the font
     * resolutions has been changed through #ClutterSettings.
     */
    connect(sigName: "resolution-changed", callback: (() => void)): number
    on(sigName: "resolution-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "resolution-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "resolution-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "resolution-changed"): void
    /**
     * The ::settings-changed signal is emitted each time the #ClutterSettings
     * properties have been changed.
     */
    connect(sigName: "settings-changed", callback: (() => void)): number
    on(sigName: "settings-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "settings-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "settings-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "settings-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Backend_ConstructProps)
    _init (config?: Backend_ConstructProps): void
    static $gtype: GObject.Type
}
interface Behaviour_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha?: Alpha
}
class Behaviour {
    /* Properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha: Alpha
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Behaviour */
    /**
     * Calls `func` for every actor driven by `behave`.
     */
    actorsForeach(func: BehaviourForeachFunc): void
    /**
     * Applies `behave` to `actor`.  This function adds a reference on
     * the actor.
     */
    apply(actor: Actor): void
    /**
     * Retrieves all the actors to which `behave` applies. It is not recommended
     * for derived classes to use this in there alpha notify method but use
     * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
     */
    getActors(): Actor[]
    /**
     * Retrieves the #ClutterAlpha object bound to `behave`.
     */
    getAlpha(): Alpha
    /**
     * Gets the number of actors this behaviour is applied too.
     */
    getNActors(): number
    /**
     * Gets an actor the behaviour was applied to referenced by index num.
     */
    getNthActor(index: number): Actor
    /**
     * Check if `behave` applied to  `actor`.
     */
    isApplied(actor: Actor): boolean
    /**
     * Removes `actor` from the list of #ClutterActor<!-- -->s to which
     * `behave` applies.  This function removes a reference on the actor.
     */
    remove(actor: Actor): void
    /**
     * Removes every actor from the list that `behave` holds.
     */
    removeAll(): void
    /**
     * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
     * is what makes a behaviour work: for each tick of the timeline
     * used by #ClutterAlpha a new value of the alpha parameter is
     * computed by the alpha function; the value should be used by
     * the #ClutterBehaviour to update one or more properties of the
     * actors to which the behaviour applies.
     * 
     * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Behaviour */
    /**
     * The ::apply signal is emitted each time the behaviour is applied
     * to an actor.
     */
    connect(sigName: "applied", callback: ((actor: Actor) => void)): number
    on(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "applied", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "applied", actor: Actor): void
    /**
     * The ::removed signal is emitted each time a behaviour is not applied
     * to an actor anymore.
     */
    connect(sigName: "removed", callback: ((actor: Actor) => void)): number
    on(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "removed", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Behaviour_ConstructProps)
    _init (config?: Behaviour_ConstructProps): void
    static $gtype: GObject.Type
}
interface BehaviourDepth_ConstructProps extends Behaviour_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BehaviourDepth */
    /**
     * End depth level to apply to the actors.
     */
    depthEnd?: number
    /**
     * Start depth level to apply to the actors.
     */
    depthStart?: number
}
class BehaviourDepth {
    /* Properties of Clutter-1.0.Clutter.BehaviourDepth */
    /**
     * End depth level to apply to the actors.
     */
    depthEnd: number
    /**
     * Start depth level to apply to the actors.
     */
    depthStart: number
    /* Properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha: Alpha
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BehaviourDepth */
    /**
     * Gets the boundaries of the `behaviour`
     */
    getBounds(): [ /* depthStart */ number, /* depthEnd */ number ]
    /**
     * Sets the boundaries of the `behaviour`.
     */
    setBounds(depthStart: number, depthEnd: number): void
    /* Methods of Clutter-1.0.Clutter.Behaviour */
    /**
     * Calls `func` for every actor driven by `behave`.
     */
    actorsForeach(func: BehaviourForeachFunc): void
    /**
     * Applies `behave` to `actor`.  This function adds a reference on
     * the actor.
     */
    apply(actor: Actor): void
    /**
     * Retrieves all the actors to which `behave` applies. It is not recommended
     * for derived classes to use this in there alpha notify method but use
     * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
     */
    getActors(): Actor[]
    /**
     * Retrieves the #ClutterAlpha object bound to `behave`.
     */
    getAlpha(): Alpha
    /**
     * Gets the number of actors this behaviour is applied too.
     */
    getNActors(): number
    /**
     * Gets an actor the behaviour was applied to referenced by index num.
     */
    getNthActor(index: number): Actor
    /**
     * Check if `behave` applied to  `actor`.
     */
    isApplied(actor: Actor): boolean
    /**
     * Removes `actor` from the list of #ClutterActor<!-- -->s to which
     * `behave` applies.  This function removes a reference on the actor.
     */
    remove(actor: Actor): void
    /**
     * Removes every actor from the list that `behave` holds.
     */
    removeAll(): void
    /**
     * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
     * is what makes a behaviour work: for each tick of the timeline
     * used by #ClutterAlpha a new value of the alpha parameter is
     * computed by the alpha function; the value should be used by
     * the #ClutterBehaviour to update one or more properties of the
     * actors to which the behaviour applies.
     * 
     * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Behaviour */
    /**
     * The ::apply signal is emitted each time the behaviour is applied
     * to an actor.
     */
    connect(sigName: "applied", callback: ((actor: Actor) => void)): number
    on(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "applied", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "applied", actor: Actor): void
    /**
     * The ::removed signal is emitted each time a behaviour is not applied
     * to an actor anymore.
     */
    connect(sigName: "removed", callback: ((actor: Actor) => void)): number
    on(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "removed", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::depth-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BehaviourDepth_ConstructProps)
    _init (config?: BehaviourDepth_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(alpha: Alpha | null, depthStart: number, depthEnd: number): BehaviourDepth
    static $gtype: GObject.Type
}
interface BehaviourEllipse_ConstructProps extends Behaviour_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BehaviourEllipse */
    /**
     * The final angle to where the rotation should end.
     */
    angleEnd?: number
    /**
     * The initial angle from where the rotation should start.
     */
    angleStart?: number
    /**
     * The tilt angle for the rotation around center in X axis
     */
    angleTiltX?: number
    /**
     * The tilt angle for the rotation around center in Y axis
     */
    angleTiltY?: number
    /**
     * The tilt angle for the rotation on the Z axis
     */
    angleTiltZ?: number
    /**
     * The center of the ellipse.
     */
    center?: Knot
    /**
     * The direction of the rotation.
     */
    direction?: RotateDirection
    /**
     * Height of the ellipse, in pixels
     */
    height?: number
    /**
     * Width of the ellipse, in pixels
     */
    width?: number
}
class BehaviourEllipse {
    /* Properties of Clutter-1.0.Clutter.BehaviourEllipse */
    /**
     * The final angle to where the rotation should end.
     */
    angleEnd: number
    /**
     * The initial angle from where the rotation should start.
     */
    angleStart: number
    /**
     * The tilt angle for the rotation around center in X axis
     */
    angleTiltX: number
    /**
     * The tilt angle for the rotation around center in Y axis
     */
    angleTiltY: number
    /**
     * The tilt angle for the rotation on the Z axis
     */
    angleTiltZ: number
    /**
     * The center of the ellipse.
     */
    center: Knot
    /**
     * The direction of the rotation.
     */
    direction: RotateDirection
    /**
     * Height of the ellipse, in pixels
     */
    height: number
    /**
     * Width of the ellipse, in pixels
     */
    width: number
    /* Properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha: Alpha
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BehaviourEllipse */
    /**
     * Gets the at which movements ends.
     */
    getAngleEnd(): number
    /**
     * Gets the angle at which movements starts.
     */
    getAngleStart(): number
    /**
     * Gets the tilt of the ellipse around the center in the given axis.
     */
    getAngleTilt(axis: RotateAxis): number
    /**
     * Gets the center of the elliptical path path.
     */
    getCenter(): [ /* x */ number, /* y */ number ]
    /**
     * Retrieves the #ClutterRotateDirection used by the ellipse behaviour.
     */
    getDirection(): RotateDirection
    /**
     * Gets the height of the elliptical path.
     */
    getHeight(): number
    /**
     * Gets the tilt of the ellipse around the center in Y axis.
     */
    getTilt(): [ /* angleTiltX */ number, /* angleTiltY */ number, /* angleTiltZ */ number ]
    /**
     * Gets the width of the elliptical path.
     */
    getWidth(): number
    /**
     * Sets the angle at which movement ends; angles >= 360 degress get clamped
     * to the canonical interval <0, 360).
     */
    setAngleEnd(angleEnd: number): void
    /**
     * Sets the angle at which movement starts; angles >= 360 degress get clamped
     * to the canonical interval <0, 360).
     */
    setAngleStart(angleStart: number): void
    /**
     * Sets the angle at which the ellipse should be tilted around it's center.
     */
    setAngleTilt(axis: RotateAxis, angleTilt: number): void
    /**
     * Sets the center of the elliptical path to the point represented by knot.
     */
    setCenter(x: number, y: number): void
    /**
     * Sets the rotation direction used by the ellipse behaviour.
     */
    setDirection(direction: RotateDirection): void
    /**
     * Sets the height of the elliptical path.
     */
    setHeight(height: number): void
    /**
     * Sets the angles at which the ellipse should be tilted around it's center.
     */
    setTilt(angleTiltX: number, angleTiltY: number, angleTiltZ: number): void
    /**
     * Sets the width of the elliptical path.
     */
    setWidth(width: number): void
    /* Methods of Clutter-1.0.Clutter.Behaviour */
    /**
     * Calls `func` for every actor driven by `behave`.
     */
    actorsForeach(func: BehaviourForeachFunc): void
    /**
     * Applies `behave` to `actor`.  This function adds a reference on
     * the actor.
     */
    apply(actor: Actor): void
    /**
     * Retrieves all the actors to which `behave` applies. It is not recommended
     * for derived classes to use this in there alpha notify method but use
     * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
     */
    getActors(): Actor[]
    /**
     * Retrieves the #ClutterAlpha object bound to `behave`.
     */
    getAlpha(): Alpha
    /**
     * Gets the number of actors this behaviour is applied too.
     */
    getNActors(): number
    /**
     * Gets an actor the behaviour was applied to referenced by index num.
     */
    getNthActor(index: number): Actor
    /**
     * Check if `behave` applied to  `actor`.
     */
    isApplied(actor: Actor): boolean
    /**
     * Removes `actor` from the list of #ClutterActor<!-- -->s to which
     * `behave` applies.  This function removes a reference on the actor.
     */
    remove(actor: Actor): void
    /**
     * Removes every actor from the list that `behave` holds.
     */
    removeAll(): void
    /**
     * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
     * is what makes a behaviour work: for each tick of the timeline
     * used by #ClutterAlpha a new value of the alpha parameter is
     * computed by the alpha function; the value should be used by
     * the #ClutterBehaviour to update one or more properties of the
     * actors to which the behaviour applies.
     * 
     * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Behaviour */
    /**
     * The ::apply signal is emitted each time the behaviour is applied
     * to an actor.
     */
    connect(sigName: "applied", callback: ((actor: Actor) => void)): number
    on(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "applied", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "applied", actor: Actor): void
    /**
     * The ::removed signal is emitted each time a behaviour is not applied
     * to an actor anymore.
     */
    connect(sigName: "removed", callback: ((actor: Actor) => void)): number
    on(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "removed", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::angle-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::angle-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::angle-tilt-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle-tilt-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle-tilt-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle-tilt-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle-tilt-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::angle-tilt-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle-tilt-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle-tilt-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle-tilt-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle-tilt-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::angle-tilt-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle-tilt-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle-tilt-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle-tilt-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle-tilt-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::center", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::center", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::center", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::center", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::center", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BehaviourEllipse_ConstructProps)
    _init (config?: BehaviourEllipse_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(alpha: Alpha | null, x: number, y: number, width: number, height: number, direction: RotateDirection, start: number, end: number): BehaviourEllipse
    static $gtype: GObject.Type
}
interface BehaviourOpacity_ConstructProps extends Behaviour_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BehaviourOpacity */
    /**
     * Final opacity level of the behaviour.
     */
    opacityEnd?: number
    /**
     * Initial opacity level of the behaviour.
     */
    opacityStart?: number
}
class BehaviourOpacity {
    /* Properties of Clutter-1.0.Clutter.BehaviourOpacity */
    /**
     * Final opacity level of the behaviour.
     */
    opacityEnd: number
    /**
     * Initial opacity level of the behaviour.
     */
    opacityStart: number
    /* Properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha: Alpha
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BehaviourOpacity */
    /**
     * Gets the initial and final levels of the opacity applied by `behaviour`
     * on each actor it controls.
     */
    getBounds(): [ /* opacityStart */ number, /* opacityEnd */ number ]
    /**
     * Sets the initial and final levels of the opacity applied by `behaviour`
     * on each actor it controls.
     */
    setBounds(opacityStart: number, opacityEnd: number): void
    /* Methods of Clutter-1.0.Clutter.Behaviour */
    /**
     * Calls `func` for every actor driven by `behave`.
     */
    actorsForeach(func: BehaviourForeachFunc): void
    /**
     * Applies `behave` to `actor`.  This function adds a reference on
     * the actor.
     */
    apply(actor: Actor): void
    /**
     * Retrieves all the actors to which `behave` applies. It is not recommended
     * for derived classes to use this in there alpha notify method but use
     * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
     */
    getActors(): Actor[]
    /**
     * Retrieves the #ClutterAlpha object bound to `behave`.
     */
    getAlpha(): Alpha
    /**
     * Gets the number of actors this behaviour is applied too.
     */
    getNActors(): number
    /**
     * Gets an actor the behaviour was applied to referenced by index num.
     */
    getNthActor(index: number): Actor
    /**
     * Check if `behave` applied to  `actor`.
     */
    isApplied(actor: Actor): boolean
    /**
     * Removes `actor` from the list of #ClutterActor<!-- -->s to which
     * `behave` applies.  This function removes a reference on the actor.
     */
    remove(actor: Actor): void
    /**
     * Removes every actor from the list that `behave` holds.
     */
    removeAll(): void
    /**
     * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
     * is what makes a behaviour work: for each tick of the timeline
     * used by #ClutterAlpha a new value of the alpha parameter is
     * computed by the alpha function; the value should be used by
     * the #ClutterBehaviour to update one or more properties of the
     * actors to which the behaviour applies.
     * 
     * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Behaviour */
    /**
     * The ::apply signal is emitted each time the behaviour is applied
     * to an actor.
     */
    connect(sigName: "applied", callback: ((actor: Actor) => void)): number
    on(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "applied", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "applied", actor: Actor): void
    /**
     * The ::removed signal is emitted each time a behaviour is not applied
     * to an actor anymore.
     */
    connect(sigName: "removed", callback: ((actor: Actor) => void)): number
    on(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "removed", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::opacity-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BehaviourOpacity_ConstructProps)
    _init (config?: BehaviourOpacity_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(alpha: Alpha | null, opacityStart: number, opacityEnd: number): BehaviourOpacity
    static $gtype: GObject.Type
}
interface BehaviourPath_ConstructProps extends Behaviour_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BehaviourPath */
    path?: Path
}
class BehaviourPath {
    /* Properties of Clutter-1.0.Clutter.BehaviourPath */
    path: Path
    /* Properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha: Alpha
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BehaviourPath */
    /**
     * Get the current path of the behaviour
     */
    getPath(): Path
    /**
     * Change the path that the actors will follow. This will take the
     * floating reference on the #ClutterPath so you do not need to unref
     * it.
     */
    setPath(path: Path): void
    /* Methods of Clutter-1.0.Clutter.Behaviour */
    /**
     * Calls `func` for every actor driven by `behave`.
     */
    actorsForeach(func: BehaviourForeachFunc): void
    /**
     * Applies `behave` to `actor`.  This function adds a reference on
     * the actor.
     */
    apply(actor: Actor): void
    /**
     * Retrieves all the actors to which `behave` applies. It is not recommended
     * for derived classes to use this in there alpha notify method but use
     * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
     */
    getActors(): Actor[]
    /**
     * Retrieves the #ClutterAlpha object bound to `behave`.
     */
    getAlpha(): Alpha
    /**
     * Gets the number of actors this behaviour is applied too.
     */
    getNActors(): number
    /**
     * Gets an actor the behaviour was applied to referenced by index num.
     */
    getNthActor(index: number): Actor
    /**
     * Check if `behave` applied to  `actor`.
     */
    isApplied(actor: Actor): boolean
    /**
     * Removes `actor` from the list of #ClutterActor<!-- -->s to which
     * `behave` applies.  This function removes a reference on the actor.
     */
    remove(actor: Actor): void
    /**
     * Removes every actor from the list that `behave` holds.
     */
    removeAll(): void
    /**
     * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
     * is what makes a behaviour work: for each tick of the timeline
     * used by #ClutterAlpha a new value of the alpha parameter is
     * computed by the alpha function; the value should be used by
     * the #ClutterBehaviour to update one or more properties of the
     * actors to which the behaviour applies.
     * 
     * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.BehaviourPath */
    /**
     * This signal is emitted each time a node defined inside the path
     * is reached.
     */
    connect(sigName: "knot-reached", callback: ((knotNum: number) => void)): number
    on(sigName: "knot-reached", callback: (knotNum: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "knot-reached", callback: (knotNum: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "knot-reached", callback: (knotNum: number) => void): NodeJS.EventEmitter
    emit(sigName: "knot-reached", knotNum: number): void
    /* Signals of Clutter-1.0.Clutter.Behaviour */
    /**
     * The ::apply signal is emitted each time the behaviour is applied
     * to an actor.
     */
    connect(sigName: "applied", callback: ((actor: Actor) => void)): number
    on(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "applied", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "applied", actor: Actor): void
    /**
     * The ::removed signal is emitted each time a behaviour is not applied
     * to an actor anymore.
     */
    connect(sigName: "removed", callback: ((actor: Actor) => void)): number
    on(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "removed", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::path", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BehaviourPath_ConstructProps)
    _init (config?: BehaviourPath_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(alpha: Alpha | null, path: Path): BehaviourPath
    static newWithDescription(alpha: Alpha | null, desc: string): BehaviourPath
    static newWithKnots(alpha: Alpha | null, knots: Knot[]): BehaviourPath
    static $gtype: GObject.Type
}
interface BehaviourRotate_ConstructProps extends Behaviour_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BehaviourRotate */
    /**
     * The final angle to where the rotation should end.
     */
    angleEnd?: number
    /**
     * The initial angle from whence the rotation should start.
     */
    angleStart?: number
    /**
     * The axis of rotation.
     */
    axis?: RotateAxis
    /**
     * The x center of rotation.
     */
    centerX?: number
    /**
     * The y center of rotation.
     */
    centerY?: number
    /**
     * The z center of rotation.
     */
    centerZ?: number
    /**
     * The direction of the rotation.
     */
    direction?: RotateDirection
}
class BehaviourRotate {
    /* Properties of Clutter-1.0.Clutter.BehaviourRotate */
    /**
     * The final angle to where the rotation should end.
     */
    angleEnd: number
    /**
     * The initial angle from whence the rotation should start.
     */
    angleStart: number
    /**
     * The axis of rotation.
     */
    axis: RotateAxis
    /**
     * The x center of rotation.
     */
    centerX: number
    /**
     * The y center of rotation.
     */
    centerY: number
    /**
     * The z center of rotation.
     */
    centerZ: number
    /**
     * The direction of the rotation.
     */
    direction: RotateDirection
    /* Properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha: Alpha
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BehaviourRotate */
    /**
     * Retrieves the #ClutterRotateAxis used by the rotate behaviour.
     */
    getAxis(): RotateAxis
    /**
     * Retrieves the rotation boundaries of the rotate behaviour.
     */
    getBounds(): [ /* angleStart */ number, /* angleEnd */ number ]
    /**
     * Retrieves the center of rotation set using
     * clutter_behaviour_rotate_set_center().
     */
    getCenter(): [ /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the #ClutterRotateDirection used by the rotate behaviour.
     */
    getDirection(): RotateDirection
    /**
     * Sets the axis used by the rotate behaviour.
     */
    setAxis(axis: RotateAxis): void
    /**
     * Sets the initial and final angles of a rotation behaviour; angles >= 360
     * degrees get clamped to the canonical interval <0, 360).
     */
    setBounds(angleStart: number, angleEnd: number): void
    /**
     * Sets the center of rotation. The coordinates are relative to the plane
     * normal to the rotation axis set with clutter_behaviour_rotate_set_axis().
     */
    setCenter(x: number, y: number, z: number): void
    /**
     * Sets the rotation direction used by the rotate behaviour.
     */
    setDirection(direction: RotateDirection): void
    /* Methods of Clutter-1.0.Clutter.Behaviour */
    /**
     * Calls `func` for every actor driven by `behave`.
     */
    actorsForeach(func: BehaviourForeachFunc): void
    /**
     * Applies `behave` to `actor`.  This function adds a reference on
     * the actor.
     */
    apply(actor: Actor): void
    /**
     * Retrieves all the actors to which `behave` applies. It is not recommended
     * for derived classes to use this in there alpha notify method but use
     * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
     */
    getActors(): Actor[]
    /**
     * Retrieves the #ClutterAlpha object bound to `behave`.
     */
    getAlpha(): Alpha
    /**
     * Gets the number of actors this behaviour is applied too.
     */
    getNActors(): number
    /**
     * Gets an actor the behaviour was applied to referenced by index num.
     */
    getNthActor(index: number): Actor
    /**
     * Check if `behave` applied to  `actor`.
     */
    isApplied(actor: Actor): boolean
    /**
     * Removes `actor` from the list of #ClutterActor<!-- -->s to which
     * `behave` applies.  This function removes a reference on the actor.
     */
    remove(actor: Actor): void
    /**
     * Removes every actor from the list that `behave` holds.
     */
    removeAll(): void
    /**
     * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
     * is what makes a behaviour work: for each tick of the timeline
     * used by #ClutterAlpha a new value of the alpha parameter is
     * computed by the alpha function; the value should be used by
     * the #ClutterBehaviour to update one or more properties of the
     * actors to which the behaviour applies.
     * 
     * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Behaviour */
    /**
     * The ::apply signal is emitted each time the behaviour is applied
     * to an actor.
     */
    connect(sigName: "applied", callback: ((actor: Actor) => void)): number
    on(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "applied", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "applied", actor: Actor): void
    /**
     * The ::removed signal is emitted each time a behaviour is not applied
     * to an actor anymore.
     */
    connect(sigName: "removed", callback: ((actor: Actor) => void)): number
    on(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "removed", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::angle-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::angle-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BehaviourRotate_ConstructProps)
    _init (config?: BehaviourRotate_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(alpha: Alpha | null, axis: RotateAxis, direction: RotateDirection, angleStart: number, angleEnd: number): BehaviourRotate
    static $gtype: GObject.Type
}
interface BehaviourScale_ConstructProps extends Behaviour_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BehaviourScale */
    /**
     * The final scaling factor on the X axis for the actors.
     */
    xScaleEnd?: number
    /**
     * The initial scaling factor on the X axis for the actors.
     */
    xScaleStart?: number
    /**
     * The final scaling factor on the Y axis for the actors.
     */
    yScaleEnd?: number
    /**
     * The initial scaling factor on the Y axis for the actors.
     */
    yScaleStart?: number
}
class BehaviourScale {
    /* Properties of Clutter-1.0.Clutter.BehaviourScale */
    /**
     * The final scaling factor on the X axis for the actors.
     */
    xScaleEnd: number
    /**
     * The initial scaling factor on the X axis for the actors.
     */
    xScaleStart: number
    /**
     * The final scaling factor on the Y axis for the actors.
     */
    yScaleEnd: number
    /**
     * The initial scaling factor on the Y axis for the actors.
     */
    yScaleStart: number
    /* Properties of Clutter-1.0.Clutter.Behaviour */
    /**
     * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
     * object binds a #ClutterTimeline and a function which computes a value
     * (the "alpha") depending on the time. Each time the alpha value changes
     * the alpha-notify virtual function is called.
     */
    alpha: Alpha
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BehaviourScale */
    /**
     * Retrieves the bounds used by scale behaviour.
     */
    getBounds(): [ /* xScaleStart */ number, /* yScaleStart */ number, /* xScaleEnd */ number, /* yScaleEnd */ number ]
    /**
     * Sets the bounds used by scale behaviour.
     */
    setBounds(xScaleStart: number, yScaleStart: number, xScaleEnd: number, yScaleEnd: number): void
    /* Methods of Clutter-1.0.Clutter.Behaviour */
    /**
     * Calls `func` for every actor driven by `behave`.
     */
    actorsForeach(func: BehaviourForeachFunc): void
    /**
     * Applies `behave` to `actor`.  This function adds a reference on
     * the actor.
     */
    apply(actor: Actor): void
    /**
     * Retrieves all the actors to which `behave` applies. It is not recommended
     * for derived classes to use this in there alpha notify method but use
     * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
     */
    getActors(): Actor[]
    /**
     * Retrieves the #ClutterAlpha object bound to `behave`.
     */
    getAlpha(): Alpha
    /**
     * Gets the number of actors this behaviour is applied too.
     */
    getNActors(): number
    /**
     * Gets an actor the behaviour was applied to referenced by index num.
     */
    getNthActor(index: number): Actor
    /**
     * Check if `behave` applied to  `actor`.
     */
    isApplied(actor: Actor): boolean
    /**
     * Removes `actor` from the list of #ClutterActor<!-- -->s to which
     * `behave` applies.  This function removes a reference on the actor.
     */
    remove(actor: Actor): void
    /**
     * Removes every actor from the list that `behave` holds.
     */
    removeAll(): void
    /**
     * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
     * is what makes a behaviour work: for each tick of the timeline
     * used by #ClutterAlpha a new value of the alpha parameter is
     * computed by the alpha function; the value should be used by
     * the #ClutterBehaviour to update one or more properties of the
     * actors to which the behaviour applies.
     * 
     * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
     * of the #ClutterAlpha instance.
     */
    setAlpha(alpha: Alpha): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Behaviour */
    /**
     * The ::apply signal is emitted each time the behaviour is applied
     * to an actor.
     */
    connect(sigName: "applied", callback: ((actor: Actor) => void)): number
    on(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "applied", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "applied", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "applied", actor: Actor): void
    /**
     * The ::removed signal is emitted each time a behaviour is not applied
     * to an actor anymore.
     */
    connect(sigName: "removed", callback: ((actor: Actor) => void)): number
    on(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "removed", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::x-scale-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-scale-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-scale-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-scale-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-scale-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-scale-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-scale-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-scale-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-scale-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-scale-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-scale-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-scale-end", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-scale-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-scale-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-scale-end", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-scale-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-scale-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-scale-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-scale-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-scale-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BehaviourScale_ConstructProps)
    _init (config?: BehaviourScale_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(alpha: Alpha | null, xScaleStart: number, yScaleStart: number, xScaleEnd: number, yScaleEnd: number): BehaviourScale
    static $gtype: GObject.Type
}
interface BinLayout_ConstructProps extends LayoutManager_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BinLayout */
    /**
     * The default horizontal alignment policy for actors managed
     * by the #ClutterBinLayout
     */
    xAlign?: BinAlignment
    /**
     * The default vertical alignment policy for actors managed
     * by the #ClutterBinLayout
     */
    yAlign?: BinAlignment
}
class BinLayout {
    /* Properties of Clutter-1.0.Clutter.BinLayout */
    /**
     * The default horizontal alignment policy for actors managed
     * by the #ClutterBinLayout
     */
    xAlign: BinAlignment
    /**
     * The default vertical alignment policy for actors managed
     * by the #ClutterBinLayout
     */
    yAlign: BinAlignment
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BinLayout */
    /**
     * Adds a #ClutterActor to the container using `self` and
     * sets the alignment policies for it
     * 
     * This function is equivalent to clutter_container_add_actor()
     * and clutter_layout_manager_child_set_property() but it does not
     * require a pointer to the #ClutterContainer associated to the
     * #ClutterBinLayout
     */
    add(child: Actor, xAlign: BinAlignment, yAlign: BinAlignment): void
    /**
     * Retrieves the horizontal and vertical alignment policies for
     * a child of `self`
     * 
     * If `child` is %NULL the default alignment policies will be returned
     * instead
     */
    getAlignment(child?: Actor | null): [ /* xAlign */ BinAlignment | null, /* yAlign */ BinAlignment | null ]
    /**
     * Sets the horizontal and vertical alignment policies to be applied
     * to a `child` of `self`
     * 
     * If `child` is %NULL then the `x_align` and `y_align` values will
     * be set as the default alignment policies
     */
    setAlignment(child: Actor | null, xAlign: BinAlignment, yAlign: BinAlignment): void
    /* Methods of Clutter-1.0.Clutter.LayoutManager */
    /**
     * Allocates the children of `container` given an area
     * 
     * See also clutter_actor_allocate()
     */
    allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void
    /**
     * Begins an animation of `duration` milliseconds, using the provided
     * easing `mode`
     * 
     * The easing mode can be specified either as a #ClutterAnimationMode
     * or as a logical id returned by clutter_alpha_register_func()
     * 
     * The result of this function depends on the `manager` implementation
     */
    beginAnimation(duration: number, mode: number): Alpha
    /**
     * Gets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     * 
     * The #GValue must already be initialized to the type of the property
     * and has to be unset with g_value_unset() after extracting the real
     * value out of it
     */
    childGetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Sets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     */
    childSetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Ends an animation started by clutter_layout_manager_begin_animation()
     * 
     * The result of this call depends on the `manager` implementation
     */
    endAnimation(): void
    /**
     * Retrieves the #GParamSpec for the layout property `name` inside
     * the #ClutterLayoutMeta sub-class used by `manager`
     */
    findChildProperty(name: string): GObject.ParamSpec
    /**
     * Retrieves the progress of the animation, if one has been started by
     * clutter_layout_manager_begin_animation()
     * 
     * The returned value has the same semantics of the #ClutterAlpha:alpha
     * value
     */
    getAnimationProgress(): number
    /**
     * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
     * to the `actor` child of `container,` eventually by creating one if the
     * #ClutterLayoutManager supports layout properties
     */
    getChildMeta(container: Container, actor: Actor): LayoutMeta
    /**
     * Computes the minimum and natural heights of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_height()
     */
    getPreferredHeight(container: Container, forWidth: number): [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    /**
     * Computes the minimum and natural widths of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_width()
     */
    getPreferredWidth(container: Container, forHeight: number): [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    /**
     * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
     * 
     * This function should only be called by implementations of the
     * #ClutterLayoutManager class
     */
    layoutChanged(): void
    /**
     * Retrieves all the #GParamSpec<!-- -->s for the layout properties
     * stored inside the #ClutterLayoutMeta sub-class used by `manager`
     */
    listChildProperties(): GObject.ParamSpec[]
    /**
     * If the #ClutterLayoutManager sub-class allows it, allow
     * adding a weak reference of the `container` using `manager`
     * from within the layout manager
     * 
     * The layout manager should not increase the reference
     * count of the `container`
     */
    setContainer(container?: Container | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.LayoutManager */
    /**
     * The ::layout-changed signal is emitted each time a layout manager
     * has been changed. Every #ClutterActor using the `manager` instance
     * as a layout manager should connect a handler to the ::layout-changed
     * signal and queue a relayout on themselves:
     * 
     * |[
     *   static void layout_changed (ClutterLayoutManager *manager,
     *                               ClutterActor         *self)
     *   {
     *     clutter_actor_queue_relayout (self);
     *   }
     *   ...
     *     self->manager = g_object_ref_sink (manager);
     *     g_signal_connect (self->manager, "layout-changed",
     *                       G_CALLBACK (layout_changed),
     *                       self);
     * ```
     * 
     * 
     * Sub-classes of #ClutterLayoutManager that implement a layout that
     * can be controlled or changed using parameters should emit the
     * ::layout-changed signal whenever one of the parameters changes,
     * by using clutter_layout_manager_layout_changed().
     */
    connect(sigName: "layout-changed", callback: (() => void)): number
    on(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "layout-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "layout-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BinLayout_ConstructProps)
    _init (config?: BinLayout_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(xAlign: BinAlignment, yAlign: BinAlignment): BinLayout
    static $gtype: GObject.Type
}
interface BindConstraint_ConstructProps extends Constraint_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BindConstraint */
    /**
     * The coordinate to be bound
     */
    coordinate?: BindCoordinate
    /**
     * The offset, in pixels, to be applied to the binding
     */
    offset?: number
    /**
     * The #ClutterActor used as the source for the binding.
     * 
     * The #ClutterActor must not be contained inside the actor associated
     * to the constraint.
     */
    source?: Actor
}
class BindConstraint {
    /* Properties of Clutter-1.0.Clutter.BindConstraint */
    /**
     * The coordinate to be bound
     */
    coordinate: BindCoordinate
    /**
     * The offset, in pixels, to be applied to the binding
     */
    offset: number
    /**
     * The #ClutterActor used as the source for the binding.
     * 
     * The #ClutterActor must not be contained inside the actor associated
     * to the constraint.
     */
    source: Actor
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BindConstraint */
    /**
     * Retrieves the bound coordinate of the constraint
     */
    getCoordinate(): BindCoordinate
    /**
     * Retrieves the offset set using clutter_bind_constraint_set_offset()
     */
    getOffset(): number
    /**
     * Retrieves the #ClutterActor set using clutter_bind_constraint_set_source()
     */
    getSource(): Actor
    /**
     * Sets the coordinate to bind in the constraint
     */
    setCoordinate(coordinate: BindCoordinate): void
    /**
     * Sets the offset to be applied to the constraint
     */
    setOffset(offset: number): void
    /**
     * Sets the source #ClutterActor for the constraint
     */
    setSource(source?: Actor | null): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::coordinate", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::coordinate", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::coordinate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::coordinate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::coordinate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BindConstraint_ConstructProps)
    _init (config?: BindConstraint_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(source: Actor | null, coordinate: BindCoordinate, offset: number): BindConstraint
    static $gtype: GObject.Type
}
interface BindingPool_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BindingPool */
    /**
     * The unique name of the #ClutterBindingPool.
     */
    name?: string
}
class BindingPool {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BindingPool */
    /**
     * Activates the callback associated to the action that is
     * bound to the `key_val` and `modifiers` pair.
     * 
     * The callback has the following signature:
     * 
     * |[
     *   void (* callback) (GObject             *gobject,
     *                      const gchar         *action_name,
     *                      guint                key_val,
     *                      ClutterModifierType  modifiers,
     *                      gpointer             user_data);
     * ```
     * 
     * 
     * Where the #GObject instance is `gobject` and the user data
     * is the one passed when installing the action with
     * clutter_binding_pool_install_action().
     * 
     * If the action bound to the `key_val,` `modifiers` pair has been
     * blocked using clutter_binding_pool_block_action(), the callback
     * will not be invoked, and this function will return %FALSE.
     */
    activate(keyVal: number, modifiers: ModifierType, gobject: GObject.Object): boolean
    /**
     * Blocks all the actions with name `action_name` inside `pool`.
     */
    blockAction(actionName: string): void
    /**
     * Retrieves the name of the action matching the given key symbol
     * and modifiers bitmask.
     */
    findAction(keyVal: number, modifiers: ModifierType): string
    /**
     * Installs a new action inside a #ClutterBindingPool. The action
     * is bound to `key_val` and `modifiers`.
     * 
     * The same action name can be used for multiple `key_val,` `modifiers`
     * pairs.
     * 
     * When an action has been activated using clutter_binding_pool_activate()
     * the passed `callback` will be invoked (with `data)`.
     * 
     * Actions can be blocked with clutter_binding_pool_block_action()
     * and then unblocked using clutter_binding_pool_unblock_action().
     */
    installAction(actionName: string, keyVal: number, modifiers: ModifierType, callback: BindingActionFunc): void
    /**
     * A #GClosure variant of clutter_binding_pool_install_action().
     * 
     * Installs a new action inside a #ClutterBindingPool. The action
     * is bound to `key_val` and `modifiers`.
     * 
     * The same action name can be used for multiple `key_val,` `modifiers`
     * pairs.
     * 
     * When an action has been activated using clutter_binding_pool_activate()
     * the passed `closure` will be invoked.
     * 
     * Actions can be blocked with clutter_binding_pool_block_action()
     * and then unblocked using clutter_binding_pool_unblock_action().
     */
    installClosure(actionName: string, keyVal: number, modifiers: ModifierType, closure: Function): void
    /**
     * Allows overriding the action for `key_val` and `modifiers` inside a
     * #ClutterBindingPool. See clutter_binding_pool_install_action().
     * 
     * When an action has been activated using clutter_binding_pool_activate()
     * the passed `callback` will be invoked (with `data)`.
     * 
     * Actions can be blocked with clutter_binding_pool_block_action()
     * and then unblocked using clutter_binding_pool_unblock_action().
     */
    overrideAction(keyVal: number, modifiers: ModifierType, callback: BindingActionFunc): void
    /**
     * A #GClosure variant of clutter_binding_pool_override_action().
     * 
     * Allows overriding the action for `key_val` and `modifiers` inside a
     * #ClutterBindingPool. See clutter_binding_pool_install_closure().
     * 
     * When an action has been activated using clutter_binding_pool_activate()
     * the passed `callback` will be invoked (with `data)`.
     * 
     * Actions can be blocked with clutter_binding_pool_block_action()
     * and then unblocked using clutter_binding_pool_unblock_action().
     */
    overrideClosure(keyVal: number, modifiers: ModifierType, closure: Function): void
    /**
     * Removes the action matching the given `key_val,` `modifiers` pair,
     * if any exists.
     */
    removeAction(keyVal: number, modifiers: ModifierType): void
    /**
     * Unblockes all the actions with name `action_name` inside `pool`.
     * 
     * Unblocking an action does not cause the callback bound to it to
     * be invoked in case clutter_binding_pool_activate() was called on
     * an action previously blocked with clutter_binding_pool_block_action().
     */
    unblockAction(actionName: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BindingPool_ConstructProps)
    _init (config?: BindingPool_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name: string): BindingPool
    /**
     * Finds the #ClutterBindingPool with `name`.
     */
    static find(name: string): BindingPool
    /**
     * Retrieves the #ClutterBindingPool for the given #GObject class
     * and, eventually, creates it. This function is a wrapper around
     * clutter_binding_pool_new() and uses the class type name as the
     * unique name for the binding pool.
     * 
     * Calling this function multiple times will return the same
     * #ClutterBindingPool.
     * 
     * A binding pool for a class can also be retrieved using
     * clutter_binding_pool_find() with the class type name:
     * 
     * |[
     *   pool = clutter_binding_pool_find (G_OBJECT_TYPE_NAME (instance));
     * ```
     * 
     */
    static getForClass(klass?: object | null): BindingPool
    static $gtype: GObject.Type
}
interface BlurEffect_ConstructProps extends OffscreenEffect_ConstructProps {
}
class BlurEffect {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BlurEffect_ConstructProps)
    _init (config?: BlurEffect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): BlurEffect
    static $gtype: GObject.Type
}
interface Box_ConstructProps extends Actor_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Box */
    /**
     * The color to be used to paint the background of the
     * #ClutterBox. Setting this property will set the
     * #ClutterBox:color-set property as a side effect
     * 
     * This property sets the #ClutterActor:background-color property
     * internally.
     */
    color?: Color
    /**
     * Whether the #ClutterBox:color property has been set.
     * 
     * This property reads the #ClutterActor:background-color-set property
     * internally.
     */
    colorSet?: boolean
}
class Box {
    /* Properties of Clutter-1.0.Clutter.Box */
    /**
     * The color to be used to paint the background of the
     * #ClutterBox. Setting this property will set the
     * #ClutterBox:color-set property as a side effect
     * 
     * This property sets the #ClutterActor:background-color property
     * internally.
     */
    color: Color
    /**
     * Whether the #ClutterBox:color property has been set.
     * 
     * This property reads the #ClutterActor:background-color-set property
     * internally.
     */
    colorSet: boolean
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Box */
    /**
     * Retrieves the background color of `box`
     * 
     * If the #ClutterBox:color-set property is set to %FALSE the
     * returned #ClutterColor is undefined
     */
    getColor(): /* color */ Color
    /**
     * Retrieves the #ClutterLayoutManager instance used by `box`
     */
    getLayoutManager(): LayoutManager
    /**
     * Vector-based variant of clutter_box_pack(), intended for language
     * bindings to use
     */
    packv(actor: Actor, properties: string[], values: any[]): void
    /**
     * Sets (or unsets) the background color for `box`
     */
    setColor(color?: Color | null): void
    /**
     * Sets the #ClutterLayoutManager for `box`
     * 
     * A #ClutterLayoutManager is a delegate object that controls the
     * layout of the children of `box`
     */
    setLayoutManager(manager: LayoutManager): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Box_ConstructProps)
    _init (config?: Box_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(manager: LayoutManager): Box
    /* Function overloads */
    static new(): Box
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
interface BoxLayout_ConstructProps extends LayoutManager_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BoxLayout */
    /**
     * The duration of the animations, in case #ClutterBoxLayout:use-animations
     * is set to %TRUE.
     * 
     * The duration is expressed in milliseconds.
     */
    easingDuration?: number
    /**
     * The easing mode for the animations, in case
     * #ClutterBoxLayout:use-animations is set to %TRUE.
     * 
     * The easing mode has the same semantics of #ClutterAnimation:mode: it can
     * either be a value from the #ClutterAnimationMode enumeration, like
     * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
     * clutter_alpha_register_func().
     * 
     * The default value is %CLUTTER_EASE_OUT_CUBIC.
     */
    easingMode?: number
    /**
     * Whether the #ClutterBoxLayout should arrange its children
     * homogeneously, i.e. all children get the same size
     */
    homogeneous?: boolean
    /**
     * The orientation of the #ClutterBoxLayout, either horizontal
     * or vertical
     */
    orientation?: Orientation
    /**
     * Whether the #ClutterBoxLayout should pack items at the start
     * or append them at the end
     */
    packStart?: boolean
    /**
     * The spacing between children of the #ClutterBoxLayout, in pixels
     */
    spacing?: number
    /**
     * Whether the #ClutterBoxLayout should animate changes in the
     * layout, overriding the easing state of the children.
     */
    useAnimations?: boolean
    /**
     * Whether the #ClutterBoxLayout should arrange its children
     * alongside the Y axis, instead of alongside the X axis
     */
    vertical?: boolean
}
class BoxLayout {
    /* Properties of Clutter-1.0.Clutter.BoxLayout */
    /**
     * The duration of the animations, in case #ClutterBoxLayout:use-animations
     * is set to %TRUE.
     * 
     * The duration is expressed in milliseconds.
     */
    easingDuration: number
    /**
     * The easing mode for the animations, in case
     * #ClutterBoxLayout:use-animations is set to %TRUE.
     * 
     * The easing mode has the same semantics of #ClutterAnimation:mode: it can
     * either be a value from the #ClutterAnimationMode enumeration, like
     * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
     * clutter_alpha_register_func().
     * 
     * The default value is %CLUTTER_EASE_OUT_CUBIC.
     */
    easingMode: number
    /**
     * Whether the #ClutterBoxLayout should arrange its children
     * homogeneously, i.e. all children get the same size
     */
    homogeneous: boolean
    /**
     * The orientation of the #ClutterBoxLayout, either horizontal
     * or vertical
     */
    orientation: Orientation
    /**
     * Whether the #ClutterBoxLayout should pack items at the start
     * or append them at the end
     */
    packStart: boolean
    /**
     * The spacing between children of the #ClutterBoxLayout, in pixels
     */
    spacing: number
    /**
     * Whether the #ClutterBoxLayout should animate changes in the
     * layout, overriding the easing state of the children.
     */
    useAnimations: boolean
    /**
     * Whether the #ClutterBoxLayout should arrange its children
     * alongside the Y axis, instead of alongside the X axis
     */
    vertical: boolean
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BoxLayout */
    /**
     * Retrieves the horizontal and vertical alignment policies for `actor`
     * as set using clutter_box_layout_pack() or clutter_box_layout_set_alignment()
     */
    getAlignment(actor: Actor): [ /* xAlign */ BoxAlignment, /* yAlign */ BoxAlignment ]
    /**
     * Retrieves the duration set using clutter_box_layout_set_easing_duration()
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode set using clutter_box_layout_set_easing_mode()
     */
    getEasingMode(): number
    /**
     * Retrieves whether `actor` should expand inside `layout`
     */
    getExpand(actor: Actor): boolean
    /**
     * Retrieves the horizontal and vertical fill policies for `actor`
     * as set using clutter_box_layout_pack() or clutter_box_layout_set_fill()
     */
    getFill(actor: Actor): [ /* xFill */ boolean, /* yFill */ boolean ]
    /**
     * Retrieves if the children sizes are allocated homogeneously.
     */
    getHomogeneous(): boolean
    /**
     * Retrieves the orientation of the `layout`.
     */
    getOrientation(): Orientation
    /**
     * Retrieves the value set using clutter_box_layout_set_pack_start()
     */
    getPackStart(): boolean
    /**
     * Retrieves the spacing set using clutter_box_layout_set_spacing()
     */
    getSpacing(): number
    /**
     * Retrieves whether `layout` should animate changes in the layout properties.
     */
    getUseAnimations(): boolean
    /**
     * Retrieves the orientation of the `layout` as set using the
     * clutter_box_layout_set_vertical() function
     */
    getVertical(): boolean
    /**
     * Packs `actor` inside the #ClutterContainer associated to `layout`
     * and sets the layout properties
     */
    pack(actor: Actor, expand: boolean, xFill: boolean, yFill: boolean, xAlign: BoxAlignment, yAlign: BoxAlignment): void
    /**
     * Sets the horizontal and vertical alignment policies for `actor`
     * inside `layout`
     */
    setAlignment(actor: Actor, xAlign: BoxAlignment, yAlign: BoxAlignment): void
    /**
     * Sets the duration of the animations used by `layout` when animating changes
     * in the layout properties.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode to be used by `layout` when animating changes in layout
     * properties.
     */
    setEasingMode(mode: number): void
    /**
     * Sets whether `actor` should expand inside `layout`
     */
    setExpand(actor: Actor, expand: boolean): void
    /**
     * Sets the horizontal and vertical fill policies for `actor`
     * inside `layout`
     */
    setFill(actor: Actor, xFill: boolean, yFill: boolean): void
    /**
     * Sets whether the size of `layout` children should be
     * homogeneous
     */
    setHomogeneous(homogeneous: boolean): void
    /**
     * Sets the orientation of the #ClutterBoxLayout layout manager.
     */
    setOrientation(orientation: Orientation): void
    /**
     * Sets whether children of `layout` should be layed out by appending
     * them or by prepending them
     */
    setPackStart(packStart: boolean): void
    /**
     * Sets the spacing between children of `layout`
     */
    setSpacing(spacing: number): void
    /**
     * Sets whether `layout` should animate changes in the layout properties
     * 
     * The duration of the animations is controlled by
     * clutter_box_layout_set_easing_duration(); the easing mode to be used
     * by the animations is controlled by clutter_box_layout_set_easing_mode().
     * 
     * Enabling animations will override the easing state of each child
     * of the actor using `layout,` and will use the #ClutterBoxLayout:easing-mode
     * and #ClutterBoxLayout:easing-duration properties instead.
     */
    setUseAnimations(animate: boolean): void
    /**
     * Sets whether `layout` should arrange its children vertically alongside
     * the Y axis, instead of horizontally alongside the X axis
     */
    setVertical(vertical: boolean): void
    /* Methods of Clutter-1.0.Clutter.LayoutManager */
    /**
     * Allocates the children of `container` given an area
     * 
     * See also clutter_actor_allocate()
     */
    allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void
    /**
     * Begins an animation of `duration` milliseconds, using the provided
     * easing `mode`
     * 
     * The easing mode can be specified either as a #ClutterAnimationMode
     * or as a logical id returned by clutter_alpha_register_func()
     * 
     * The result of this function depends on the `manager` implementation
     */
    beginAnimation(duration: number, mode: number): Alpha
    /**
     * Gets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     * 
     * The #GValue must already be initialized to the type of the property
     * and has to be unset with g_value_unset() after extracting the real
     * value out of it
     */
    childGetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Sets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     */
    childSetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Ends an animation started by clutter_layout_manager_begin_animation()
     * 
     * The result of this call depends on the `manager` implementation
     */
    endAnimation(): void
    /**
     * Retrieves the #GParamSpec for the layout property `name` inside
     * the #ClutterLayoutMeta sub-class used by `manager`
     */
    findChildProperty(name: string): GObject.ParamSpec
    /**
     * Retrieves the progress of the animation, if one has been started by
     * clutter_layout_manager_begin_animation()
     * 
     * The returned value has the same semantics of the #ClutterAlpha:alpha
     * value
     */
    getAnimationProgress(): number
    /**
     * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
     * to the `actor` child of `container,` eventually by creating one if the
     * #ClutterLayoutManager supports layout properties
     */
    getChildMeta(container: Container, actor: Actor): LayoutMeta
    /**
     * Computes the minimum and natural heights of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_height()
     */
    getPreferredHeight(container: Container, forWidth: number): [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    /**
     * Computes the minimum and natural widths of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_width()
     */
    getPreferredWidth(container: Container, forHeight: number): [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    /**
     * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
     * 
     * This function should only be called by implementations of the
     * #ClutterLayoutManager class
     */
    layoutChanged(): void
    /**
     * Retrieves all the #GParamSpec<!-- -->s for the layout properties
     * stored inside the #ClutterLayoutMeta sub-class used by `manager`
     */
    listChildProperties(): GObject.ParamSpec[]
    /**
     * If the #ClutterLayoutManager sub-class allows it, allow
     * adding a weak reference of the `container` using `manager`
     * from within the layout manager
     * 
     * The layout manager should not increase the reference
     * count of the `container`
     */
    setContainer(container?: Container | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.LayoutManager */
    /**
     * The ::layout-changed signal is emitted each time a layout manager
     * has been changed. Every #ClutterActor using the `manager` instance
     * as a layout manager should connect a handler to the ::layout-changed
     * signal and queue a relayout on themselves:
     * 
     * |[
     *   static void layout_changed (ClutterLayoutManager *manager,
     *                               ClutterActor         *self)
     *   {
     *     clutter_actor_queue_relayout (self);
     *   }
     *   ...
     *     self->manager = g_object_ref_sink (manager);
     *     g_signal_connect (self->manager, "layout-changed",
     *                       G_CALLBACK (layout_changed),
     *                       self);
     * ```
     * 
     * 
     * Sub-classes of #ClutterLayoutManager that implement a layout that
     * can be controlled or changed using parameters should emit the
     * ::layout-changed signal whenever one of the parameters changes,
     * by using clutter_layout_manager_layout_changed().
     */
    connect(sigName: "layout-changed", callback: (() => void)): number
    on(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "layout-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "layout-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::easing-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::easing-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::easing-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::easing-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::easing-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::easing-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::easing-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::easing-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::easing-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::easing-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::orientation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::orientation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pack-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pack-start", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pack-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pack-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pack-start", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::use-animations", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-animations", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::use-animations", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::use-animations", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::use-animations", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::vertical", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vertical", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::vertical", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::vertical", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::vertical", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BoxLayout_ConstructProps)
    _init (config?: BoxLayout_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): BoxLayout
    static $gtype: GObject.Type
}
interface BrightnessContrastEffect_ConstructProps extends OffscreenEffect_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.BrightnessContrastEffect */
    /**
     * The brightness change to apply to the effect.
     * 
     * This property uses a #ClutterColor to represent the changes to each
     * color channel. The range is [ 0, 255 ], with 127 as the value used
     * to indicate no change; values smaller than 127 indicate a decrease
     * in brightness, and values larger than 127 indicate an increase in
     * brightness.
     */
    brightness?: Color
    /**
     * The contrast change to apply to the effect.
     * 
     * This property uses a #ClutterColor to represent the changes to each
     * color channel. The range is [ 0, 255 ], with 127 as the value used
     * to indicate no change; values smaller than 127 indicate a decrease
     * in contrast, and values larger than 127 indicate an increase in
     * contrast.
     */
    contrast?: Color
}
class BrightnessContrastEffect {
    /* Properties of Clutter-1.0.Clutter.BrightnessContrastEffect */
    /**
     * The brightness change to apply to the effect.
     * 
     * This property uses a #ClutterColor to represent the changes to each
     * color channel. The range is [ 0, 255 ], with 127 as the value used
     * to indicate no change; values smaller than 127 indicate a decrease
     * in brightness, and values larger than 127 indicate an increase in
     * brightness.
     */
    brightness: Color
    /**
     * The contrast change to apply to the effect.
     * 
     * This property uses a #ClutterColor to represent the changes to each
     * color channel. The range is [ 0, 255 ], with 127 as the value used
     * to indicate no change; values smaller than 127 indicate a decrease
     * in contrast, and values larger than 127 indicate an increase in
     * contrast.
     */
    contrast: Color
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.BrightnessContrastEffect */
    /**
     * Retrieves the change in brightness used by `effect`.
     */
    getBrightness(): [ /* red */ number | null, /* green */ number | null, /* blue */ number | null ]
    /**
     * Retrieves the contrast value used by `effect`.
     */
    getContrast(): [ /* red */ number | null, /* green */ number | null, /* blue */ number | null ]
    /**
     * The range of `brightness` is [-1.0, 1.0], where 0.0 designates no change;
     * a value below 0.0 indicates a decrease in brightness; and a value
     * above 0.0 indicates an increase of brightness.
     */
    setBrightness(brightness: number): void
    /**
     * The range for each component is [-1.0, 1.0] where 0.0 designates no change,
     * values below 0.0 mean a decrease in brightness, and values above indicate
     * an increase.
     */
    setBrightnessFull(red: number, green: number, blue: number): void
    /**
     * The range for `contrast` is [-1.0, 1.0], where 0.0 designates no change;
     * a value below 0.0 indicates a decrease in contrast; and a value above
     * 0.0 indicates an increase.
     */
    setContrast(contrast: number): void
    /**
     * The range for each component is [-1.0, 1.0] where 0.0 designates no change,
     * values below 0.0 mean a decrease in contrast, and values above indicate
     * an increase.
     */
    setContrastFull(red: number, green: number, blue: number): void
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::brightness", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::brightness", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::brightness", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::brightness", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::brightness", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contrast", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contrast", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contrast", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contrast", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contrast", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BrightnessContrastEffect_ConstructProps)
    _init (config?: BrightnessContrastEffect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): BrightnessContrastEffect
    static $gtype: GObject.Type
}
interface CairoTexture_ConstructProps extends Texture_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.CairoTexture */
    /**
     * Controls whether the #ClutterCairoTexture should automatically
     * resize the Cairo surface whenever the actor's allocation changes.
     * If :auto-resize is set to %TRUE the surface contents will also
     * be invalidated automatically.
     */
    autoResize?: boolean
    /**
     * The height of the Cairo surface used by the #ClutterCairoTexture
     * actor, in pixels.
     */
    surfaceHeight?: number
    /**
     * The width of the Cairo surface used by the #ClutterCairoTexture
     * actor, in pixels.
     */
    surfaceWidth?: number
}
class CairoTexture {
    /* Properties of Clutter-1.0.Clutter.CairoTexture */
    /**
     * Controls whether the #ClutterCairoTexture should automatically
     * resize the Cairo surface whenever the actor's allocation changes.
     * If :auto-resize is set to %TRUE the surface contents will also
     * be invalidated automatically.
     */
    autoResize: boolean
    /**
     * The height of the Cairo surface used by the #ClutterCairoTexture
     * actor, in pixels.
     */
    surfaceHeight: number
    /**
     * The width of the Cairo surface used by the #ClutterCairoTexture
     * actor, in pixels.
     */
    surfaceWidth: number
    /* Properties of Clutter-1.0.Clutter.Texture */
    /**
     * The path of the file containing the image data to be displayed by
     * the texture.
     * 
     * This property is unset when using the clutter_texture_set_from_*_data()
     * family of functions.
     */
    filename: string
    filterQuality: TextureQuality
    keepAspectRatio: boolean
    /**
     * Tries to load a texture from a filename by using a local thread to perform
     * the read operations. The initially created texture has dimensions 0x0 when
     * the true size becomes available the #ClutterTexture::size-change signal is
     * emitted and when the image has completed loading the
     * #ClutterTexture::load-finished signal is emitted.
     * 
     * Threading is only enabled if g_thread_init() has been called prior to
     * clutter_init(), otherwise #ClutterTexture will use the main loop to load
     * the image.
     * 
     * The upload of the texture data on the GL pipeline is not asynchronous, as
     * it must be performed from within the same thread that called
     * clutter_main().
     */
    loadAsync: boolean
    /**
     * Like #ClutterTexture:load-async but loads the width and height
     * synchronously causing some blocking.
     */
    loadDataAsync: boolean
    pickWithAlpha: boolean
    readonly pixelFormat: Cogl.PixelFormat
    repeatX: boolean
    repeatY: boolean
    syncSize: boolean
    readonly tileWaste: number
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.CairoTexture */
    /**
     * Clears `self'`s internal drawing surface, so that the next upload
     * will replace the previous contents of the #ClutterCairoTexture
     * rather than adding to it.
     * 
     * Calling this function from within a #ClutterCairoTexture::draw
     * signal handler will clear the invalidated area.
     */
    clear(): void
    /**
     * Creates a new Cairo context for the `cairo` texture. It is
     * similar to using clutter_cairo_texture_create_region() with `x_offset`
     * and `y_offset` of 0, `width` equal to the `cairo` texture surface width
     * and `height` equal to the `cairo` texture surface height.
     * 
     * Do not call this function within the paint virtual
     * function or from a callback to the #ClutterActor::paint
     * signal.
     */
    create(): cairo.Context
    /**
     * Creates a new Cairo context that will updat the region defined
     * by `x_offset,` `y_offset,` `width` and `height`.
     * 
     * Do not call this function within the paint virtual
     * function or from a callback to the #ClutterActor::paint
     * signal.
     */
    createRegion(xOffset: number, yOffset: number, width: number, height: number): cairo.Context
    /**
     * Retrieves the value set using clutter_cairo_texture_set_auto_resize().
     */
    getAutoResize(): boolean
    /**
     * Retrieves the surface width and height for `self`.
     */
    getSurfaceSize(): [ /* width */ number, /* height */ number ]
    /**
     * Invalidates the whole surface of a #ClutterCairoTexture.
     * 
     * This function will cause the #ClutterCairoTexture::draw signal
     * to be emitted.
     * 
     * See also: clutter_cairo_texture_invalidate_rectangle()
     */
    invalidate(): void
    /**
     * Invalidates a rectangular region of a #ClutterCairoTexture.
     * 
     * The invalidation will cause the #ClutterCairoTexture::draw signal
     * to be emitted.
     * 
     * See also: clutter_cairo_texture_invalidate()
     */
    invalidateRectangle(rect?: cairo.RectangleInt | null): void
    /**
     * Sets whether the #ClutterCairoTexture should ensure that the
     * backing Cairo surface used matches the allocation assigned to
     * the actor. If the allocation changes, the contents of the
     * #ClutterCairoTexture will also be invalidated automatically.
     */
    setAutoResize(value: boolean): void
    /**
     * Resizes the Cairo surface used by `self` to `width` and `height`.
     * 
     * This function will not invalidate the contents of the Cairo
     * texture: you will have to explicitly call either
     * clutter_cairo_texture_invalidate_rectangle() or
     * clutter_cairo_texture_invalidate().
     */
    setSurfaceSize(width: number, height: number): void
    /* Methods of Clutter-1.0.Clutter.Texture */
    /**
     * Gets the size in pixels of the untransformed underlying image
     */
    getBaseSize(): [ /* width */ number, /* height */ number ]
    /**
     * Returns a handle to the underlying COGL material used for drawing
     * the actor.
     */
    getCoglMaterial(): Cogl.Handle
    /**
     * Retrieves the handle to the underlying COGL texture used for drawing
     * the actor. No extra reference is taken so if you need to keep the
     * handle then you should call cogl_handle_ref() on it.
     * 
     * The texture handle returned is the first layer of the material
     * handle used by the #ClutterTexture. If you need to access the other
     * layers you should use clutter_texture_get_cogl_material() instead
     * and use the #CoglMaterial API.
     */
    getCoglTexture(): Cogl.Handle
    /**
     * Gets the filter quality used when scaling a texture.
     */
    getFilterQuality(): TextureQuality
    /**
     * Retrieves the value set using clutter_texture_set_keep_aspect_ratio()
     */
    getKeepAspectRatio(): boolean
    /**
     * Retrieves the value set using clutter_texture_set_load_async()
     */
    getLoadAsync(): boolean
    /**
     * Retrieves the value set by clutter_texture_set_load_data_async()
     */
    getLoadDataAsync(): boolean
    /**
     * Gets the maximum waste that will be used when creating a texture or
     * -1 if slicing is disabled.
     */
    getMaxTileWaste(): number
    /**
     * Retrieves the value set by clutter_texture_set_load_data_async()
     */
    getPickWithAlpha(): boolean
    /**
     * Retrieves the pixel format used by `texture`. This is
     * equivalent to:
     * 
     * |[
     *   handle = clutter_texture_get_pixel_format (texture);
     * 
     *   if (handle != COGL_INVALID_HANDLE)
     *     format = cogl_texture_get_format (handle);
     * ```
     * 
     */
    getPixelFormat(): Cogl.PixelFormat
    /**
     * Retrieves the horizontal and vertical repeat values set
     * using clutter_texture_set_repeat()
     */
    getRepeat(): [ /* repeatX */ boolean, /* repeatY */ boolean ]
    /**
     * Retrieves the value set with clutter_texture_set_sync_size()
     */
    getSyncSize(): boolean
    /**
     * Updates a sub-region of the pixel data in a #ClutterTexture.
     */
    setAreaFromRgbData(data: Uint8Array, hasAlpha: boolean, x: number, y: number, width: number, height: number, rowstride: number, bpp: number, flags: TextureFlags): boolean
    /**
     * Replaces the underlying Cogl material drawn by this actor with
     * `cogl_material`. A reference to the material is taken so if the
     * handle is no longer needed it should be deref'd with
     * cogl_handle_unref. Texture data is attached to the material so
     * calling this function also replaces the Cogl
     * texture. #ClutterTexture requires that the material have a texture
     * layer so you should set one on the material before calling this
     * function.
     */
    setCoglMaterial(coglMaterial: Cogl.Handle): void
    /**
     * Replaces the underlying COGL texture drawn by this actor with
     * `cogl_tex`. A reference to the texture is taken so if the handle is
     * no longer needed it should be deref'd with cogl_handle_unref.
     */
    setCoglTexture(coglTex: Cogl.Handle): void
    /**
     * Sets the filter quality when scaling a texture. The quality is an
     * enumeration currently the following values are supported:
     * %CLUTTER_TEXTURE_QUALITY_LOW which is fast but only uses nearest neighbour
     * interpolation. %CLUTTER_TEXTURE_QUALITY_MEDIUM which is computationally a
     * bit more expensive (bilinear interpolation), and
     * %CLUTTER_TEXTURE_QUALITY_HIGH which uses extra texture memory resources to
     * improve scaled down rendering as well (by using mipmaps). The default value
     * is %CLUTTER_TEXTURE_QUALITY_MEDIUM.
     */
    setFilterQuality(filterQuality: TextureQuality): void
    /**
     * Sets the #ClutterTexture image data from an image file. In case of
     * failure, %FALSE is returned and `error` is set.
     * 
     * If #ClutterTexture:load-async is set to %TRUE, this function
     * will return as soon as possible, and the actual image loading
     * from disk will be performed asynchronously. #ClutterTexture::size-change
     * will be emitten when the size of the texture is available and
     * #ClutterTexture::load-finished will be emitted when the image has been
     * loaded or if an error occurred.
     */
    setFromFile(filename: string): boolean
    /**
     * Sets #ClutterTexture image data.
     */
    setFromRgbData(data: Uint8Array, hasAlpha: boolean, width: number, height: number, rowstride: number, bpp: number, flags: TextureFlags): boolean
    /**
     * Sets a #ClutterTexture from YUV image data. If an error occurred,
     * %FALSE is returned and `error` is set.
     * 
     * The YUV support depends on the driver; the format supported by the
     * few drivers exposing this capability are not really useful.
     * 
     * The proper way to convert image data in any YUV colorspace to any
     * RGB colorspace is to use a fragment shader associated with the
     * #ClutterTexture material.
     */
    setFromYuvData(data: Uint8Array, width: number, height: number, flags: TextureFlags): boolean
    /**
     * Sets whether `texture` should have a preferred size maintaining
     * the aspect ratio of the underlying image
     */
    setKeepAspectRatio(keepAspect: boolean): void
    /**
     * Sets whether `texture` should use a worker thread to load the data
     * from disk asynchronously. Setting `load_async` to %TRUE will make
     * clutter_texture_set_from_file() return immediately.
     * 
     * See the #ClutterTexture:load-async property documentation, and
     * clutter_texture_set_load_data_async().
     */
    setLoadAsync(loadAsync: boolean): void
    /**
     * Sets whether `texture` should use a worker thread to load the data
     * from disk asynchronously. Setting `load_async` to %TRUE will make
     * clutter_texture_set_from_file() block until the #ClutterTexture has
     * determined the width and height of the image data.
     * 
     * See the #ClutterTexture:load-async property documentation, and
     * clutter_texture_set_load_async().
     */
    setLoadDataAsync(loadAsync: boolean): void
    /**
     * Sets whether `texture` should have it's shape defined by the alpha
     * channel when picking.
     * 
     * Be aware that this is a bit more costly than the default picking
     * due to the texture lookup, extra test against the alpha value and
     * the fact that it will also interrupt the batching of geometry done
     * internally.
     * 
     * Also there is currently no control over the threshold used to
     * determine what value of alpha is considered pickable, and so only
     * fully opaque parts of the texture will react to picking.
     */
    setPickWithAlpha(pickWithAlpha: boolean): void
    /**
     * Sets whether the `texture` should repeat horizontally or
     * vertically when the actor size is bigger than the image size
     */
    setRepeat(repeatX: boolean, repeatY: boolean): void
    /**
     * Sets whether `texture` should have the same preferred size as the
     * underlying image data.
     */
    setSyncSize(syncSize: boolean): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.CairoTexture */
    /**
     * The ::create-surface signal is emitted when a #ClutterCairoTexture
     * news its surface (re)created, which happens either when the Cairo
     * context is created with clutter_cairo_texture_create() or
     * clutter_cairo_texture_create_region(), or when the surface is resized
     * through clutter_cairo_texture_set_surface_size().
     * 
     * The first signal handler that returns a non-%NULL, valid surface will
     * stop any further signal emission, and the returned surface will be
     * the one used.
     */
    connect(sigName: "create-surface", callback: ((width: number, height: number) => cairo.Surface)): number
    on(sigName: "create-surface", callback: (width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "create-surface", callback: (width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "create-surface", callback: (width: number, height: number) => void): NodeJS.EventEmitter
    emit(sigName: "create-surface", width: number, height: number): void
    /**
     * The ::draw signal is emitted each time a #ClutterCairoTexture has
     * been invalidated.
     * 
     * The passed Cairo context passed will be clipped to the invalidated
     * area.
     * 
     * It is safe to connect multiple callbacks to this signals; the state
     * of the Cairo context passed to each callback is automatically saved
     * and restored, so it's not necessary to call cairo_save() and
     * cairo_restore().
     */
    connect(sigName: "draw", callback: ((cr: cairo.Context) => boolean)): number
    on(sigName: "draw", callback: (cr: cairo.Context) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "draw", callback: (cr: cairo.Context) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "draw", callback: (cr: cairo.Context) => void): NodeJS.EventEmitter
    emit(sigName: "draw", cr: cairo.Context): void
    /* Signals of Clutter-1.0.Clutter.Texture */
    /**
     * The ::load-finished signal is emitted when a texture load has
     * completed. If there was an error during loading, `error` will
     * be set, otherwise it will be %NULL
     */
    connect(sigName: "load-finished", callback: ((error: GLib.Error) => void)): number
    on(sigName: "load-finished", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "load-finished", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "load-finished", callback: (error: GLib.Error) => void): NodeJS.EventEmitter
    emit(sigName: "load-finished", error: GLib.Error): void
    /**
     * The ::pixbuf-change signal is emitted each time the pixbuf
     * used by `texture` changes.
     */
    connect(sigName: "pixbuf-change", callback: (() => void)): number
    on(sigName: "pixbuf-change", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pixbuf-change", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pixbuf-change", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "pixbuf-change"): void
    /**
     * The ::size-change signal is emitted each time the size of the
     * pixbuf used by `texture` changes.  The new size is given as
     * argument to the callback.
     */
    connect(sigName: "size-change", callback: ((width: number, height: number) => void)): number
    on(sigName: "size-change", callback: (width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "size-change", callback: (width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "size-change", callback: (width: number, height: number) => void): NodeJS.EventEmitter
    emit(sigName: "size-change", width: number, height: number): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::auto-resize", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-resize", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auto-resize", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auto-resize", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auto-resize", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::surface-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::surface-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::surface-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::surface-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::surface-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::surface-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::surface-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::surface-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::surface-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::surface-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filter-quality", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filter-quality", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filter-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filter-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filter-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::keep-aspect-ratio", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::keep-aspect-ratio", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::keep-aspect-ratio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::keep-aspect-ratio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::keep-aspect-ratio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::load-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::load-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::load-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::load-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::load-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::load-data-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::load-data-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::load-data-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::load-data-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::load-data-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pick-with-alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pick-with-alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pick-with-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pick-with-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pick-with-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pixel-format", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pixel-format", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pixel-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pixel-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pixel-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::sync-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sync-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::sync-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::sync-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::sync-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::tile-waste", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tile-waste", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::tile-waste", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::tile-waste", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::tile-waste", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CairoTexture_ConstructProps)
    _init (config?: CairoTexture_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(width: number, height: number): CairoTexture
    /* Function overloads */
    static new(): CairoTexture
    static new(): CairoTexture
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
interface Canvas_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Canvas */
    /**
     * The height of the canvas.
     */
    height?: number
    /**
     * The scaling factor to be applied to the Cairo surface used for
     * drawing.
     * 
     * If #ClutterCanvas:scale-factor is set to a negative value, the
     * value of the #ClutterSettings:window-scaling-factor property is
     * used instead.
     * 
     * Use #ClutterCanvas:scale-factor-set to check if the scale factor
     * is set.
     */
    scaleFactor?: number
    /**
     * The width of the canvas.
     */
    width?: number
}
class Canvas {
    /* Properties of Clutter-1.0.Clutter.Canvas */
    /**
     * The height of the canvas.
     */
    height: number
    /**
     * The scaling factor to be applied to the Cairo surface used for
     * drawing.
     * 
     * If #ClutterCanvas:scale-factor is set to a negative value, the
     * value of the #ClutterSettings:window-scaling-factor property is
     * used instead.
     * 
     * Use #ClutterCanvas:scale-factor-set to check if the scale factor
     * is set.
     */
    scaleFactor: number
    /**
     * Whether the #ClutterCanvas:scale-factor property is set.
     * 
     * If the #ClutterCanvas:scale-factor-set property is %FALSE
     * then #ClutterCanvas will use the #ClutterSettings:window-scaling-factor
     * property.
     */
    readonly scaleFactorSet: boolean
    /**
     * The width of the canvas.
     */
    width: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Canvas */
    /**
     * Retrieves the scaling factor of `canvas,` as set using
     * clutter_canvas_set_scale_factor().
     */
    getScaleFactor(): number
    /**
     * Sets the scaling factor for the Cairo surface used by `canvas`.
     * 
     * This function should rarely be used.
     * 
     * The default scaling factor of a #ClutterCanvas content uses the
     * #ClutterSettings:window-scaling-factor property, which is set by
     * the windowing system. By using this function it is possible to
     * override that setting.
     * 
     * Changing the scale factor will invalidate the `canvas`.
     */
    setScaleFactor(scale: number): void
    /**
     * Sets the size of the `canvas,` and invalidates the content.
     * 
     * This function will cause the `canvas` to be invalidated only
     * if the size of the canvas surface has changed.
     * 
     * If you want to invalidate the contents of the `canvas` when setting
     * the size, you can use the return value of the function to conditionally
     * call clutter_content_invalidate():
     * 
     * |[
     *   if (!clutter_canvas_set_size (canvas, width, height))
     *     clutter_content_invalidate (CLUTTER_CONTENT (canvas));
     * ```
     * 
     */
    setSize(width: number, height: number): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Content */
    /**
     * Retrieves the natural size of the `content,` if any.
     * 
     * The natural size of a #ClutterContent is defined as the size the content
     * would have regardless of the allocation of the actor that is painting it,
     * for instance the size of an image data.
     */
    getPreferredSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Invalidates a #ClutterContent.
     * 
     * This function should be called by #ClutterContent implementations when
     * they change the way a the content should be painted regardless of the
     * actor state.
     */
    invalidate(): void
    /* Signals of Clutter-1.0.Clutter.Canvas */
    /**
     * The #ClutterCanvas::draw signal is emitted each time a canvas is
     * invalidated.
     * 
     * It is safe to connect multiple handlers to this signal: each
     * handler invocation will be automatically protected by cairo_save()
     * and cairo_restore() pairs.
     */
    connect(sigName: "draw", callback: ((cr: cairo.Context, width: number, height: number) => boolean)): number
    on(sigName: "draw", callback: (cr: cairo.Context, width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "draw", callback: (cr: cairo.Context, width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "draw", callback: (cr: cairo.Context, width: number, height: number) => void): NodeJS.EventEmitter
    emit(sigName: "draw", cr: cairo.Context, width: number, height: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Content */
    /**
     * This signal is emitted each time a #ClutterContent implementation is
     * assigned to a #ClutterActor.
     */
    connect(sigName: "attached", callback: ((actor: Actor) => void)): number
    on(sigName: "attached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "attached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "attached", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "attached", actor: Actor): void
    /**
     * This signal is emitted each time a #ClutterContent implementation is
     * removed from a #ClutterActor.
     */
    connect(sigName: "detached", callback: ((actor: Actor) => void)): number
    on(sigName: "detached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "detached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "detached", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "detached", actor: Actor): void
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-factor-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-factor-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-factor-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-factor-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-factor-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Canvas_ConstructProps)
    _init (config?: Canvas_ConstructProps): void
    static $gtype: GObject.Type
}
interface ChildMeta_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ChildMeta */
    /**
     * The #ClutterActor being wrapped by this #ClutterChildMeta
     */
    actor?: Actor
    /**
     * The #ClutterContainer that created this #ClutterChildMeta.
     */
    container?: Container
}
class ChildMeta {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ChildMeta */
    /**
     * Retrieves the actor wrapped by `data`
     */
    getActor(): Actor
    /**
     * Retrieves the container using `data`
     */
    getContainer(): Container
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ChildMeta_ConstructProps)
    _init (config?: ChildMeta_ConstructProps): void
    static $gtype: GObject.Type
}
interface ClickAction_ConstructProps extends Action_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ClickAction */
    /**
     * The minimum duration of a press for it to be recognized as a long
     * press gesture, in milliseconds.
     * 
     * A value of -1 will make the #ClutterClickAction use the value of
     * the #ClutterSettings:long-press-duration property.
     */
    longPressDuration?: number
    /**
     * The maximum allowed distance that can be covered (on both axes) before
     * a long press gesture is cancelled, in pixels.
     * 
     * A value of -1 will make the #ClutterClickAction use the value of
     * the #ClutterSettings:dnd-drag-threshold property.
     */
    longPressThreshold?: number
}
class ClickAction {
    /* Properties of Clutter-1.0.Clutter.ClickAction */
    /**
     * Whether the clickable actor has the pointer grabbed
     */
    readonly held: boolean
    /**
     * The minimum duration of a press for it to be recognized as a long
     * press gesture, in milliseconds.
     * 
     * A value of -1 will make the #ClutterClickAction use the value of
     * the #ClutterSettings:long-press-duration property.
     */
    longPressDuration: number
    /**
     * The maximum allowed distance that can be covered (on both axes) before
     * a long press gesture is cancelled, in pixels.
     * 
     * A value of -1 will make the #ClutterClickAction use the value of
     * the #ClutterSettings:dnd-drag-threshold property.
     */
    longPressThreshold: number
    /**
     * Whether the clickable actor should be in "pressed" state
     */
    readonly pressed: boolean
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ClickAction */
    /**
     * Retrieves the button that was pressed.
     */
    getButton(): number
    /**
     * Retrieves the screen coordinates of the button press.
     */
    getCoords(): [ /* pressX */ number, /* pressY */ number ]
    /**
     * Retrieves the modifier state of the click action.
     */
    getState(): ModifierType
    /**
     * Emulates a release of the pointer button, which ungrabs the pointer
     * and unsets the #ClutterClickAction:pressed state.
     * 
     * This function will also cancel the long press gesture if one was
     * initiated.
     * 
     * This function is useful to break a grab, for instance after a certain
     * amount of time has passed.
     */
    release(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.ClickAction */
    /**
     * The ::clicked signal is emitted when the #ClutterActor to which
     * a #ClutterClickAction has been applied should respond to a
     * pointer button press and release events
     */
    connect(sigName: "clicked", callback: ((actor: Actor) => void)): number
    on(sigName: "clicked", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "clicked", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "clicked", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "clicked", actor: Actor): void
    /**
     * The ::long-press signal is emitted during the long press gesture
     * handling.
     * 
     * This signal can be emitted multiple times with different states.
     * 
     * The %CLUTTER_LONG_PRESS_QUERY state will be emitted on button presses,
     * and its return value will determine whether the long press handling
     * should be initiated. If the signal handlers will return %TRUE, the
     * %CLUTTER_LONG_PRESS_QUERY state will be followed either by a signal
     * emission with the %CLUTTER_LONG_PRESS_ACTIVATE state if the long press
     * constraints were respected, or by a signal emission with the
     * %CLUTTER_LONG_PRESS_CANCEL state if the long press was cancelled.
     * 
     * It is possible to forcibly cancel a long press detection using
     * clutter_click_action_release().
     */
    connect(sigName: "long-press", callback: ((actor: Actor, state: LongPressState) => boolean)): number
    on(sigName: "long-press", callback: (actor: Actor, state: LongPressState) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "long-press", callback: (actor: Actor, state: LongPressState) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "long-press", callback: (actor: Actor, state: LongPressState) => void): NodeJS.EventEmitter
    emit(sigName: "long-press", actor: Actor, state: LongPressState): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::held", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::held", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::held", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::held", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::held", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::long-press-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::long-press-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::long-press-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::long-press-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::long-press-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::long-press-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::long-press-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::long-press-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::long-press-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::long-press-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pressed", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pressed", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pressed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pressed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pressed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ClickAction_ConstructProps)
    _init (config?: ClickAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): ClickAction
    static $gtype: GObject.Type
}
class ClipNode {
    /* Methods of Clutter-1.0.Clutter.PaintNode */
    /**
     * Adds `child` to the list of children of `node`.
     * 
     * This function will acquire a reference on `child`.
     */
    addChild(child: PaintNode): void
    /**
     * Adds a rectangle region to the `node,` as described by the
     * passed `rect`.
     */
    addRectangle(rect: ActorBox): void
    /**
     * Adds a rectangle region to the `node,` with texture coordinates.
     */
    addTextureRectangle(rect: ActorBox, x1: number, y1: number, x2: number, y2: number): void
    /**
     * Acquires a reference on `node`.
     */
    ref(): PaintNode
    /**
     * Sets a user-readable `name` for `node`.
     * 
     * The `name` will be used for debugging purposes.
     * 
     * The `node` will copy the passed string.
     */
    setName(name: string): void
    /**
     * Releases a reference on `node`.
     */
    unref(): void
    static name: string
    static new(): ClipNode
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): ClipNode
}
interface Clone_ConstructProps extends Actor_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Clone */
    /**
     * This property specifies the source actor being cloned.
     */
    source?: Actor
}
class Clone {
    /* Properties of Clutter-1.0.Clutter.Clone */
    /**
     * This property specifies the source actor being cloned.
     */
    source: Actor
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Clone */
    /**
     * Retrieves the source #ClutterActor being cloned by `self`.
     */
    getSource(): Actor
    /**
     * Sets `source` as the source actor to be cloned by `self`.
     */
    setSource(source?: Actor | null): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Clone_ConstructProps)
    _init (config?: Clone_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(source: Actor): Clone
    /* Function overloads */
    static new(): Clone
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
class ColorNode {
    /* Methods of Clutter-1.0.Clutter.PaintNode */
    /**
     * Adds `child` to the list of children of `node`.
     * 
     * This function will acquire a reference on `child`.
     */
    addChild(child: PaintNode): void
    /**
     * Adds a rectangle region to the `node,` as described by the
     * passed `rect`.
     */
    addRectangle(rect: ActorBox): void
    /**
     * Adds a rectangle region to the `node,` with texture coordinates.
     */
    addTextureRectangle(rect: ActorBox, x1: number, y1: number, x2: number, y2: number): void
    /**
     * Acquires a reference on `node`.
     */
    ref(): PaintNode
    /**
     * Sets a user-readable `name` for `node`.
     * 
     * The `name` will be used for debugging purposes.
     * 
     * The `node` will copy the passed string.
     */
    setName(name: string): void
    /**
     * Releases a reference on `node`.
     */
    unref(): void
    static name: string
    static new(color?: Color | null): ColorNode
    constructor(color?: Color | null)
    /* Static methods and pseudo-constructors */
    static new(color?: Color | null): ColorNode
}
interface ColorizeEffect_ConstructProps extends OffscreenEffect_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ColorizeEffect */
    /**
     * The tint to apply to the actor
     */
    tint?: Color
}
class ColorizeEffect {
    /* Properties of Clutter-1.0.Clutter.ColorizeEffect */
    /**
     * The tint to apply to the actor
     */
    tint: Color
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ColorizeEffect */
    /**
     * Retrieves the tint used by `effect`
     */
    getTint(): /* tint */ Color
    /**
     * Sets the tint to be used when colorizing
     */
    setTint(tint: Color): void
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::tint", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tint", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::tint", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::tint", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::tint", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ColorizeEffect_ConstructProps)
    _init (config?: ColorizeEffect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(tint: Color): ColorizeEffect
    static $gtype: GObject.Type
}
interface Constraint_ConstructProps extends ActorMeta_ConstructProps {
}
class Constraint {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Constraint_ConstructProps)
    _init (config?: Constraint_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeformEffect_ConstructProps extends OffscreenEffect_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.DeformEffect */
    /**
     * The number of horizontal tiles. The bigger the number, the
     * smaller the tiles
     */
    xTiles?: number
    /**
     * The number of vertical tiles. The bigger the number, the
     * smaller the tiles
     */
    yTiles?: number
}
class DeformEffect {
    /* Properties of Clutter-1.0.Clutter.DeformEffect */
    /**
     * The number of horizontal tiles. The bigger the number, the
     * smaller the tiles
     */
    xTiles: number
    /**
     * The number of vertical tiles. The bigger the number, the
     * smaller the tiles
     */
    yTiles: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.DeformEffect */
    /**
     * Retrieves the handle to the back face material used by `effect`
     */
    getBackMaterial(): Cogl.Handle
    /**
     * Retrieves the number of horizontal and vertical tiles used to sub-divide
     * the actor's geometry during the effect
     */
    getNTiles(): [ /* xTiles */ number, /* yTiles */ number ]
    /**
     * Invalidates the `effect<`!-- -->'s vertices and, if it is associated
     * to an actor, it will queue a redraw
     */
    invalidate(): void
    /**
     * Sets the material that should be used when drawing the back face
     * of the actor during a deformation
     * 
     * The #ClutterDeformEffect will take a reference on the material's
     * handle
     */
    setBackMaterial(material?: Cogl.Handle | null): void
    /**
     * Sets the number of horizontal and vertical tiles to be used
     * when applying the effect
     * 
     * More tiles allow a finer grained deformation at the expenses
     * of computation
     */
    setNTiles(xTiles: number, yTiles: number): void
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::x-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DeformEffect_ConstructProps)
    _init (config?: DeformEffect_ConstructProps): void
    static $gtype: GObject.Type
}
interface DesaturateEffect_ConstructProps extends OffscreenEffect_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.DesaturateEffect */
    /**
     * The desaturation factor, between 0.0 (no desaturation) and 1.0 (full
     * desaturation).
     */
    factor?: number
}
class DesaturateEffect {
    /* Properties of Clutter-1.0.Clutter.DesaturateEffect */
    /**
     * The desaturation factor, between 0.0 (no desaturation) and 1.0 (full
     * desaturation).
     */
    factor: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.DesaturateEffect */
    /**
     * Retrieves the desaturation factor of `effect`
     */
    getFactor(): number
    /**
     * Sets the desaturation factor for `effect,` with 0.0 being "do not desaturate"
     * and 1.0 being "fully desaturate"
     */
    setFactor(factor: number): void
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DesaturateEffect_ConstructProps)
    _init (config?: DesaturateEffect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(factor: number): DesaturateEffect
    static $gtype: GObject.Type
}
interface DeviceManager_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.DeviceManager */
    backend?: Backend
}
class DeviceManager {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.DeviceManager */
    /**
     * Retrieves the core #ClutterInputDevice of type `device_type`
     * 
     * Core devices are devices created automatically by the default
     * Clutter backend
     */
    getCoreDevice(deviceType: InputDeviceType): InputDevice
    /**
     * Retrieves the #ClutterInputDevice with the given `device_id`
     */
    getDevice(deviceId: number): InputDevice
    /**
     * Lists all currently registered input devices
     */
    listDevices(): InputDevice[]
    /**
     * Lists all currently registered input devices
     */
    peekDevices(): InputDevice[]
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.DeviceManager */
    /**
     * The ::device-added signal is emitted each time a device has been
     * added to the #ClutterDeviceManager
     */
    connect(sigName: "device-added", callback: ((device: InputDevice) => void)): number
    on(sigName: "device-added", callback: (device: InputDevice) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "device-added", callback: (device: InputDevice) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "device-added", callback: (device: InputDevice) => void): NodeJS.EventEmitter
    emit(sigName: "device-added", device: InputDevice): void
    /**
     * The ::device-removed signal is emitted each time a device has been
     * removed from the #ClutterDeviceManager
     */
    connect(sigName: "device-removed", callback: ((device: InputDevice) => void)): number
    on(sigName: "device-removed", callback: (device: InputDevice) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "device-removed", callback: (device: InputDevice) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "device-removed", callback: (device: InputDevice) => void): NodeJS.EventEmitter
    emit(sigName: "device-removed", device: InputDevice): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DeviceManager_ConstructProps)
    _init (config?: DeviceManager_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Retrieves the device manager singleton
     */
    static getDefault(): DeviceManager
    static $gtype: GObject.Type
}
interface DragAction_ConstructProps extends Action_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.DragAction */
    /**
     * Constains the dragging action (or in particular, the resulting
     * actor position) to the specified #ClutterRect, in parent's
     * coordinates.
     */
    dragArea?: Rect
    /**
     * Constraints the dragging action to the specified axis
     */
    dragAxis?: DragAxis
    /**
     * The #ClutterActor that is effectively being dragged
     * 
     * A #ClutterDragAction will, be default, use the #ClutterActor that
     * has been attached to the action; it is possible to create a
     * separate #ClutterActor and use it instead.
     * 
     * Setting this property has no effect on the #ClutterActor argument
     * passed to the #ClutterDragAction signals
     */
    dragHandle?: Actor
    /**
     * The horizontal threshold, in pixels, that the cursor must travel
     * in order to begin a drag action.
     * 
     * When set to a positive value, #ClutterDragAction will only emit
     * #ClutterDragAction::drag-begin if the pointer has moved
     * horizontally at least of the given amount of pixels since
     * the button press event.
     * 
     * When set to -1, #ClutterDragAction will use the default threshold
     * stored in the #ClutterSettings:dnd-drag-threshold property of
     * #ClutterSettings.
     * 
     * When read, this property will always return a valid drag
     * threshold, either as set or the default one.
     */
    xDragThreshold?: number
    /**
     * The vertical threshold, in pixels, that the cursor must travel
     * in order to begin a drag action.
     * 
     * When set to a positive value, #ClutterDragAction will only emit
     * #ClutterDragAction::drag-begin if the pointer has moved
     * vertically at least of the given amount of pixels since
     * the button press event.
     * 
     * When set to -1, #ClutterDragAction will use the value stored
     * in the #ClutterSettings:dnd-drag-threshold property of
     * #ClutterSettings.
     * 
     * When read, this property will always return a valid drag
     * threshold, either as set or the default one.
     */
    yDragThreshold?: number
}
class DragAction {
    /* Properties of Clutter-1.0.Clutter.DragAction */
    /**
     * Constains the dragging action (or in particular, the resulting
     * actor position) to the specified #ClutterRect, in parent's
     * coordinates.
     */
    dragArea: Rect
    /**
     * Whether the #ClutterDragAction:drag-area property has been set.
     */
    readonly dragAreaSet: boolean
    /**
     * Constraints the dragging action to the specified axis
     */
    dragAxis: DragAxis
    /**
     * The #ClutterActor that is effectively being dragged
     * 
     * A #ClutterDragAction will, be default, use the #ClutterActor that
     * has been attached to the action; it is possible to create a
     * separate #ClutterActor and use it instead.
     * 
     * Setting this property has no effect on the #ClutterActor argument
     * passed to the #ClutterDragAction signals
     */
    dragHandle: Actor
    /**
     * The horizontal threshold, in pixels, that the cursor must travel
     * in order to begin a drag action.
     * 
     * When set to a positive value, #ClutterDragAction will only emit
     * #ClutterDragAction::drag-begin if the pointer has moved
     * horizontally at least of the given amount of pixels since
     * the button press event.
     * 
     * When set to -1, #ClutterDragAction will use the default threshold
     * stored in the #ClutterSettings:dnd-drag-threshold property of
     * #ClutterSettings.
     * 
     * When read, this property will always return a valid drag
     * threshold, either as set or the default one.
     */
    xDragThreshold: number
    /**
     * The vertical threshold, in pixels, that the cursor must travel
     * in order to begin a drag action.
     * 
     * When set to a positive value, #ClutterDragAction will only emit
     * #ClutterDragAction::drag-begin if the pointer has moved
     * vertically at least of the given amount of pixels since
     * the button press event.
     * 
     * When set to -1, #ClutterDragAction will use the value stored
     * in the #ClutterSettings:dnd-drag-threshold property of
     * #ClutterSettings.
     * 
     * When read, this property will always return a valid drag
     * threshold, either as set or the default one.
     */
    yDragThreshold: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.DragAction */
    /**
     * Retrieves the "drag area" associated with `action,` that
     * is a #ClutterRect that constrains the actor movements,
     * in parents coordinates.
     */
    getDragArea(): [ /* returnType */ boolean, /* dragArea */ Rect ]
    /**
     * Retrieves the axis constraint set by clutter_drag_action_set_drag_axis()
     */
    getDragAxis(): DragAxis
    /**
     * Retrieves the drag handle set by clutter_drag_action_set_drag_handle()
     */
    getDragHandle(): Actor
    /**
     * Retrieves the values set by clutter_drag_action_set_drag_threshold().
     * 
     * If the #ClutterDragAction:x-drag-threshold property or the
     * #ClutterDragAction:y-drag-threshold property have been set to -1 then
     * this function will return the default drag threshold value as stored
     * by the #ClutterSettings:dnd-drag-threshold property of #ClutterSettings.
     */
    getDragThreshold(): [ /* xThreshold */ number, /* yThreshold */ number ]
    /**
     * Retrieves the coordinates, in stage space, of the latest motion
     * event during the dragging
     */
    getMotionCoords(): [ /* motionX */ number, /* motionY */ number ]
    /**
     * Retrieves the coordinates, in stage space, of the press event
     * that started the dragging
     */
    getPressCoords(): [ /* pressX */ number, /* pressY */ number ]
    /**
     * Sets `drag_area` to constrain the dragging of the actor associated
     * with `action,` so that it position is always within `drag_area,` expressed
     * in parent's coordinates.
     * If `drag_area` is %NULL, the actor is not constrained.
     */
    setDragArea(dragArea?: Rect | null): void
    /**
     * Restricts the dragging action to a specific axis
     */
    setDragAxis(axis: DragAxis): void
    /**
     * Sets the actor to be used as the drag handle.
     */
    setDragHandle(handle?: Actor | null): void
    /**
     * Sets the horizontal and vertical drag thresholds that must be
     * cleared by the pointer before `action` can begin the dragging.
     * 
     * If `x_threshold` or `y_threshold` are set to -1 then the default
     * drag threshold stored in the #ClutterSettings:dnd-drag-threshold
     * property of #ClutterSettings will be used.
     */
    setDragThreshold(xThreshold: number, yThreshold: number): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.DragAction */
    /**
     * The ::drag-begin signal is emitted when the #ClutterDragAction
     * starts the dragging
     * 
     * The emission of this signal can be delayed by using the
     * #ClutterDragAction:x-drag-threshold and
     * #ClutterDragAction:y-drag-threshold properties
     */
    connect(sigName: "drag-begin", callback: ((actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void)): number
    on(sigName: "drag-begin", callback: (actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "drag-begin", callback: (actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "drag-begin", callback: (actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void): NodeJS.EventEmitter
    emit(sigName: "drag-begin", actor: Actor, eventX: number, eventY: number, modifiers: ModifierType): void
    /**
     * The ::drag-end signal is emitted at the end of the dragging,
     * when the pointer button's is released
     * 
     * This signal is emitted if and only if the #ClutterDragAction::drag-begin
     * signal has been emitted first
     */
    connect(sigName: "drag-end", callback: ((actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void)): number
    on(sigName: "drag-end", callback: (actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "drag-end", callback: (actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "drag-end", callback: (actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void): NodeJS.EventEmitter
    emit(sigName: "drag-end", actor: Actor, eventX: number, eventY: number, modifiers: ModifierType): void
    /**
     * The ::drag-motion signal is emitted for each motion event after
     * the #ClutterDragAction::drag-begin signal has been emitted.
     * 
     * The components of the distance between the press event and the
     * latest motion event are computed in the actor's coordinate space,
     * to take into account eventual transformations. If you want the
     * stage coordinates of the latest motion event you can use
     * clutter_drag_action_get_motion_coords().
     * 
     * The default handler of the signal will call clutter_actor_move_by()
     * either on `actor` or, if set, of #ClutterDragAction:drag-handle using
     * the `delta_x` and `delta_y` components of the dragging motion. If you
     * want to override the default behaviour, you can connect to the
     * #ClutterDragAction::drag-progress signal and return %FALSE from the
     * handler.
     */
    connect(sigName: "drag-motion", callback: ((actor: Actor, deltaX: number, deltaY: number) => void)): number
    on(sigName: "drag-motion", callback: (actor: Actor, deltaX: number, deltaY: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "drag-motion", callback: (actor: Actor, deltaX: number, deltaY: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "drag-motion", callback: (actor: Actor, deltaX: number, deltaY: number) => void): NodeJS.EventEmitter
    emit(sigName: "drag-motion", actor: Actor, deltaX: number, deltaY: number): void
    /**
     * The ::drag-progress signal is emitted for each motion event after
     * the #ClutterDragAction::drag-begin signal has been emitted.
     * 
     * The components of the distance between the press event and the
     * latest motion event are computed in the actor's coordinate space,
     * to take into account eventual transformations. If you want the
     * stage coordinates of the latest motion event you can use
     * clutter_drag_action_get_motion_coords().
     * 
     * The default handler will emit #ClutterDragAction::drag-motion,
     * if #ClutterDragAction::drag-progress emission returns %TRUE.
     */
    connect(sigName: "drag-progress", callback: ((actor: Actor, deltaX: number, deltaY: number) => boolean)): number
    on(sigName: "drag-progress", callback: (actor: Actor, deltaX: number, deltaY: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "drag-progress", callback: (actor: Actor, deltaX: number, deltaY: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "drag-progress", callback: (actor: Actor, deltaX: number, deltaY: number) => void): NodeJS.EventEmitter
    emit(sigName: "drag-progress", actor: Actor, deltaX: number, deltaY: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::drag-area", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::drag-area", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::drag-area", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::drag-area", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::drag-area", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::drag-area-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::drag-area-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::drag-area-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::drag-area-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::drag-area-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::drag-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::drag-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::drag-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::drag-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::drag-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::drag-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::drag-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::drag-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::drag-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::drag-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-drag-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-drag-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-drag-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-drag-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DragAction_ConstructProps)
    _init (config?: DragAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): DragAction
    static $gtype: GObject.Type
}
interface DropAction_ConstructProps extends Action_ConstructProps {
}
class DropAction {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.DropAction */
    /**
     * The ::can-drop signal is emitted when the dragged actor is dropped
     * on `actor`. The return value of the ::can-drop signal will determine
     * whether or not the #ClutterDropAction::drop signal is going to be
     * emitted on `action`.
     * 
     * The default implementation of #ClutterDropAction returns %TRUE for
     * this signal.
     */
    connect(sigName: "can-drop", callback: ((actor: Actor, eventX: number, eventY: number) => boolean)): number
    on(sigName: "can-drop", callback: (actor: Actor, eventX: number, eventY: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "can-drop", callback: (actor: Actor, eventX: number, eventY: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "can-drop", callback: (actor: Actor, eventX: number, eventY: number) => void): NodeJS.EventEmitter
    emit(sigName: "can-drop", actor: Actor, eventX: number, eventY: number): void
    /**
     * The ::drop signal is emitted when the dragged actor is dropped
     * on `actor`. This signal is only emitted if at least an handler of
     * #ClutterDropAction::can-drop returns %TRUE.
     */
    connect(sigName: "drop", callback: ((actor: Actor, eventX: number, eventY: number) => void)): number
    on(sigName: "drop", callback: (actor: Actor, eventX: number, eventY: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "drop", callback: (actor: Actor, eventX: number, eventY: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "drop", callback: (actor: Actor, eventX: number, eventY: number) => void): NodeJS.EventEmitter
    emit(sigName: "drop", actor: Actor, eventX: number, eventY: number): void
    /**
     * The ::drop-cancel signal is emitted when the drop is refused
     * by an emission of the #ClutterDropAction::can-drop signal.
     * 
     * After the ::drop-cancel signal is fired the active drag is
     * terminated.
     */
    connect(sigName: "drop-cancel", callback: ((actor: Actor, eventX: number, eventY: number) => void)): number
    on(sigName: "drop-cancel", callback: (actor: Actor, eventX: number, eventY: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "drop-cancel", callback: (actor: Actor, eventX: number, eventY: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "drop-cancel", callback: (actor: Actor, eventX: number, eventY: number) => void): NodeJS.EventEmitter
    emit(sigName: "drop-cancel", actor: Actor, eventX: number, eventY: number): void
    /**
     * The ::over-in signal is emitted when the dragged actor crosses
     * into `actor`.
     */
    connect(sigName: "over-in", callback: ((actor: Actor) => void)): number
    on(sigName: "over-in", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "over-in", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "over-in", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "over-in", actor: Actor): void
    /**
     * The ::over-out signal is emitted when the dragged actor crosses
     * outside `actor`.
     */
    connect(sigName: "over-out", callback: ((actor: Actor) => void)): number
    on(sigName: "over-out", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "over-out", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "over-out", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "over-out", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DropAction_ConstructProps)
    _init (config?: DropAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): DropAction
    static $gtype: GObject.Type
}
interface Effect_ConstructProps extends ActorMeta_ConstructProps {
}
class Effect {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Effect_ConstructProps)
    _init (config?: Effect_ConstructProps): void
    static $gtype: GObject.Type
}
interface FixedLayout_ConstructProps extends LayoutManager_ConstructProps {
}
class FixedLayout {
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.LayoutManager */
    /**
     * Allocates the children of `container` given an area
     * 
     * See also clutter_actor_allocate()
     */
    allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void
    /**
     * Begins an animation of `duration` milliseconds, using the provided
     * easing `mode`
     * 
     * The easing mode can be specified either as a #ClutterAnimationMode
     * or as a logical id returned by clutter_alpha_register_func()
     * 
     * The result of this function depends on the `manager` implementation
     */
    beginAnimation(duration: number, mode: number): Alpha
    /**
     * Gets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     * 
     * The #GValue must already be initialized to the type of the property
     * and has to be unset with g_value_unset() after extracting the real
     * value out of it
     */
    childGetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Sets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     */
    childSetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Ends an animation started by clutter_layout_manager_begin_animation()
     * 
     * The result of this call depends on the `manager` implementation
     */
    endAnimation(): void
    /**
     * Retrieves the #GParamSpec for the layout property `name` inside
     * the #ClutterLayoutMeta sub-class used by `manager`
     */
    findChildProperty(name: string): GObject.ParamSpec
    /**
     * Retrieves the progress of the animation, if one has been started by
     * clutter_layout_manager_begin_animation()
     * 
     * The returned value has the same semantics of the #ClutterAlpha:alpha
     * value
     */
    getAnimationProgress(): number
    /**
     * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
     * to the `actor` child of `container,` eventually by creating one if the
     * #ClutterLayoutManager supports layout properties
     */
    getChildMeta(container: Container, actor: Actor): LayoutMeta
    /**
     * Computes the minimum and natural heights of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_height()
     */
    getPreferredHeight(container: Container, forWidth: number): [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    /**
     * Computes the minimum and natural widths of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_width()
     */
    getPreferredWidth(container: Container, forHeight: number): [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    /**
     * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
     * 
     * This function should only be called by implementations of the
     * #ClutterLayoutManager class
     */
    layoutChanged(): void
    /**
     * Retrieves all the #GParamSpec<!-- -->s for the layout properties
     * stored inside the #ClutterLayoutMeta sub-class used by `manager`
     */
    listChildProperties(): GObject.ParamSpec[]
    /**
     * If the #ClutterLayoutManager sub-class allows it, allow
     * adding a weak reference of the `container` using `manager`
     * from within the layout manager
     * 
     * The layout manager should not increase the reference
     * count of the `container`
     */
    setContainer(container?: Container | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.LayoutManager */
    /**
     * The ::layout-changed signal is emitted each time a layout manager
     * has been changed. Every #ClutterActor using the `manager` instance
     * as a layout manager should connect a handler to the ::layout-changed
     * signal and queue a relayout on themselves:
     * 
     * |[
     *   static void layout_changed (ClutterLayoutManager *manager,
     *                               ClutterActor         *self)
     *   {
     *     clutter_actor_queue_relayout (self);
     *   }
     *   ...
     *     self->manager = g_object_ref_sink (manager);
     *     g_signal_connect (self->manager, "layout-changed",
     *                       G_CALLBACK (layout_changed),
     *                       self);
     * ```
     * 
     * 
     * Sub-classes of #ClutterLayoutManager that implement a layout that
     * can be controlled or changed using parameters should emit the
     * ::layout-changed signal whenever one of the parameters changes,
     * by using clutter_layout_manager_layout_changed().
     */
    connect(sigName: "layout-changed", callback: (() => void)): number
    on(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "layout-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "layout-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: FixedLayout_ConstructProps)
    _init (config?: FixedLayout_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): FixedLayout
    static $gtype: GObject.Type
}
interface FlowLayout_ConstructProps extends LayoutManager_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.FlowLayout */
    /**
     * The spacing between columns, in pixels; the value of this
     * property is honoured by horizontal non-overflowing layouts
     * and by vertical overflowing layouts
     */
    columnSpacing?: number
    /**
     * Whether each child inside the #ClutterFlowLayout should receive
     * the same allocation
     */
    homogeneous?: boolean
    /**
     * Maximum width for each column in the layout, in pixels. If
     * set to -1 the width will be the maximum child width
     */
    maxColumnWidth?: number
    /**
     * Maximum height for each row in the layout, in pixels. If
     * set to -1 the width will be the maximum child height
     */
    maxRowHeight?: number
    /**
     * Minimum width for each column in the layout, in pixels
     */
    minColumnWidth?: number
    /**
     * Minimum height for each row in the layout, in pixels
     */
    minRowHeight?: number
    /**
     * The orientation of the #ClutterFlowLayout. The children
     * of the layout will be layed out following the orientation.
     * 
     * This property also controls the overflowing directions
     */
    orientation?: FlowOrientation
    /**
     * The spacing between rows, in pixels; the value of this
     * property is honoured by vertical non-overflowing layouts and
     * by horizontal overflowing layouts
     */
    rowSpacing?: number
    /**
     * Whether the #ClutterFlowLayout should arrange its children
     * on a grid
     */
    snapToGrid?: boolean
}
class FlowLayout {
    /* Properties of Clutter-1.0.Clutter.FlowLayout */
    /**
     * The spacing between columns, in pixels; the value of this
     * property is honoured by horizontal non-overflowing layouts
     * and by vertical overflowing layouts
     */
    columnSpacing: number
    /**
     * Whether each child inside the #ClutterFlowLayout should receive
     * the same allocation
     */
    homogeneous: boolean
    /**
     * Maximum width for each column in the layout, in pixels. If
     * set to -1 the width will be the maximum child width
     */
    maxColumnWidth: number
    /**
     * Maximum height for each row in the layout, in pixels. If
     * set to -1 the width will be the maximum child height
     */
    maxRowHeight: number
    /**
     * Minimum width for each column in the layout, in pixels
     */
    minColumnWidth: number
    /**
     * Minimum height for each row in the layout, in pixels
     */
    minRowHeight: number
    /**
     * The orientation of the #ClutterFlowLayout. The children
     * of the layout will be layed out following the orientation.
     * 
     * This property also controls the overflowing directions
     */
    orientation: FlowOrientation
    /**
     * The spacing between rows, in pixels; the value of this
     * property is honoured by vertical non-overflowing layouts and
     * by horizontal overflowing layouts
     */
    rowSpacing: number
    /**
     * Whether the #ClutterFlowLayout should arrange its children
     * on a grid
     */
    snapToGrid: boolean
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.FlowLayout */
    /**
     * Retrieves the spacing between columns
     */
    getColumnSpacing(): number
    /**
     * Retrieves the minimum and maximum column widths
     */
    getColumnWidth(): [ /* minWidth */ number, /* maxWidth */ number ]
    /**
     * Retrieves whether the `layout` is homogeneous
     */
    getHomogeneous(): boolean
    /**
     * Retrieves the orientation of the `layout`
     */
    getOrientation(): FlowOrientation
    /**
     * Retrieves the minimum and maximum row heights
     */
    getRowHeight(): [ /* minHeight */ number, /* maxHeight */ number ]
    /**
     * Retrieves the spacing between rows
     */
    getRowSpacing(): number
    /**
     * Retrieves the value of #ClutterFlowLayout:snap-to-grid property
     */
    getSnapToGrid(): boolean
    /**
     * Sets the space between columns, in pixels
     */
    setColumnSpacing(spacing: number): void
    /**
     * Sets the minimum and maximum widths that a column can have
     */
    setColumnWidth(minWidth: number, maxWidth: number): void
    /**
     * Sets whether the `layout` should allocate the same space for
     * each child
     */
    setHomogeneous(homogeneous: boolean): void
    /**
     * Sets the orientation of the flow layout
     * 
     * The orientation controls the direction used to allocate
     * the children: either horizontally or vertically. The
     * orientation also controls the direction of the overflowing
     */
    setOrientation(orientation: FlowOrientation): void
    /**
     * Sets the minimum and maximum heights that a row can have
     */
    setRowHeight(minHeight: number, maxHeight: number): void
    /**
     * Sets the spacing between rows, in pixels
     */
    setRowSpacing(spacing: number): void
    /**
     * Whether the `layout` should place its children on a grid.
     */
    setSnapToGrid(snapToGrid: boolean): void
    /* Methods of Clutter-1.0.Clutter.LayoutManager */
    /**
     * Allocates the children of `container` given an area
     * 
     * See also clutter_actor_allocate()
     */
    allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void
    /**
     * Begins an animation of `duration` milliseconds, using the provided
     * easing `mode`
     * 
     * The easing mode can be specified either as a #ClutterAnimationMode
     * or as a logical id returned by clutter_alpha_register_func()
     * 
     * The result of this function depends on the `manager` implementation
     */
    beginAnimation(duration: number, mode: number): Alpha
    /**
     * Gets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     * 
     * The #GValue must already be initialized to the type of the property
     * and has to be unset with g_value_unset() after extracting the real
     * value out of it
     */
    childGetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Sets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     */
    childSetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Ends an animation started by clutter_layout_manager_begin_animation()
     * 
     * The result of this call depends on the `manager` implementation
     */
    endAnimation(): void
    /**
     * Retrieves the #GParamSpec for the layout property `name` inside
     * the #ClutterLayoutMeta sub-class used by `manager`
     */
    findChildProperty(name: string): GObject.ParamSpec
    /**
     * Retrieves the progress of the animation, if one has been started by
     * clutter_layout_manager_begin_animation()
     * 
     * The returned value has the same semantics of the #ClutterAlpha:alpha
     * value
     */
    getAnimationProgress(): number
    /**
     * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
     * to the `actor` child of `container,` eventually by creating one if the
     * #ClutterLayoutManager supports layout properties
     */
    getChildMeta(container: Container, actor: Actor): LayoutMeta
    /**
     * Computes the minimum and natural heights of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_height()
     */
    getPreferredHeight(container: Container, forWidth: number): [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    /**
     * Computes the minimum and natural widths of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_width()
     */
    getPreferredWidth(container: Container, forHeight: number): [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    /**
     * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
     * 
     * This function should only be called by implementations of the
     * #ClutterLayoutManager class
     */
    layoutChanged(): void
    /**
     * Retrieves all the #GParamSpec<!-- -->s for the layout properties
     * stored inside the #ClutterLayoutMeta sub-class used by `manager`
     */
    listChildProperties(): GObject.ParamSpec[]
    /**
     * If the #ClutterLayoutManager sub-class allows it, allow
     * adding a weak reference of the `container` using `manager`
     * from within the layout manager
     * 
     * The layout manager should not increase the reference
     * count of the `container`
     */
    setContainer(container?: Container | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.LayoutManager */
    /**
     * The ::layout-changed signal is emitted each time a layout manager
     * has been changed. Every #ClutterActor using the `manager` instance
     * as a layout manager should connect a handler to the ::layout-changed
     * signal and queue a relayout on themselves:
     * 
     * |[
     *   static void layout_changed (ClutterLayoutManager *manager,
     *                               ClutterActor         *self)
     *   {
     *     clutter_actor_queue_relayout (self);
     *   }
     *   ...
     *     self->manager = g_object_ref_sink (manager);
     *     g_signal_connect (self->manager, "layout-changed",
     *                       G_CALLBACK (layout_changed),
     *                       self);
     * ```
     * 
     * 
     * Sub-classes of #ClutterLayoutManager that implement a layout that
     * can be controlled or changed using parameters should emit the
     * ::layout-changed signal whenever one of the parameters changes,
     * by using clutter_layout_manager_layout_changed().
     */
    connect(sigName: "layout-changed", callback: (() => void)): number
    on(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "layout-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "layout-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::column-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::column-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::max-column-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-column-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::max-column-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::max-column-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::max-column-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::max-row-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-row-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::max-row-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::max-row-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::max-row-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-column-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-column-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-column-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-column-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-column-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-row-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-row-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-row-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-row-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-row-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::orientation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::orientation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::row-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::row-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::snap-to-grid", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::snap-to-grid", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::snap-to-grid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::snap-to-grid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::snap-to-grid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: FlowLayout_ConstructProps)
    _init (config?: FlowLayout_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(orientation: FlowOrientation): FlowLayout
    static $gtype: GObject.Type
}
interface GestureAction_ConstructProps extends Action_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.GestureAction */
    /**
     * Number of touch points to trigger a gesture action.
     */
    nTouchPoints?: number
    /**
     * The horizontal trigger distance to be used by the action to either
     * emit the #ClutterGestureAction::gesture-begin signal or to emit
     * the #ClutterGestureAction::gesture-cancel signal.
     * 
     * A negative value will be interpreted as the default drag threshold.
     */
    thresholdTriggerDistanceX?: number
    /**
     * The vertical trigger distance to be used by the action to either
     * emit the #ClutterGestureAction::gesture-begin signal or to emit
     * the #ClutterGestureAction::gesture-cancel signal.
     * 
     * A negative value will be interpreted as the default drag threshold.
     */
    thresholdTriggerDistanceY?: number
    /**
     * The trigger edge to be used by the action to either emit the
     * #ClutterGestureAction::gesture-begin signal or to emit the
     * #ClutterGestureAction::gesture-cancel signal.
     */
    thresholdTriggerEdge?: GestureTriggerEdge
}
class GestureAction {
    /* Properties of Clutter-1.0.Clutter.GestureAction */
    /**
     * Number of touch points to trigger a gesture action.
     */
    nTouchPoints: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.GestureAction */
    /**
     * Cancel a #ClutterGestureAction before it begins
     */
    cancel(): void
    /**
     * Retrieves the #ClutterInputDevice of a touch point.
     */
    getDevice(point: number): InputDevice
    /**
     * Retrieves a reference to the last #ClutterEvent for a touch point. Call
     * clutter_event_copy() if you need to store the reference somewhere.
     */
    getLastEvent(point: number): Event
    /**
     * Retrieves the coordinates, in stage space, of the latest motion
     * event during the dragging.
     */
    getMotionCoords(point: number): [ /* motionX */ number | null, /* motionY */ number | null ]
    /**
     * Retrieves the incremental delta since the last motion event
     * during the dragging.
     */
    getMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the number of points currently active.
     */
    getNCurrentPoints(): number
    /**
     * Retrieves the number of requested points to trigger the gesture.
     */
    getNTouchPoints(): number
    /**
     * Retrieves the coordinates, in stage space, of the press event
     * that started the dragging for a specific touch point.
     */
    getPressCoords(point: number): [ /* pressX */ number | null, /* pressY */ number | null ]
    /**
     * Retrieves the coordinates, in stage space, where the touch point was
     * last released.
     */
    getReleaseCoords(point: number): [ /* releaseX */ number | null, /* releaseY */ number | null ]
    /**
     * Retrieves the #ClutterEventSequence of a touch point.
     */
    getSequence(point: number): EventSequence
    /**
     * Retrieves the threshold trigger distance of the gesture `action,`
     * as set using clutter_gesture_action_set_threshold_trigger_distance().
     */
    getThresholdTriggerDistance(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEdge(): GestureTriggerEdge
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEgde(): GestureTriggerEdge
    /**
     * Retrieves the velocity, in stage pixels per millisecond, of the
     * latest motion event during the dragging.
     */
    getVelocity(point: number): [ /* returnType */ number, /* velocityX */ number | null, /* velocityY */ number | null ]
    /**
     * Sets the number of points needed to trigger the gesture.
     */
    setNTouchPoints(nbPoints: number): void
    /**
     * Sets the threshold trigger distance for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerDistance(x: number, y: number): void
    /**
     * Sets the edge trigger for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerEdge(edge: GestureTriggerEdge): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.GestureAction */
    /**
     * The ::gesture_begin signal is emitted when the #ClutterActor to which
     * a #ClutterGestureAction has been applied starts receiving a gesture.
     */
    connect(sigName: "gesture-begin", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-begin", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-begin", actor: Actor): void
    /**
     * The ::gesture-cancel signal is emitted when the ongoing gesture gets
     * cancelled from the #ClutterGestureAction::gesture-progress signal handler.
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-cancel", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-cancel", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-cancel", actor: Actor): void
    /**
     * The ::gesture-end signal is emitted at the end of the gesture gesture,
     * when the pointer's button is released
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-end", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-end", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-end", actor: Actor): void
    /**
     * The ::gesture-progress signal is emitted for each motion event after
     * the #ClutterGestureAction::gesture-begin signal has been emitted.
     */
    connect(sigName: "gesture-progress", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-progress", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-progress", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: GestureAction_ConstructProps)
    _init (config?: GestureAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): GestureAction
    static $gtype: GObject.Type
}
interface GridLayout_ConstructProps extends LayoutManager_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.GridLayout */
    /**
     * Whether all columns of the layout should have the same width
     */
    columnHomogeneous?: boolean
    /**
     * The amount of space in pixels between two consecutive columns
     */
    columnSpacing?: number
    /**
     * The orientation of the layout, either horizontal or vertical
     */
    orientation?: Orientation
    /**
     * Whether all rows of the layout should have the same height
     */
    rowHomogeneous?: boolean
    /**
     * The amount of space in pixels between two consecutive rows
     */
    rowSpacing?: number
}
class GridLayout {
    /* Properties of Clutter-1.0.Clutter.GridLayout */
    /**
     * Whether all columns of the layout should have the same width
     */
    columnHomogeneous: boolean
    /**
     * The amount of space in pixels between two consecutive columns
     */
    columnSpacing: number
    /**
     * The orientation of the layout, either horizontal or vertical
     */
    orientation: Orientation
    /**
     * Whether all rows of the layout should have the same height
     */
    rowHomogeneous: boolean
    /**
     * The amount of space in pixels between two consecutive rows
     */
    rowSpacing: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.GridLayout */
    /**
     * Adds a widget to the grid.
     * 
     * The position of `child` is determined by `left` and `top`. The
     * number of 'cells' that `child` will occupy is determined by
     * `width` and `height`.
     */
    attach(child: Actor, left: number, top: number, width: number, height: number): void
    /**
     * Adds a actor to the grid.
     * 
     * The actor is placed next to `sibling,` on the side determined by
     * `side`. When `sibling` is %NULL, the actor is placed in row (for
     * left or right placement) or column 0 (for top or bottom placement),
     * at the end indicated by `side`.
     * 
     * Attaching widgets labeled [1], [2], [3] with `sibling` == %NULL and
     * `side` == %CLUTTER_GRID_POSITION_LEFT yields a layout of [3][2][1].
     */
    attachNextTo(child: Actor, sibling: Actor | null, side: GridPosition, width: number, height: number): void
    /**
     * Gets the child of `layout` whose area covers the grid
     * cell whose upper left corner is at `left,` `top`.
     */
    getChildAt(left: number, top: number): Actor
    /**
     * Returns whether all columns of `layout` have the same width.
     */
    getColumnHomogeneous(): boolean
    /**
     * Retrieves the spacing set using clutter_grid_layout_set_column_spacing()
     */
    getColumnSpacing(): number
    /**
     * Retrieves the orientation of the `layout`.
     */
    getOrientation(): Orientation
    /**
     * Returns whether all rows of `layout` have the same height.
     */
    getRowHomogeneous(): boolean
    /**
     * Retrieves the spacing set using clutter_grid_layout_set_row_spacing()
     */
    getRowSpacing(): number
    /**
     * Inserts a column at the specified position.
     * 
     * Children which are attached at or to the right of this position
     * are moved one column to the right. Children which span across this
     * position are grown to span the new column.
     */
    insertColumn(position: number): void
    /**
     * Inserts a row or column at the specified position.
     * 
     * The new row or column is placed next to `sibling,` on the side
     * determined by `side`. If `side` is %CLUTTER_GRID_POSITION_LEFT or
     * %CLUTTER_GRID_POSITION_BOTTOM, a row is inserted. If `side` is
     * %CLUTTER_GRID_POSITION_LEFT of %CLUTTER_GRID_POSITION_RIGHT,
     * a column is inserted.
     */
    insertNextTo(sibling: Actor, side: GridPosition): void
    /**
     * Inserts a row at the specified position.
     * 
     * Children which are attached at or below this position
     * are moved one row down. Children which span across this
     * position are grown to span the new row.
     */
    insertRow(position: number): void
    /**
     * Sets whether all columns of `layout` will have the same width.
     */
    setColumnHomogeneous(homogeneous: boolean): void
    /**
     * Sets the spacing between columns of `layout`
     */
    setColumnSpacing(spacing: number): void
    /**
     * Sets the orientation of the `layout`.
     * 
     * #ClutterGridLayout uses the orientation as a hint when adding
     * children to the #ClutterActor using it as a layout manager via
     * clutter_actor_add_child(); changing this value will not have
     * any effect on children that are already part of the layout.
     */
    setOrientation(orientation: Orientation): void
    /**
     * Sets whether all rows of `layout` will have the same height.
     */
    setRowHomogeneous(homogeneous: boolean): void
    /**
     * Sets the spacing between rows of `layout`
     */
    setRowSpacing(spacing: number): void
    /* Methods of Clutter-1.0.Clutter.LayoutManager */
    /**
     * Allocates the children of `container` given an area
     * 
     * See also clutter_actor_allocate()
     */
    allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void
    /**
     * Begins an animation of `duration` milliseconds, using the provided
     * easing `mode`
     * 
     * The easing mode can be specified either as a #ClutterAnimationMode
     * or as a logical id returned by clutter_alpha_register_func()
     * 
     * The result of this function depends on the `manager` implementation
     */
    beginAnimation(duration: number, mode: number): Alpha
    /**
     * Gets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     * 
     * The #GValue must already be initialized to the type of the property
     * and has to be unset with g_value_unset() after extracting the real
     * value out of it
     */
    childGetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Sets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     */
    childSetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Ends an animation started by clutter_layout_manager_begin_animation()
     * 
     * The result of this call depends on the `manager` implementation
     */
    endAnimation(): void
    /**
     * Retrieves the #GParamSpec for the layout property `name` inside
     * the #ClutterLayoutMeta sub-class used by `manager`
     */
    findChildProperty(name: string): GObject.ParamSpec
    /**
     * Retrieves the progress of the animation, if one has been started by
     * clutter_layout_manager_begin_animation()
     * 
     * The returned value has the same semantics of the #ClutterAlpha:alpha
     * value
     */
    getAnimationProgress(): number
    /**
     * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
     * to the `actor` child of `container,` eventually by creating one if the
     * #ClutterLayoutManager supports layout properties
     */
    getChildMeta(container: Container, actor: Actor): LayoutMeta
    /**
     * Computes the minimum and natural heights of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_height()
     */
    getPreferredHeight(container: Container, forWidth: number): [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    /**
     * Computes the minimum and natural widths of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_width()
     */
    getPreferredWidth(container: Container, forHeight: number): [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    /**
     * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
     * 
     * This function should only be called by implementations of the
     * #ClutterLayoutManager class
     */
    layoutChanged(): void
    /**
     * Retrieves all the #GParamSpec<!-- -->s for the layout properties
     * stored inside the #ClutterLayoutMeta sub-class used by `manager`
     */
    listChildProperties(): GObject.ParamSpec[]
    /**
     * If the #ClutterLayoutManager sub-class allows it, allow
     * adding a weak reference of the `container` using `manager`
     * from within the layout manager
     * 
     * The layout manager should not increase the reference
     * count of the `container`
     */
    setContainer(container?: Container | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.LayoutManager */
    /**
     * The ::layout-changed signal is emitted each time a layout manager
     * has been changed. Every #ClutterActor using the `manager` instance
     * as a layout manager should connect a handler to the ::layout-changed
     * signal and queue a relayout on themselves:
     * 
     * |[
     *   static void layout_changed (ClutterLayoutManager *manager,
     *                               ClutterActor         *self)
     *   {
     *     clutter_actor_queue_relayout (self);
     *   }
     *   ...
     *     self->manager = g_object_ref_sink (manager);
     *     g_signal_connect (self->manager, "layout-changed",
     *                       G_CALLBACK (layout_changed),
     *                       self);
     * ```
     * 
     * 
     * Sub-classes of #ClutterLayoutManager that implement a layout that
     * can be controlled or changed using parameters should emit the
     * ::layout-changed signal whenever one of the parameters changes,
     * by using clutter_layout_manager_layout_changed().
     */
    connect(sigName: "layout-changed", callback: (() => void)): number
    on(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "layout-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "layout-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::column-homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::column-homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::column-homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::column-homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::column-homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::column-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::column-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::orientation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::orientation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::orientation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::row-homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::row-homogeneous", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::row-homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::row-homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::row-homogeneous", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::row-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::row-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: GridLayout_ConstructProps)
    _init (config?: GridLayout_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): GridLayout
    static $gtype: GObject.Type
}
interface Group_ConstructProps extends Actor_ConstructProps {
}
class Group {
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Group */
    /**
     * Gets the number of actors held in the group.
     */
    getNChildren(): number
    /**
     * Gets a groups child held at `index_` in stack.
     */
    getNthChild(index: number): Actor
    /**
     * Removes all children actors from the #ClutterGroup.
     */
    removeAll(): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Group_ConstructProps)
    _init (config?: Group_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Group
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
interface Image_ConstructProps extends GObject.Object_ConstructProps {
}
class Image {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Image */
    /**
     * Sets the image data to be display by `image,` using `rect` to indicate
     * the position and size of the image data to be set.
     * 
     * If the `image` does not have any image data set when this function is
     * called, a new texture will be created with the size of the width and
     * height of the rectangle, i.e. calling this function on a newly created
     * #ClutterImage will be the equivalent of calling clutter_image_set_data().
     * 
     * If the image data was successfully loaded, the `image` will be invalidated.
     * 
     * In case of error, the `error` value will be set, and this function will
     * return %FALSE.
     * 
     * The image data is copied in texture memory.
     */
    setArea(data: Uint8Array, pixelFormat: Cogl.PixelFormat, rect: cairo.RectangleInt, rowStride: number): boolean
    /**
     * Sets the image data stored inside a #GBytes to be displayed by `image`.
     * 
     * If the image data was successfully loaded, the `image` will be invalidated.
     * 
     * In case of error, the `error` value will be set, and this function will
     * return %FALSE.
     * 
     * The image data contained inside the #GBytes is copied in texture memory,
     * and no additional reference is acquired on the `data`.
     */
    setBytes(data: any, pixelFormat: Cogl.PixelFormat, width: number, height: number, rowStride: number): boolean
    /**
     * Sets the image data to be displayed by `image`.
     * 
     * If the image data was successfully loaded, the `image` will be invalidated.
     * 
     * In case of error, the `error` value will be set, and this function will
     * return %FALSE.
     * 
     * The image data is copied in texture memory.
     * 
     * The image data is expected to be a linear array of RGBA or RGB pixel data;
     * how to retrieve that data is left to platform specific image loaders. For
     * instance, if you use the GdkPixbuf library:
     * 
     * 
     * ```c
     *   ClutterContent *image = clutter_image_new ();
     * 
     *   GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file (filename, NULL);
     * 
     *   clutter_image_set_data (CLUTTER_IMAGE (image),
     *                           gdk_pixbuf_get_pixels (pixbuf),
     *                           gdk_pixbuf_get_has_alpha (pixbuf)
     *                             ? COGL_PIXEL_FORMAT_RGBA_8888
     *                             : COGL_PIXEL_FORMAT_RGB_888,
     *                           gdk_pixbuf_get_width (pixbuf),
     *                           gdk_pixbuf_get_height (pixbuf),
     *                           gdk_pixbuf_get_rowstride (pixbuf),
     *                           &error);
     * 
     *   g_object_unref (pixbuf);
     * ```
     * 
     */
    setData(data: Uint8Array, pixelFormat: Cogl.PixelFormat, width: number, height: number, rowStride: number): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Content */
    /**
     * Retrieves the natural size of the `content,` if any.
     * 
     * The natural size of a #ClutterContent is defined as the size the content
     * would have regardless of the allocation of the actor that is painting it,
     * for instance the size of an image data.
     */
    getPreferredSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Invalidates a #ClutterContent.
     * 
     * This function should be called by #ClutterContent implementations when
     * they change the way a the content should be painted regardless of the
     * actor state.
     */
    invalidate(): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Content */
    /**
     * This signal is emitted each time a #ClutterContent implementation is
     * assigned to a #ClutterActor.
     */
    connect(sigName: "attached", callback: ((actor: Actor) => void)): number
    on(sigName: "attached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "attached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "attached", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "attached", actor: Actor): void
    /**
     * This signal is emitted each time a #ClutterContent implementation is
     * removed from a #ClutterActor.
     */
    connect(sigName: "detached", callback: ((actor: Actor) => void)): number
    on(sigName: "detached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "detached", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "detached", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "detached", actor: Actor): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Image_ConstructProps)
    _init (config?: Image_ConstructProps): void
    static $gtype: GObject.Type
}
interface InputDevice_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.InputDevice */
    /**
     * The #ClutterBackend that created the device.
     */
    backend?: Backend
    /**
     * The #ClutterDeviceManager instance which owns the device
     */
    deviceManager?: DeviceManager
    deviceMode?: InputMode
    /**
     * The type of the device
     */
    deviceType?: InputDeviceType
    /**
     * Whether the device is enabled.
     * 
     * A device with the #ClutterInputDevice:device-mode property set
     * to %CLUTTER_INPUT_MODE_MASTER cannot be disabled.
     * 
     * A device must be enabled in order to receive events from it.
     */
    enabled?: boolean
    /**
     * Whether the device has an on screen cursor following its movement.
     */
    hasCursor?: boolean
    /**
     * The unique identifier of the device
     */
    id?: number
    /**
     * The name of the device
     */
    name?: string
    /**
     * Product ID of this device.
     */
    productId?: string
    /**
     * Vendor ID of this device.
     */
    vendorId?: string
}
class InputDevice {
    /* Properties of Clutter-1.0.Clutter.InputDevice */
    /**
     * Whether the device is enabled.
     * 
     * A device with the #ClutterInputDevice:device-mode property set
     * to %CLUTTER_INPUT_MODE_MASTER cannot be disabled.
     * 
     * A device must be enabled in order to receive events from it.
     */
    enabled: boolean
    /**
     * The number of axes of the device.
     */
    readonly nAxes: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.InputDevice */
    /**
     * Retrieves a pointer to the #ClutterInputDevice that has been
     * associated to `device`.
     * 
     * If the #ClutterInputDevice:device-mode property of `device` is
     * set to %CLUTTER_INPUT_MODE_MASTER, this function will return
     * %NULL.
     */
    getAssociatedDevice(): InputDevice
    /**
     * Retrieves the type of axis on `device` at the given index.
     */
    getAxis(index: number): InputAxis
    /**
     * Extracts the value of the given `axis` of a #ClutterInputDevice from
     * an array of axis values.
     * 
     * An example of typical usage for this function is:
     * 
     * |[
     *   ClutterInputDevice *device = clutter_event_get_device (event);
     *   gdouble *axes = clutter_event_get_axes (event, NULL);
     *   gdouble pressure_value = 0;
     * 
     *   clutter_input_device_get_axis_value (device, axes,
     *                                        CLUTTER_INPUT_AXIS_PRESSURE,
     *                                        &pressure_value);
     * ```
     * 
     */
    getAxisValue(axes: number[], axis: InputAxis): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Retrieves the latest coordinates of a pointer or touch point of
     * `device`.
     */
    getCoords(sequence?: EventSequence | null): [ /* returnType */ boolean, /* point */ Point ]
    /**
     * Retrieves the latest coordinates of the pointer of `device`
     */
    getDeviceCoords(): [ /* x */ number, /* y */ number ]
    /**
     * Retrieves the unique identifier of `device`
     */
    getDeviceId(): number
    /**
     * Retrieves the #ClutterInputMode of `device`.
     */
    getDeviceMode(): InputMode
    /**
     * Retrieves the name of the `device`
     */
    getDeviceName(): string
    /**
     * Retrieves the type of `device`
     */
    getDeviceType(): InputDeviceType
    /**
     * Retrieves whether `device` is enabled.
     */
    getEnabled(): boolean
    /**
     * Retrieves a pointer to the #ClutterActor currently grabbing all
     * the events coming from `device`.
     */
    getGrabbedActor(): Actor
    /**
     * Retrieves whether `device` has a pointer that follows the
     * device motion.
     */
    getHasCursor(): boolean
    /**
     * Retrieves the key set using clutter_input_device_set_key()
     */
    getKey(index: number): [ /* returnType */ boolean, /* keyval */ number, /* modifiers */ ModifierType ]
    /**
     * Retrieves the current modifiers state of the device, as seen
     * by the last event Clutter processed.
     */
    getModifierState(): ModifierType
    /**
     * Retrieves the number of axes available on `device`.
     */
    getNAxes(): number
    /**
     * Retrieves the number of keys registered for `device`.
     */
    getNKeys(): number
    /**
     * Retrieves the #ClutterActor underneath the pointer of `device`
     */
    getPointerActor(): Actor
    /**
     * Retrieves the #ClutterStage underneath the pointer of `device`
     */
    getPointerStage(): Stage
    /**
     * Gets the product ID of this device.
     */
    getProductId(): string
    /**
     * Retrieves the slave devices attached to `device`.
     */
    getSlaveDevices(): InputDevice[]
    /**
     * Gets the vendor ID of this device.
     */
    getVendorId(): string
    /**
     * Acquires a grab on `actor` for the given `device`.
     * 
     * Any event coming from `device` will be delivered to `actor,` bypassing
     * the usual event delivery mechanism, until the grab is released by
     * calling clutter_input_device_ungrab().
     * 
     * The grab is client-side: even if the windowing system used by the Clutter
     * backend has the concept of "device grabs", Clutter will not use them.
     * 
     * Only #ClutterInputDevice of types %CLUTTER_POINTER_DEVICE and
     * %CLUTTER_KEYBOARD_DEVICE can hold a grab.
     */
    grab(actor: Actor): void
    /**
     * Translates a hardware keycode from a #ClutterKeyEvent to the
     * equivalent evdev keycode. Note that depending on the input backend
     * used by Clutter this function can fail if there is no obvious
     * mapping between the key codes. The hardware keycode can be taken
     * from the #ClutterKeyEvent.hardware_keycode member of #ClutterKeyEvent.
     */
    keycodeToEvdev(hardwareKeycode: number, evdevKeycode: number): boolean
    /**
     * Retrieves a pointer to the #ClutterActor currently grabbing the
     * touch events coming from `device` given the `sequence`.
     */
    sequenceGetGrabbedActor(sequence: EventSequence): Actor
    /**
     * Acquires a grab on `actor` for the given `device` and the given touch
     * `sequence`.
     * 
     * Any touch event coming from `device` and from `sequence` will be
     * delivered to `actor,` bypassing the usual event delivery mechanism,
     * until the grab is released by calling
     * clutter_input_device_sequence_ungrab().
     * 
     * The grab is client-side: even if the windowing system used by the Clutter
     * backend has the concept of "device grabs", Clutter will not use them.
     */
    sequenceGrab(sequence: EventSequence, actor: Actor): void
    /**
     * Releases the grab on the `device` for the given `sequence,` if one is
     * in place.
     */
    sequenceUngrab(sequence: EventSequence): void
    /**
     * Enables or disables a #ClutterInputDevice.
     * 
     * Only devices with a #ClutterInputDevice:device-mode property set
     * to %CLUTTER_INPUT_MODE_SLAVE or %CLUTTER_INPUT_MODE_FLOATING can
     * be disabled.
     */
    setEnabled(enabled: boolean): void
    /**
     * Sets the keyval and modifiers at the given `index_` for `device`.
     * 
     * Clutter will use the keyval and modifiers set when filling out
     * an event coming from the same input device.
     */
    setKey(index: number, keyval: number, modifiers: ModifierType): void
    /**
     * Releases the grab on the `device,` if one is in place.
     */
    ungrab(): void
    /**
     * Forcibly updates the state of the `device` using a #ClutterEvent
     * 
     * This function should never be used by applications: it is meant
     * for integration with embedding toolkits, like clutter-gtk
     * 
     * Embedding toolkits that disable the event collection inside Clutter
     * need to use this function to update the state of input devices depending
     * on a #ClutterEvent that they are going to submit to the event handling code
     * in Clutter though clutter_do_event(). Since the input devices hold the state
     * that is going to be used to fill in fields like the #ClutterButtonEvent
     * click count, or to emit synthesized events like %CLUTTER_ENTER and
     * %CLUTTER_LEAVE, it is necessary for embedding toolkits to also be
     * responsible of updating the input device state.
     * 
     * For instance, this might be the code to translate an embedding toolkit
     * native motion notification into a Clutter #ClutterMotionEvent and ask
     * Clutter to process it:
     * 
     * |[
     *   ClutterEvent c_event;
     * 
     *   translate_native_event_to_clutter (native_event, &c_event);
     * 
     *   clutter_do_event (&c_event);
     * ```
     * 
     * 
     * Before letting clutter_do_event() process the event, it is necessary to call
     * clutter_input_device_update_from_event():
     * 
     * |[
     *   ClutterEvent c_event;
     *   ClutterDeviceManager *manager;
     *   ClutterInputDevice *device;
     * 
     *   translate_native_event_to_clutter (native_event, &c_event);
     * 
     *   // get the device manager
     *   manager = clutter_device_manager_get_default ();
     * 
     *   // use the default Core Pointer that Clutter backends register by default
     *   device = clutter_device_manager_get_core_device (manager, %CLUTTER_POINTER_DEVICE);
     * 
     *   // update the state of the input device
     *   clutter_input_device_update_from_event (device, &c_event, FALSE);
     * 
     *   clutter_do_event (&c_event);
     * ```
     * 
     * 
     * The `update_stage` boolean argument should be used when the input device
     * enters and leaves a #ClutterStage; it will use the #ClutterStage field
     * of the passed `event` to update the stage associated to the input device.
     */
    updateFromEvent(event: Event, updateStage: boolean): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::n-axes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-axes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-axes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-axes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-axes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: InputDevice_ConstructProps)
    _init (config?: InputDevice_ConstructProps): void
    static $gtype: GObject.Type
}
interface Interval_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Interval */
    /**
     * The final value of the interval.
     */
    final?: any
    /**
     * The initial value of the interval.
     */
    initial?: any
    /**
     * The type of the values in the interval.
     */
    valueType?: GObject.Type
}
class Interval {
    /* Properties of Clutter-1.0.Clutter.Interval */
    /**
     * The final value of the interval.
     */
    final: any
    /**
     * The initial value of the interval.
     */
    initial: any
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Interval */
    /**
     * Creates a copy of `interval`.
     */
    clone(): Interval
    /**
     * Computes the value between the `interval` boundaries given the
     * progress `factor`
     * 
     * Unlike clutter_interval_compute_value(), this function will
     * return a const pointer to the computed value
     * 
     * You should use this function if you immediately pass the computed
     * value to another function that makes a copy of it, like
     * g_object_set_property()
     */
    compute(factor: number): any
    /**
     * Computes the value between the `interval` boundaries given the
     * progress `factor` and copies it into `value`.
     */
    computeValue(factor: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Retrieves the final value of `interval` and copies
     * it into `value`.
     * 
     * The passed #GValue must be initialized to the value held by
     * the #ClutterInterval.
     */
    getFinalValue(): /* value */ any
    /**
     * Retrieves the initial value of `interval` and copies
     * it into `value`.
     * 
     * The passed #GValue must be initialized to the value held by
     * the #ClutterInterval.
     */
    getInitialValue(): /* value */ any
    /**
     * Retrieves the #GType of the values inside `interval`.
     */
    getValueType(): GObject.Type
    /**
     * Checks if the `interval` has a valid initial and final values.
     */
    isValid(): boolean
    /**
     * Gets the pointer to the final value of `interval`
     */
    peekFinalValue(): any
    /**
     * Gets the pointer to the initial value of `interval`
     */
    peekInitialValue(): any
    /**
     * Sets the final value of `interval` to `value`. The value is
     * copied inside the #ClutterInterval.
     */
    setFinal(value: any): void
    /**
     * Sets the initial value of `interval` to `value`. The value is copied
     * inside the #ClutterInterval.
     */
    setInitial(value: any): void
    /**
     * Validates the initial and final values of `interval` against
     * a #GParamSpec.
     */
    validate(pspec: GObject.ParamSpec): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::final", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::final", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::final", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::final", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::final", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Interval_ConstructProps)
    _init (config?: Interval_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newWithValues(gtype: GObject.Type, initial?: any | null, final?: any | null): Interval
    static $gtype: GObject.Type
}
interface KeyframeTransition_ConstructProps extends PropertyTransition_ConstructProps {
}
class KeyframeTransition {
    /* Properties of Clutter-1.0.Clutter.PropertyTransition */
    /**
     * The name of the property of a #ClutterAnimatable to animate.
     */
    propertyName: string
    /* Properties of Clutter-1.0.Clutter.Transition */
    /**
     * The #ClutterAnimatable instance currently being animated.
     */
    animatable: Animatable
    /**
     * The #ClutterInterval used to describe the initial and final states
     * of the transition.
     */
    interval: Interval
    /**
     * Whether the #ClutterTransition should be automatically detached
     * from the #ClutterTransition:animatable instance whenever the
     * #ClutterTimeline::stopped signal is emitted.
     * 
     * The #ClutterTransition:remove-on-complete property takes into
     * account the value of the #ClutterTimeline:repeat-count property,
     * and it only detaches the transition if the transition is not
     * repeating.
     */
    removeOnComplete: boolean
    /* Properties of Clutter-1.0.Clutter.Timeline */
    /**
     * If the direction of the timeline should be automatically reversed
     * when reaching the end.
     */
    autoReverse: boolean
    /**
     * A delay, in milliseconds, that should be observed by the
     * timeline before actually starting.
     */
    delay: number
    /**
     * The direction of the timeline, either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    direction: TimelineDirection
    /**
     * Duration of the timeline in milliseconds, depending on the
     * ClutterTimeline:fps value.
     */
    duration: number
    /**
     * Whether the timeline should automatically rewind and restart.
     * 
     * As a side effect, setting this property to %TRUE will set the
     * #ClutterTimeline:repeat-count property to -1, while setting this
     * property to %FALSE will set the #ClutterTimeline:repeat-count
     * property to 0.
     */
    loop: boolean
    /**
     * Controls the way a #ClutterTimeline computes the normalized progress.
     */
    progressMode: AnimationMode
    /**
     * Defines how many times the timeline should repeat.
     * 
     * If the repeat count is 0, the timeline does not repeat.
     * 
     * If the repeat count is set to -1, the timeline will repeat until it is
     * stopped.
     */
    repeatCount: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.KeyframeTransition */
    /**
     * Removes all key frames from `transition`.
     */
    clear(): void
    /**
     * Retrieves the details of the key frame at `index_` inside `transition`.
     * 
     * The `transition` must already have key frames set, and `index_` must be
     * smaller than the number of key frames.
     */
    getKeyFrame(index: number): [ /* key */ number | null, /* mode */ AnimationMode | null, /* value */ any ]
    /**
     * Retrieves the number of key frames inside `transition`.
     */
    getNKeyFrames(): number
    /**
     * Sets the details of the key frame at `index_` inside `transition`.
     * 
     * The `transition` must already have a key frame at `index_,` and `index_`
     * must be smaller than the number of key frames inside `transition`.
     */
    setKeyFrame(index: number, key: number, mode: AnimationMode, value: any): void
    /**
     * Sets the keys for each key frame inside `transition`.
     * 
     * If `transition` does not hold any key frame, `n_key_frames` key frames
     * will be created; if `transition` already has key frames, `key_frames` must
     * have at least as many elements as the number of key frames.
     */
    setKeyFrames(keyFrames: number[]): void
    /**
     * Sets the easing modes for each key frame inside `transition`.
     * 
     * If `transition` does not hold any key frame, `n_modes` key frames will
     * be created; if `transition` already has key frames, `modes` must have
     * at least as many elements as the number of key frames.
     */
    setModes(modes: AnimationMode[]): void
    /**
     * Sets the values for each key frame inside `transition`.
     * 
     * If `transition` does not hold any key frame, `n_values` key frames will
     * be created; if `transition` already has key frames, `values` must have
     * at least as many elements as the number of key frames.
     */
    setValues(values: any[]): void
    /* Methods of Clutter-1.0.Clutter.PropertyTransition */
    /**
     * Retrieves the value of the #ClutterPropertyTransition:property-name
     * property.
     */
    getPropertyName(): string
    /**
     * Sets the #ClutterPropertyTransition:property-name property of `transition`.
     */
    setPropertyName(propertyName?: string | null): void
    /* Methods of Clutter-1.0.Clutter.Transition */
    /**
     * Retrieves the #ClutterAnimatable set using clutter_transition_set_animatable().
     */
    getAnimatable(): Animatable
    /**
     * Retrieves the interval set using clutter_transition_set_interval()
     */
    getInterval(): Interval
    /**
     * Retrieves the value of the #ClutterTransition:remove-on-complete property.
     */
    getRemoveOnComplete(): boolean
    /**
     * Sets the #ClutterTransition:animatable property.
     * 
     * The `transition` will acquire a reference to the `animatable` instance,
     * and will call the #ClutterTransitionClass.attached() virtual function.
     * 
     * If an existing #ClutterAnimatable is attached to `transition,` the
     * reference will be released, and the #ClutterTransitionClass.detached()
     * virtual function will be called.
     */
    setAnimatable(animatable?: Animatable | null): void
    /**
     * Sets the initial value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setFrom(value: any): void
    /**
     * Sets the #ClutterTransition:interval property using `interval`.
     * 
     * The `transition` will acquire a reference on the `interval,` sinking
     * the floating flag on it if necessary.
     */
    setInterval(interval?: Interval | null): void
    /**
     * Sets whether `transition` should be detached from the #ClutterAnimatable
     * set using clutter_transition_set_animatable() when the
     * #ClutterTimeline::completed signal is emitted.
     */
    setRemoveOnComplete(removeComplete: boolean): void
    /**
     * Sets the final value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setTo(value: any): void
    /* Methods of Clutter-1.0.Clutter.Timeline */
    /**
     * Adds a named marker that will be hit when the timeline has reached
     * the specified `progress`.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `progress` of its duration,
     * if will emit a ::marker-reached signal for each marker attached to
     * that particular point.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker_at_time()
     */
    addMarker(markerName: string, progress: number): void
    /**
     * Adds a named marker that will be hit when the timeline has been
     * running for `msecs` milliseconds.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `msecs,` it will emit
     * a ::marker-reached signal for each marker attached to that position.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker()
     */
    addMarkerAtTime(markerName: string, msecs: number): void
    /**
     * Advance timeline to the requested point. The point is given as a
     * time in milliseconds since the timeline started.
     * 
     * The `timeline` will not emit the #ClutterTimeline::new-frame
     * signal for the given time. The first ::new-frame signal after the call to
     * clutter_timeline_advance() will be emit the skipped markers.
     */
    advance(msecs: number): void
    /**
     * Advances `timeline` to the time of the given `marker_name`.
     * 
     * Like clutter_timeline_advance(), this function will not
     * emit the #ClutterTimeline::new-frame for the time where `marker_name`
     * is set, nor it will emit #ClutterTimeline::marker-reached for
     * `marker_name`.
     */
    advanceToMarker(markerName: string): void
    /**
     * Create a new #ClutterTimeline instance which has property values
     * matching that of supplied timeline. The cloned timeline will not
     * be started and will not be positioned to the current position of
     * the original `timeline:` you will have to start it with
     * clutter_timeline_start().
     * 
     * The only cloned properties are:
     * 
     *  - #ClutterTimeline:duration
     *  - #ClutterTimeline:loop
     *  - #ClutterTimeline:delay
     *  - #ClutterTimeline:direction
     */
    clone(): Timeline
    /**
     * Retrieves the value set by clutter_timeline_set_auto_reverse().
     */
    getAutoReverse(): boolean
    /**
     * Retrieves the control points for the cubic bezier progress mode.
     */
    getCubicBezierProgress(): [ /* returnType */ boolean, /* c1 */ Point, /* c2 */ Point ]
    /**
     * Retrieves the current repeat for a timeline.
     * 
     * Repeats start at 0.
     */
    getCurrentRepeat(): number
    /**
     * Retrieves the delay set using clutter_timeline_set_delay().
     */
    getDelay(): number
    /**
     * Retrieves the amount of time elapsed since the last
     * ClutterTimeline::new-frame signal.
     * 
     * This function is only useful inside handlers for the ::new-frame
     * signal, and its behaviour is undefined if the timeline is not
     * playing.
     */
    getDelta(): number
    /**
     * Retrieves the direction of the timeline set with
     * clutter_timeline_set_direction().
     */
    getDirection(): TimelineDirection
    /**
     * Retrieves the duration of a #ClutterTimeline in milliseconds.
     * See clutter_timeline_set_duration().
     */
    getDuration(): number
    /**
     * Retrieves the full duration of the `timeline,` taking into account the
     * current value of the #ClutterTimeline:repeat-count property.
     * 
     * If the #ClutterTimeline:repeat-count property is set to -1, this function
     * will return %G_MAXINT64.
     * 
     * The returned value is to be considered a hint, and it's only valid
     * as long as the `timeline` hasn't been changed.
     */
    getDurationHint(): number
    /**
     * Request the current time position of the timeline.
     */
    getElapsedTime(): number
    /**
     * Gets whether `timeline` is looping
     */
    getLoop(): boolean
    /**
     * The position of the timeline in a normalized [-1, 2] interval.
     * 
     * The return value of this function is determined by the progress
     * mode set using clutter_timeline_set_progress_mode(), or by the
     * progress function set using clutter_timeline_set_progress_func().
     */
    getProgress(): number
    /**
     * Retrieves the progress mode set using clutter_timeline_set_progress_mode()
     * or clutter_timeline_set_progress_func().
     */
    getProgressMode(): AnimationMode
    /**
     * Retrieves the number set using clutter_timeline_set_repeat_count().
     */
    getRepeatCount(): number
    /**
     * Retrieves the parameters of the step progress mode used by `timeline`.
     */
    getStepProgress(): [ /* returnType */ boolean, /* nSteps */ number, /* stepMode */ StepMode ]
    /**
     * Checks whether `timeline` has a marker set with the given name.
     */
    hasMarker(markerName: string): boolean
    /**
     * Queries state of a #ClutterTimeline.
     */
    isPlaying(): boolean
    /**
     * Retrieves the list of markers at time `msecs`. If `msecs` is a
     * negative integer, all the markers attached to `timeline` will be
     * returned.
     */
    listMarkers(msecs: number): string[]
    /**
     * Pauses the #ClutterTimeline on current frame
     */
    pause(): void
    /**
     * Removes `marker_name,` if found, from `timeline`.
     */
    removeMarker(markerName: string): void
    /**
     * Rewinds #ClutterTimeline to the first frame if its direction is
     * %CLUTTER_TIMELINE_FORWARD and the last frame if it is
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    rewind(): void
    /**
     * Sets whether `timeline` should reverse the direction after the
     * emission of the #ClutterTimeline::completed signal.
     * 
     * Setting the #ClutterTimeline:auto-reverse property to %TRUE is the
     * equivalent of connecting a callback to the #ClutterTimeline::completed
     * signal and changing the direction of the timeline from that callback;
     * for instance, this code:
     * 
     * |[
     * static void
     * reverse_timeline (ClutterTimeline *timeline)
     * {
     *   ClutterTimelineDirection dir = clutter_timeline_get_direction (timeline);
     * 
     *   if (dir == CLUTTER_TIMELINE_FORWARD)
     *     dir = CLUTTER_TIMELINE_BACKWARD;
     *   else
     *     dir = CLUTTER_TIMELINE_FORWARD;
     * 
     *   clutter_timeline_set_direction (timeline, dir);
     * }
     * ...
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   g_signal_connect (timeline, "completed",
     *                     G_CALLBACK (reverse_timeline),
     *                     NULL);
     * ```
     * 
     * 
     * can be effectively replaced by:
     * 
     * |[
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   clutter_timeline_set_auto_reverse (timeline);
     * ```
     * 
     */
    setAutoReverse(reverse: boolean): void
    /**
     * Sets the #ClutterTimeline:progress-mode of `timeline`
     * to %CLUTTER_CUBIC_BEZIER, and sets the two control
     * points for the cubic bezier.
     * 
     * The cubic bezier curve is between (0, 0) and (1, 1). The X coordinate
     * of the two control points must be in the [ 0, 1 ] range, while the
     * Y coordinate of the two control points can exceed this range.
     */
    setCubicBezierProgress(c1: Point, c2: Point): void
    /**
     * Sets the delay, in milliseconds, before `timeline` should start.
     */
    setDelay(msecs: number): void
    /**
     * Sets the direction of `timeline,` either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    setDirection(direction: TimelineDirection): void
    /**
     * Sets the duration of the timeline, in milliseconds. The speed
     * of the timeline depends on the ClutterTimeline:fps setting.
     */
    setDuration(msecs: number): void
    /**
     * Sets whether `timeline` should loop.
     * 
     * This function is equivalent to calling clutter_timeline_set_repeat_count()
     * with -1 if `loop` is %TRUE, and with 0 if `loop` is %FALSE.
     */
    setLoop(loop: boolean): void
    /**
     * Sets a custom progress function for `timeline`. The progress function will
     * be called by clutter_timeline_get_progress() and will be used to compute
     * the progress value based on the elapsed time and the total duration of the
     * timeline.
     * 
     * If `func` is not %NULL, the #ClutterTimeline:progress-mode property will
     * be set to %CLUTTER_CUSTOM_MODE.
     * 
     * If `func` is %NULL, any previously set progress function will be unset, and
     * the #ClutterTimeline:progress-mode property will be set to %CLUTTER_LINEAR.
     */
    setProgressFunc(func: TimelineProgressFunc | null): void
    /**
     * Sets the progress function using a value from the #ClutterAnimationMode
     * enumeration. The `mode` cannot be %CLUTTER_CUSTOM_MODE or bigger than
     * %CLUTTER_ANIMATION_LAST.
     */
    setProgressMode(mode: AnimationMode): void
    /**
     * Sets the number of times the `timeline` should repeat.
     * 
     * If `count` is 0, the timeline never repeats.
     * 
     * If `count` is -1, the timeline will always repeat until
     * it's stopped.
     */
    setRepeatCount(count: number): void
    /**
     * Sets the #ClutterTimeline:progress-mode of the `timeline` to %CLUTTER_STEPS
     * and provides the parameters of the step function.
     */
    setStepProgress(nSteps: number, stepMode: StepMode): void
    /**
     * Advance timeline by the requested time in milliseconds
     */
    skip(msecs: number): void
    /**
     * Starts the #ClutterTimeline playing.
     */
    start(): void
    /**
     * Stops the #ClutterTimeline and moves to frame 0
     */
    stop(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Timeline */
    /**
     * The #ClutterTimeline::completed signal is emitted when the timeline's
     * elapsed time reaches the value of the #ClutterTimeline:duration
     * property.
     * 
     * This signal will be emitted even if the #ClutterTimeline is set to be
     * repeating.
     * 
     * If you want to get notification on whether the #ClutterTimeline has
     * been stopped or has finished its run, including its eventual repeats,
     * you should use the #ClutterTimeline::stopped signal instead.
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /**
     * The ::marker-reached signal is emitted each time a timeline
     * reaches a marker set with
     * clutter_timeline_add_marker_at_time(). This signal is detailed
     * with the name of the marker as well, so it is possible to connect
     * a callback to the ::marker-reached signal for a specific marker
     * with:
     * 
     * <informalexample><programlisting>
     *   clutter_timeline_add_marker_at_time (timeline, "foo", 500);
     *   clutter_timeline_add_marker_at_time (timeline, "bar", 750);
     * 
     *   g_signal_connect (timeline, "marker-reached",
     *                     G_CALLBACK (each_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::foo",
     *                     G_CALLBACK (foo_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::bar",
     *                     G_CALLBACK (bar_marker_reached), NULL);
     * </programlisting></informalexample>
     * 
     * In the example, the first callback will be invoked for both
     * the "foo" and "bar" marker, while the second and third callbacks
     * will be invoked for the "foo" or "bar" markers, respectively.
     */
    connect(sigName: "marker-reached", callback: ((markerName: string, msecs: number) => void)): number
    on(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "marker-reached", markerName: string, msecs: number): void
    /**
     * The ::new-frame signal is emitted for each timeline running
     * timeline before a new frame is drawn to give animations a chance
     * to update the scene.
     */
    connect(sigName: "new-frame", callback: ((msecs: number) => void)): number
    on(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-frame", callback: (msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "new-frame", msecs: number): void
    /**
     * The ::paused signal is emitted when clutter_timeline_pause() is invoked.
     */
    connect(sigName: "paused", callback: (() => void)): number
    on(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paused", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paused"): void
    /**
     * The ::started signal is emitted when the timeline starts its run.
     * This might be as soon as clutter_timeline_start() is invoked or
     * after the delay set in the ClutterTimeline:delay property has
     * expired.
     */
    connect(sigName: "started", callback: (() => void)): number
    on(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "started", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "started"): void
    /**
     * The #ClutterTimeline::stopped signal is emitted when the timeline
     * has been stopped, either because clutter_timeline_stop() has been
     * called, or because it has been exhausted.
     * 
     * This is different from the #ClutterTimeline::completed signal,
     * which gets emitted after every repeat finishes.
     * 
     * If the #ClutterTimeline has is marked as infinitely repeating,
     * this signal will never be emitted.
     */
    connect(sigName: "stopped", callback: ((isFinished: boolean) => void)): number
    on(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "stopped", callback: (isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "stopped", isFinished: boolean): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::property-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::property-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::property-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::property-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::property-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: KeyframeTransition_ConstructProps)
    _init (config?: KeyframeTransition_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(propertyName: string): KeyframeTransition
    /* Function overloads */
    static new(propertyName?: string | null): KeyframeTransition
    static new(msecs: number): KeyframeTransition
    static $gtype: GObject.Type
}
interface LayoutManager_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
}
class LayoutManager {
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.LayoutManager */
    /**
     * Allocates the children of `container` given an area
     * 
     * See also clutter_actor_allocate()
     */
    allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void
    /**
     * Begins an animation of `duration` milliseconds, using the provided
     * easing `mode`
     * 
     * The easing mode can be specified either as a #ClutterAnimationMode
     * or as a logical id returned by clutter_alpha_register_func()
     * 
     * The result of this function depends on the `manager` implementation
     */
    beginAnimation(duration: number, mode: number): Alpha
    /**
     * Gets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     * 
     * The #GValue must already be initialized to the type of the property
     * and has to be unset with g_value_unset() after extracting the real
     * value out of it
     */
    childGetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Sets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     */
    childSetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Ends an animation started by clutter_layout_manager_begin_animation()
     * 
     * The result of this call depends on the `manager` implementation
     */
    endAnimation(): void
    /**
     * Retrieves the #GParamSpec for the layout property `name` inside
     * the #ClutterLayoutMeta sub-class used by `manager`
     */
    findChildProperty(name: string): GObject.ParamSpec
    /**
     * Retrieves the progress of the animation, if one has been started by
     * clutter_layout_manager_begin_animation()
     * 
     * The returned value has the same semantics of the #ClutterAlpha:alpha
     * value
     */
    getAnimationProgress(): number
    /**
     * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
     * to the `actor` child of `container,` eventually by creating one if the
     * #ClutterLayoutManager supports layout properties
     */
    getChildMeta(container: Container, actor: Actor): LayoutMeta
    /**
     * Computes the minimum and natural heights of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_height()
     */
    getPreferredHeight(container: Container, forWidth: number): [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    /**
     * Computes the minimum and natural widths of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_width()
     */
    getPreferredWidth(container: Container, forHeight: number): [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    /**
     * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
     * 
     * This function should only be called by implementations of the
     * #ClutterLayoutManager class
     */
    layoutChanged(): void
    /**
     * Retrieves all the #GParamSpec<!-- -->s for the layout properties
     * stored inside the #ClutterLayoutMeta sub-class used by `manager`
     */
    listChildProperties(): GObject.ParamSpec[]
    /**
     * If the #ClutterLayoutManager sub-class allows it, allow
     * adding a weak reference of the `container` using `manager`
     * from within the layout manager
     * 
     * The layout manager should not increase the reference
     * count of the `container`
     */
    setContainer(container?: Container | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.LayoutManager */
    /**
     * The ::layout-changed signal is emitted each time a layout manager
     * has been changed. Every #ClutterActor using the `manager` instance
     * as a layout manager should connect a handler to the ::layout-changed
     * signal and queue a relayout on themselves:
     * 
     * |[
     *   static void layout_changed (ClutterLayoutManager *manager,
     *                               ClutterActor         *self)
     *   {
     *     clutter_actor_queue_relayout (self);
     *   }
     *   ...
     *     self->manager = g_object_ref_sink (manager);
     *     g_signal_connect (self->manager, "layout-changed",
     *                       G_CALLBACK (layout_changed),
     *                       self);
     * ```
     * 
     * 
     * Sub-classes of #ClutterLayoutManager that implement a layout that
     * can be controlled or changed using parameters should emit the
     * ::layout-changed signal whenever one of the parameters changes,
     * by using clutter_layout_manager_layout_changed().
     */
    connect(sigName: "layout-changed", callback: (() => void)): number
    on(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "layout-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "layout-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: LayoutManager_ConstructProps)
    _init (config?: LayoutManager_ConstructProps): void
    static $gtype: GObject.Type
}
interface LayoutMeta_ConstructProps extends ChildMeta_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.LayoutMeta */
    /**
     * The #ClutterLayoutManager that created this #ClutterLayoutMeta.
     */
    manager?: LayoutManager
}
class LayoutMeta {
    /* Fields of Clutter-1.0.Clutter.ChildMeta */
    /**
     * the container handling this data
     */
    readonly container: Container
    /**
     * the actor wrapped by this data
     */
    readonly actor: Actor
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.LayoutMeta */
    /**
     * Retrieves the actor wrapped by `data`
     */
    getManager(): LayoutManager
    /* Methods of Clutter-1.0.Clutter.ChildMeta */
    /**
     * Retrieves the actor wrapped by `data`
     */
    getActor(): Actor
    /**
     * Retrieves the container using `data`
     */
    getContainer(): Container
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: LayoutMeta_ConstructProps)
    _init (config?: LayoutMeta_ConstructProps): void
    static $gtype: GObject.Type
}
interface ListModel_ConstructProps extends Model_ConstructProps {
}
class ListModel {
    /* Properties of Clutter-1.0.Clutter.Model */
    /**
     * Whether the #ClutterModel has a filter set
     * 
     * This property is set to %TRUE if a filter function has been
     * set using clutter_model_set_filter()
     */
    readonly filterSet: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Model */
    /**
     * Creates and appends a new row to the #ClutterModel, setting the row
     * values for the given `columns` upon creation.
     */
    appendv(columns: number[], values: any[]): void
    /**
     * Checks whether the row pointer by `iter` should be filtered or not using
     * the filtering function set on `model`.
     * 
     * This function should be used only by subclasses of #ClutterModel.
     */
    filterIter(iter: ModelIter): boolean
    /**
     * Checks whether `row` should be filtered or not using the
     * filtering function set on `model`.
     * 
     * This function should be used only by subclasses of #ClutterModel.
     */
    filterRow(row: number): boolean
    /**
     * Calls `func` for each row in the model.
     */
    foreach(func: ModelForeachFunc): void
    /**
     * Retrieves the name of the `column`
     */
    getColumnName(column: number): string
    /**
     * Retrieves the type of the `column`.
     */
    getColumnType(column: number): GObject.Type
    /**
     * Returns whether the `model` has a filter in place, set
     * using clutter_model_set_filter()
     */
    getFilterSet(): boolean
    /**
     * Retrieves a #ClutterModelIter representing the first non-filtered
     * row in `model`.
     */
    getFirstIter(): ModelIter
    /**
     * Retrieves a #ClutterModelIter representing the row at the given index.
     * 
     * If a filter function has been set using clutter_model_set_filter()
     * then the `model` implementation will return the first non filtered
     * row.
     */
    getIterAtRow(row: number): ModelIter
    /**
     * Retrieves a #ClutterModelIter representing the last non-filtered
     * row in `model`.
     */
    getLastIter(): ModelIter
    /**
     * Retrieves the number of columns inside `model`.
     */
    getNColumns(): number
    /**
     * Retrieves the number of rows inside `model,` eventually taking
     * into account any filtering function set using clutter_model_set_filter().
     */
    getNRows(): number
    /**
     * Retrieves the number of column used for sorting the `model`.
     */
    getSortingColumn(): number
    /**
     * Sets the data in the cell specified by `iter` and `column`. The type of
     * `value` must be convertable to the type of the column. If the row does
     * not exist then it is created.
     */
    insertValue(row: number, column: number, value: any): void
    /**
     * Inserts data at `row` into the #ClutterModel, setting the row
     * values for the given `columns` upon creation.
     */
    insertv(row: number, columns: number[], values: any[]): void
    /**
     * Creates and prepends a new row to the #ClutterModel, setting the row
     * values for the given `columns` upon creation.
     */
    prependv(columns: number[], values: any[]): void
    /**
     * Removes the row at the given position from the model.
     */
    remove(row: number): void
    /**
     * Force a resort on the `model`. This function should only be
     * used by subclasses of #ClutterModel.
     */
    resort(): void
    /**
     * Filters the `model` using the given filtering function.
     */
    setFilter(func: ModelFilterFunc | null): void
    /**
     * Assigns a name to the columns of a #ClutterModel.
     * 
     * This function is meant primarily for #GObjects that inherit from
     * #ClutterModel, and should only be used when contructing a #ClutterModel.
     * It will not work after the initial creation of the #ClutterModel.
     */
    setNames(names: string[]): void
    /**
     * Sorts `model` using the given sorting function.
     */
    setSort(column: number, func: ModelSortFunc | null): void
    /**
     * Sets the model to sort by `column`. If `column` is a negative value
     * the sorting column will be unset.
     */
    setSortingColumn(column: number): void
    /**
     * Sets the types of the columns inside a #ClutterModel.
     * 
     * This function is meant primarily for #GObjects that inherit from
     * #ClutterModel, and should only be used when contructing a #ClutterModel.
     * It will not work after the initial creation of the #ClutterModel.
     */
    setTypes(types: GObject.Type[]): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Model */
    /**
     * The ::filter-changed signal is emitted when a new filter has been applied
     */
    connect(sigName: "filter-changed", callback: (() => void)): number
    on(sigName: "filter-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "filter-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "filter-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "filter-changed"): void
    /**
     * The ::row-added signal is emitted when a new row has been added.
     * The data on the row has already been set when the ::row-added signal
     * has been emitted.
     */
    connect(sigName: "row-added", callback: ((iter: ModelIter) => void)): number
    on(sigName: "row-added", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-added", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-added", callback: (iter: ModelIter) => void): NodeJS.EventEmitter
    emit(sigName: "row-added", iter: ModelIter): void
    /**
     * The ::row-removed signal is emitted when a row has been changed.
     * The data on the row has already been updated when the ::row-changed
     * signal has been emitted.
     */
    connect(sigName: "row-changed", callback: ((iter: ModelIter) => void)): number
    on(sigName: "row-changed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-changed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-changed", callback: (iter: ModelIter) => void): NodeJS.EventEmitter
    emit(sigName: "row-changed", iter: ModelIter): void
    /**
     * The ::row-removed signal is emitted when a row has been removed.
     * The data on the row pointed by the passed iterator is still valid
     * when the ::row-removed signal has been emitted.
     */
    connect(sigName: "row-removed", callback: ((iter: ModelIter) => void)): number
    on(sigName: "row-removed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (iter: ModelIter) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", iter: ModelIter): void
    /**
     * The ::sort-changed signal is emitted after the model has been sorted
     */
    connect(sigName: "sort-changed", callback: (() => void)): number
    on(sigName: "sort-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "sort-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "sort-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "sort-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::filter-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filter-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filter-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filter-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filter-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ListModel_ConstructProps)
    _init (config?: ListModel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newv(types: GObject.Type[], names: string[]): ListModel
    /* Function overloads */
    static newv(objectType: GObject.Type, parameters: GObject.Parameter[]): ListModel
    static $gtype: GObject.Type
}
interface Model_ConstructProps extends GObject.Object_ConstructProps {
}
class Model {
    /* Properties of Clutter-1.0.Clutter.Model */
    /**
     * Whether the #ClutterModel has a filter set
     * 
     * This property is set to %TRUE if a filter function has been
     * set using clutter_model_set_filter()
     */
    readonly filterSet: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Model */
    /**
     * Creates and appends a new row to the #ClutterModel, setting the row
     * values for the given `columns` upon creation.
     */
    appendv(columns: number[], values: any[]): void
    /**
     * Checks whether the row pointer by `iter` should be filtered or not using
     * the filtering function set on `model`.
     * 
     * This function should be used only by subclasses of #ClutterModel.
     */
    filterIter(iter: ModelIter): boolean
    /**
     * Checks whether `row` should be filtered or not using the
     * filtering function set on `model`.
     * 
     * This function should be used only by subclasses of #ClutterModel.
     */
    filterRow(row: number): boolean
    /**
     * Calls `func` for each row in the model.
     */
    foreach(func: ModelForeachFunc): void
    /**
     * Retrieves the name of the `column`
     */
    getColumnName(column: number): string
    /**
     * Retrieves the type of the `column`.
     */
    getColumnType(column: number): GObject.Type
    /**
     * Returns whether the `model` has a filter in place, set
     * using clutter_model_set_filter()
     */
    getFilterSet(): boolean
    /**
     * Retrieves a #ClutterModelIter representing the first non-filtered
     * row in `model`.
     */
    getFirstIter(): ModelIter
    /**
     * Retrieves a #ClutterModelIter representing the row at the given index.
     * 
     * If a filter function has been set using clutter_model_set_filter()
     * then the `model` implementation will return the first non filtered
     * row.
     */
    getIterAtRow(row: number): ModelIter
    /**
     * Retrieves a #ClutterModelIter representing the last non-filtered
     * row in `model`.
     */
    getLastIter(): ModelIter
    /**
     * Retrieves the number of columns inside `model`.
     */
    getNColumns(): number
    /**
     * Retrieves the number of rows inside `model,` eventually taking
     * into account any filtering function set using clutter_model_set_filter().
     */
    getNRows(): number
    /**
     * Retrieves the number of column used for sorting the `model`.
     */
    getSortingColumn(): number
    /**
     * Sets the data in the cell specified by `iter` and `column`. The type of
     * `value` must be convertable to the type of the column. If the row does
     * not exist then it is created.
     */
    insertValue(row: number, column: number, value: any): void
    /**
     * Inserts data at `row` into the #ClutterModel, setting the row
     * values for the given `columns` upon creation.
     */
    insertv(row: number, columns: number[], values: any[]): void
    /**
     * Creates and prepends a new row to the #ClutterModel, setting the row
     * values for the given `columns` upon creation.
     */
    prependv(columns: number[], values: any[]): void
    /**
     * Removes the row at the given position from the model.
     */
    remove(row: number): void
    /**
     * Force a resort on the `model`. This function should only be
     * used by subclasses of #ClutterModel.
     */
    resort(): void
    /**
     * Filters the `model` using the given filtering function.
     */
    setFilter(func: ModelFilterFunc | null): void
    /**
     * Assigns a name to the columns of a #ClutterModel.
     * 
     * This function is meant primarily for #GObjects that inherit from
     * #ClutterModel, and should only be used when contructing a #ClutterModel.
     * It will not work after the initial creation of the #ClutterModel.
     */
    setNames(names: string[]): void
    /**
     * Sorts `model` using the given sorting function.
     */
    setSort(column: number, func: ModelSortFunc | null): void
    /**
     * Sets the model to sort by `column`. If `column` is a negative value
     * the sorting column will be unset.
     */
    setSortingColumn(column: number): void
    /**
     * Sets the types of the columns inside a #ClutterModel.
     * 
     * This function is meant primarily for #GObjects that inherit from
     * #ClutterModel, and should only be used when contructing a #ClutterModel.
     * It will not work after the initial creation of the #ClutterModel.
     */
    setTypes(types: GObject.Type[]): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Model */
    /**
     * The ::filter-changed signal is emitted when a new filter has been applied
     */
    connect(sigName: "filter-changed", callback: (() => void)): number
    on(sigName: "filter-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "filter-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "filter-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "filter-changed"): void
    /**
     * The ::row-added signal is emitted when a new row has been added.
     * The data on the row has already been set when the ::row-added signal
     * has been emitted.
     */
    connect(sigName: "row-added", callback: ((iter: ModelIter) => void)): number
    on(sigName: "row-added", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-added", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-added", callback: (iter: ModelIter) => void): NodeJS.EventEmitter
    emit(sigName: "row-added", iter: ModelIter): void
    /**
     * The ::row-removed signal is emitted when a row has been changed.
     * The data on the row has already been updated when the ::row-changed
     * signal has been emitted.
     */
    connect(sigName: "row-changed", callback: ((iter: ModelIter) => void)): number
    on(sigName: "row-changed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-changed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-changed", callback: (iter: ModelIter) => void): NodeJS.EventEmitter
    emit(sigName: "row-changed", iter: ModelIter): void
    /**
     * The ::row-removed signal is emitted when a row has been removed.
     * The data on the row pointed by the passed iterator is still valid
     * when the ::row-removed signal has been emitted.
     */
    connect(sigName: "row-removed", callback: ((iter: ModelIter) => void)): number
    on(sigName: "row-removed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "row-removed", callback: (iter: ModelIter) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "row-removed", callback: (iter: ModelIter) => void): NodeJS.EventEmitter
    emit(sigName: "row-removed", iter: ModelIter): void
    /**
     * The ::sort-changed signal is emitted after the model has been sorted
     */
    connect(sigName: "sort-changed", callback: (() => void)): number
    on(sigName: "sort-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "sort-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "sort-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "sort-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::filter-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filter-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filter-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filter-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filter-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Model_ConstructProps)
    _init (config?: Model_ConstructProps): void
    static $gtype: GObject.Type
}
interface ModelIter_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ModelIter */
    /**
     * A reference to the #ClutterModel that this iter belongs to.
     */
    model?: Model
    /**
     * The row number to which this iter points to.
     */
    row?: number
}
class ModelIter {
    /* Properties of Clutter-1.0.Clutter.ModelIter */
    /**
     * A reference to the #ClutterModel that this iter belongs to.
     */
    model: Model
    /**
     * The row number to which this iter points to.
     */
    row: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ModelIter */
    /**
     * Copies the passed iterator.
     */
    copy(): ModelIter
    /**
     * Retrieves a pointer to the #ClutterModel that this iter is part of.
     */
    getModel(): Model
    /**
     * Retrieves the position of the row that the `iter` points to.
     */
    getRow(): number
    /**
     * Sets an initializes `value` to that at `column`. When done with `value,`
     * g_value_unset() needs to be called to free any allocated memory.
     */
    getValue(column: number): /* value */ any
    /**
     * Gets whether the current iterator is at the beginning of the model
     * to which it belongs.
     */
    isFirst(): boolean
    /**
     * Gets whether the iterator is at the end of the model to which it
     * belongs.
     */
    isLast(): boolean
    /**
     * Updates the `iter` to point at the next position in the model.
     * The model implementation should take into account the presence of
     * a filter function.
     */
    next(): ModelIter
    /**
     * Sets the `iter` to point at the previous position in the model.
     * The model implementation should take into account the presence of
     * a filter function.
     */
    prev(): ModelIter
    /**
     * Sets the data in the cell specified by `iter` and `column`. The type of
     * `value` must be convertable to the type of the column.
     */
    setValue(column: number, value: any): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::model", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::row", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::row", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::row", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::row", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::row", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ModelIter_ConstructProps)
    _init (config?: ModelIter_ConstructProps): void
    static $gtype: GObject.Type
}
interface OffscreenEffect_ConstructProps extends Effect_ConstructProps {
}
class OffscreenEffect {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: OffscreenEffect_ConstructProps)
    _init (config?: OffscreenEffect_ConstructProps): void
    static $gtype: GObject.Type
}
interface PageTurnEffect_ConstructProps extends DeformEffect_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.PageTurnEffect */
    /**
     * The angle of the page rotation, in degrees, between 0.0 and 360.0
     */
    angle?: number
    /**
     * The period of the page turn, between 0.0 (no curling) and
     * 1.0 (fully curled)
     */
    period?: number
    /**
     * The radius of the page curl, in pixels
     */
    radius?: number
}
class PageTurnEffect {
    /* Properties of Clutter-1.0.Clutter.PageTurnEffect */
    /**
     * The angle of the page rotation, in degrees, between 0.0 and 360.0
     */
    angle: number
    /**
     * The period of the page turn, between 0.0 (no curling) and
     * 1.0 (fully curled)
     */
    period: number
    /**
     * The radius of the page curl, in pixels
     */
    radius: number
    /* Properties of Clutter-1.0.Clutter.DeformEffect */
    /**
     * The number of horizontal tiles. The bigger the number, the
     * smaller the tiles
     */
    xTiles: number
    /**
     * The number of vertical tiles. The bigger the number, the
     * smaller the tiles
     */
    yTiles: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.PageTurnEffect */
    /**
     * Retrieves the value set using clutter_page_turn_effect_get_angle()
     */
    getAngle(): number
    /**
     * Retrieves the value set using clutter_page_turn_effect_get_period()
     */
    getPeriod(): number
    /**
     * Retrieves the value set using clutter_page_turn_effect_set_radius()
     */
    getRadius(): number
    /**
     * Sets the angle of the page curling, in degrees
     */
    setAngle(angle: number): void
    /**
     * Sets the period of the page curling, between 0.0 (no curling)
     * and 1.0 (fully curled)
     */
    setPeriod(period: number): void
    /**
     * Sets the radius of the page curling
     */
    setRadius(radius: number): void
    /* Methods of Clutter-1.0.Clutter.DeformEffect */
    /**
     * Retrieves the handle to the back face material used by `effect`
     */
    getBackMaterial(): Cogl.Handle
    /**
     * Retrieves the number of horizontal and vertical tiles used to sub-divide
     * the actor's geometry during the effect
     */
    getNTiles(): [ /* xTiles */ number, /* yTiles */ number ]
    /**
     * Invalidates the `effect<`!-- -->'s vertices and, if it is associated
     * to an actor, it will queue a redraw
     */
    invalidate(): void
    /**
     * Sets the material that should be used when drawing the back face
     * of the actor during a deformation
     * 
     * The #ClutterDeformEffect will take a reference on the material's
     * handle
     */
    setBackMaterial(material?: Cogl.Handle | null): void
    /**
     * Sets the number of horizontal and vertical tiles to be used
     * when applying the effect
     * 
     * More tiles allow a finer grained deformation at the expenses
     * of computation
     */
    setNTiles(xTiles: number, yTiles: number): void
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::angle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::angle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::angle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::angle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::angle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::period", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::period", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::period", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::period", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::period", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::radius", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::radius", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::radius", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::radius", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::radius", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-tiles", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-tiles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: PageTurnEffect_ConstructProps)
    _init (config?: PageTurnEffect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(period: number, angle: number, radius: number): PageTurnEffect
    static $gtype: GObject.Type
}
class PaintNode {
    /* Methods of Clutter-1.0.Clutter.PaintNode */
    /**
     * Adds `child` to the list of children of `node`.
     * 
     * This function will acquire a reference on `child`.
     */
    addChild(child: PaintNode): void
    /**
     * Adds a rectangle region to the `node,` as described by the
     * passed `rect`.
     */
    addRectangle(rect: ActorBox): void
    /**
     * Adds a rectangle region to the `node,` with texture coordinates.
     */
    addTextureRectangle(rect: ActorBox, x1: number, y1: number, x2: number, y2: number): void
    /**
     * Acquires a reference on `node`.
     */
    ref(): PaintNode
    /**
     * Sets a user-readable `name` for `node`.
     * 
     * The `name` will be used for debugging purposes.
     * 
     * The `node` will copy the passed string.
     */
    setName(name: string): void
    /**
     * Releases a reference on `node`.
     */
    unref(): void
    static name: string
}
interface PanAction_ConstructProps extends GestureAction_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.PanAction */
    /**
     * The initial acceleration factor
     * 
     * The kinetic momentum measured at the time of releasing the pointer will
     * be multiplied by the factor specified by this property before being used
     * to generate interpolated ::pan events.
     */
    accelerationFactor?: number
    /**
     * The rate at which the interpolated panning will decelerate in
     * 
     * #ClutterPanAction will emit interpolated ::pan events with decreasing
     * scroll deltas, using the rate specified by this property.
     */
    deceleration?: number
    /**
     * Whether interpolated events emission is enabled.
     */
    interpolate?: boolean
    /**
     * Constraints the panning action to the specified axis
     */
    panAxis?: PanAxis
}
class PanAction {
    /* Properties of Clutter-1.0.Clutter.PanAction */
    /**
     * The initial acceleration factor
     * 
     * The kinetic momentum measured at the time of releasing the pointer will
     * be multiplied by the factor specified by this property before being used
     * to generate interpolated ::pan events.
     */
    accelerationFactor: number
    /**
     * The rate at which the interpolated panning will decelerate in
     * 
     * #ClutterPanAction will emit interpolated ::pan events with decreasing
     * scroll deltas, using the rate specified by this property.
     */
    deceleration: number
    /**
     * Whether interpolated events emission is enabled.
     */
    interpolate: boolean
    /**
     * Constraints the panning action to the specified axis
     */
    panAxis: PanAxis
    /* Properties of Clutter-1.0.Clutter.GestureAction */
    /**
     * Number of touch points to trigger a gesture action.
     */
    nTouchPoints: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.PanAction */
    /**
     * Retrieves the initial acceleration factor for interpolated ::pan events.
     */
    getAccelerationFactor(): number
    /**
     * Retrieves the delta, in stage space, dependent on the current state
     * of the #ClutterPanAction, and respecting the constraint specified by the
     * #ClutterPanAction:pan-axis property.
     */
    getConstrainedMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the deceleration rate of interpolated ::pan events.
     */
    getDeceleration(): number
    /**
     * Checks if the action should emit ::pan events even after releasing
     * the pointer during a panning gesture, to emulate some kind of
     * kinetic inertia.
     */
    getInterpolate(): boolean
    /**
     * Retrieves the coordinates, in stage space, of the latest interpolated
     * event, analogous to clutter_gesture_action_get_motion_coords().
     */
    getInterpolatedCoords(): [ /* interpolatedX */ number | null, /* interpolatedY */ number | null ]
    /**
     * Retrieves the delta, in stage space, since the latest interpolated
     * event, analogous to clutter_gesture_action_get_motion_delta().
     */
    getInterpolatedDelta(): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the coordinates, in stage space, dependent on the current state
     * of the #ClutterPanAction. If it is inactive, both fields will be
     * set to 0. If it is panning by user action, the values will be equivalent
     * to those returned by clutter_gesture_action_get_motion_coords().
     * If it is interpolating with some form of kinetic scrolling, the values
     * will be equivalent to those returned by
     * clutter_pan_action_get_interpolated_coords(). This is a convenience
     * method designed to be used in replacement "pan" signal handlers.
     */
    getMotionCoords(point: number): [ /* motionX */ number | null, /* motionY */ number | null ]
    /**
     * Retrieves the delta, in stage space, dependent on the current state
     * of the #ClutterPanAction. If it is inactive, both fields will be
     * set to 0. If it is panning by user action, the values will be equivalent
     * to those returned by clutter_gesture_action_get_motion_delta().
     * If it is interpolating with some form of kinetic scrolling, the values
     * will be equivalent to those returned by
     * clutter_pan_action_get_interpolated_delta(). This is a convenience
     * method designed to be used in replacement "pan" signal handlers.
     */
    getMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the axis constraint set by clutter_pan_action_set_pan_axis()
     */
    getPanAxis(): PanAxis
    /**
     * Factor applied to the momentum velocity at the time of releasing the
     * pointer when generating interpolated ::pan events.
     */
    setAccelerationFactor(factor: number): void
    /**
     * Sets the deceleration rate of the interpolated ::pan events generated
     * after a pan gesture. This is approximately the value that the momentum
     * at the time of releasing the pointer is divided by every 60th of a second.
     */
    setDeceleration(rate: number): void
    /**
     * Sets whether the action should emit interpolated ::pan events
     * after the drag has ended, to emulate the gesture kinetic inertia.
     */
    setInterpolate(shouldInterpolate: boolean): void
    /**
     * Restricts the panning action to a specific axis
     */
    setPanAxis(axis: PanAxis): void
    /* Methods of Clutter-1.0.Clutter.GestureAction */
    /**
     * Cancel a #ClutterGestureAction before it begins
     */
    cancel(): void
    /**
     * Retrieves the #ClutterInputDevice of a touch point.
     */
    getDevice(point: number): InputDevice
    /**
     * Retrieves a reference to the last #ClutterEvent for a touch point. Call
     * clutter_event_copy() if you need to store the reference somewhere.
     */
    getLastEvent(point: number): Event
    /**
     * Retrieves the coordinates, in stage space, of the latest motion
     * event during the dragging.
     */
    getMotionCoords(point: number): [ /* motionX */ number | null, /* motionY */ number | null ]
    /**
     * Retrieves the incremental delta since the last motion event
     * during the dragging.
     */
    getMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the number of points currently active.
     */
    getNCurrentPoints(): number
    /**
     * Retrieves the number of requested points to trigger the gesture.
     */
    getNTouchPoints(): number
    /**
     * Retrieves the coordinates, in stage space, of the press event
     * that started the dragging for a specific touch point.
     */
    getPressCoords(point: number): [ /* pressX */ number | null, /* pressY */ number | null ]
    /**
     * Retrieves the coordinates, in stage space, where the touch point was
     * last released.
     */
    getReleaseCoords(point: number): [ /* releaseX */ number | null, /* releaseY */ number | null ]
    /**
     * Retrieves the #ClutterEventSequence of a touch point.
     */
    getSequence(point: number): EventSequence
    /**
     * Retrieves the threshold trigger distance of the gesture `action,`
     * as set using clutter_gesture_action_set_threshold_trigger_distance().
     */
    getThresholdTriggerDistance(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEdge(): GestureTriggerEdge
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEgde(): GestureTriggerEdge
    /**
     * Retrieves the velocity, in stage pixels per millisecond, of the
     * latest motion event during the dragging.
     */
    getVelocity(point: number): [ /* returnType */ number, /* velocityX */ number | null, /* velocityY */ number | null ]
    /**
     * Sets the number of points needed to trigger the gesture.
     */
    setNTouchPoints(nbPoints: number): void
    /**
     * Sets the threshold trigger distance for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerDistance(x: number, y: number): void
    /**
     * Sets the edge trigger for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerEdge(edge: GestureTriggerEdge): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.PanAction */
    /**
     * The ::pan signal is emitted to keep track of the motion during
     * a pan gesture. `is_interpolated` is set to %TRUE during the
     * interpolation phase of the pan, after the drag has ended and
     * the :interpolate property was set to %TRUE.
     */
    connect(sigName: "pan", callback: ((actor: Actor, isInterpolated: boolean) => boolean)): number
    on(sigName: "pan", callback: (actor: Actor, isInterpolated: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pan", callback: (actor: Actor, isInterpolated: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pan", callback: (actor: Actor, isInterpolated: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "pan", actor: Actor, isInterpolated: boolean): void
    /**
     * The ::pan-stopped signal is emitted at the end of the interpolation
     * phase of the pan action, only when :interpolate is set to %TRUE.
     */
    connect(sigName: "pan-stopped", callback: ((actor: Actor) => void)): number
    on(sigName: "pan-stopped", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pan-stopped", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pan-stopped", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "pan-stopped", actor: Actor): void
    /* Signals of Clutter-1.0.Clutter.GestureAction */
    /**
     * The ::gesture_begin signal is emitted when the #ClutterActor to which
     * a #ClutterGestureAction has been applied starts receiving a gesture.
     */
    connect(sigName: "gesture-begin", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-begin", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-begin", actor: Actor): void
    /**
     * The ::gesture-cancel signal is emitted when the ongoing gesture gets
     * cancelled from the #ClutterGestureAction::gesture-progress signal handler.
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-cancel", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-cancel", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-cancel", actor: Actor): void
    /**
     * The ::gesture-end signal is emitted at the end of the gesture gesture,
     * when the pointer's button is released
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-end", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-end", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-end", actor: Actor): void
    /**
     * The ::gesture-progress signal is emitted for each motion event after
     * the #ClutterGestureAction::gesture-begin signal has been emitted.
     */
    connect(sigName: "gesture-progress", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-progress", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-progress", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::acceleration-factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::acceleration-factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::acceleration-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::acceleration-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::acceleration-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::deceleration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::deceleration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::deceleration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::deceleration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::deceleration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interpolate", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interpolate", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interpolate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interpolate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interpolate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pan-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pan-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pan-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pan-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pan-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: PanAction_ConstructProps)
    _init (config?: PanAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): PanAction
    static $gtype: GObject.Type
}
class ParamSpecColor {
    /* Fields of GObject-2.0.GObject.ParamSpec */
    /**
     * private #GTypeInstance portion
     */
    readonly gTypeInstance: GObject.TypeInstance
    /**
     * name of this parameter: always an interned string
     */
    readonly name: string
    /**
     * #GParamFlags flags for this parameter
     */
    readonly flags: GObject.ParamFlags
    /**
     * the #GValue type for this parameter
     */
    readonly valueType: GObject.Type
    /**
     * #GType type that uses (introduces) this parameter
     */
    readonly ownerType: GObject.Type
    /* Methods of GObject-2.0.GObject.ParamSpec */
    /**
     * Get the short description of a #GParamSpec.
     */
    getBlurb(): string | null
    /**
     * Gets the default value of `pspec` as a pointer to a #GValue.
     * 
     * The #GValue will remain valid for the life of `pspec`.
     */
    getDefaultValue(): any
    /**
     * Get the name of a #GParamSpec.
     * 
     * The name is always an "interned" string (as per g_intern_string()).
     * This allows for pointer-value comparisons.
     */
    getName(): string
    /**
     * Gets the GQuark for the name.
     */
    getNameQuark(): GLib.Quark
    /**
     * Get the nickname of a #GParamSpec.
     */
    getNick(): string
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * If the paramspec redirects operations to another paramspec,
     * returns that paramspec. Redirect is used typically for
     * providing a new implementation of a property in a derived
     * type while preserving all the properties from the parent
     * type. Redirection is established by creating a property
     * of type #GParamSpecOverride. See g_object_class_override_property()
     * for an example of the use of this capability.
     */
    getRedirectTarget(): GObject.ParamSpec | null
    /**
     * Sets an opaque, named pointer on a #GParamSpec. The name is
     * specified through a #GQuark (retrieved e.g. via
     * g_quark_from_static_string()), and the pointer can be gotten back
     * from the `pspec` with g_param_spec_get_qdata().  Setting a
     * previously set user data pointer, overrides (frees) the old pointer
     * set, using %NULL as pointer essentially removes the data stored.
     */
    setQdata(quark: GLib.Quark, data?: object | null): void
    /**
     * The initial reference count of a newly created #GParamSpec is 1,
     * even though no one has explicitly called g_param_spec_ref() on it
     * yet. So the initial reference count is flagged as "floating", until
     * someone calls `g_param_spec_ref (pspec); g_param_spec_sink
     * (pspec);` in sequence on it, taking over the initial
     * reference count (thus ending up with a `pspec` that has a reference
     * count of 1 still, but is not flagged "floating" anymore).
     */
    sink(): void
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata()
     * and removes the `data` from `pspec` without invoking its destroy()
     * function (if any was set).  Usually, calling this function is only
     * required to update user data pointers with a destroy notifier.
     */
    stealQdata(quark: GLib.Quark): object | null
    static name: string
}
class ParamSpecFixed {
    /* Fields of GObject-2.0.GObject.ParamSpec */
    /**
     * private #GTypeInstance portion
     */
    readonly gTypeInstance: GObject.TypeInstance
    /**
     * name of this parameter: always an interned string
     */
    readonly name: string
    /**
     * #GParamFlags flags for this parameter
     */
    readonly flags: GObject.ParamFlags
    /**
     * the #GValue type for this parameter
     */
    readonly valueType: GObject.Type
    /**
     * #GType type that uses (introduces) this parameter
     */
    readonly ownerType: GObject.Type
    /* Methods of GObject-2.0.GObject.ParamSpec */
    /**
     * Get the short description of a #GParamSpec.
     */
    getBlurb(): string | null
    /**
     * Gets the default value of `pspec` as a pointer to a #GValue.
     * 
     * The #GValue will remain valid for the life of `pspec`.
     */
    getDefaultValue(): any
    /**
     * Get the name of a #GParamSpec.
     * 
     * The name is always an "interned" string (as per g_intern_string()).
     * This allows for pointer-value comparisons.
     */
    getName(): string
    /**
     * Gets the GQuark for the name.
     */
    getNameQuark(): GLib.Quark
    /**
     * Get the nickname of a #GParamSpec.
     */
    getNick(): string
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * If the paramspec redirects operations to another paramspec,
     * returns that paramspec. Redirect is used typically for
     * providing a new implementation of a property in a derived
     * type while preserving all the properties from the parent
     * type. Redirection is established by creating a property
     * of type #GParamSpecOverride. See g_object_class_override_property()
     * for an example of the use of this capability.
     */
    getRedirectTarget(): GObject.ParamSpec | null
    /**
     * Sets an opaque, named pointer on a #GParamSpec. The name is
     * specified through a #GQuark (retrieved e.g. via
     * g_quark_from_static_string()), and the pointer can be gotten back
     * from the `pspec` with g_param_spec_get_qdata().  Setting a
     * previously set user data pointer, overrides (frees) the old pointer
     * set, using %NULL as pointer essentially removes the data stored.
     */
    setQdata(quark: GLib.Quark, data?: object | null): void
    /**
     * The initial reference count of a newly created #GParamSpec is 1,
     * even though no one has explicitly called g_param_spec_ref() on it
     * yet. So the initial reference count is flagged as "floating", until
     * someone calls `g_param_spec_ref (pspec); g_param_spec_sink
     * (pspec);` in sequence on it, taking over the initial
     * reference count (thus ending up with a `pspec` that has a reference
     * count of 1 still, but is not flagged "floating" anymore).
     */
    sink(): void
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata()
     * and removes the `data` from `pspec` without invoking its destroy()
     * function (if any was set).  Usually, calling this function is only
     * required to update user data pointers with a destroy notifier.
     */
    stealQdata(quark: GLib.Quark): object | null
    static name: string
}
class ParamSpecUnit {
    /* Fields of GObject-2.0.GObject.ParamSpec */
    /**
     * private #GTypeInstance portion
     */
    readonly gTypeInstance: GObject.TypeInstance
    /**
     * name of this parameter: always an interned string
     */
    readonly name: string
    /**
     * #GParamFlags flags for this parameter
     */
    readonly flags: GObject.ParamFlags
    /**
     * the #GValue type for this parameter
     */
    readonly valueType: GObject.Type
    /**
     * #GType type that uses (introduces) this parameter
     */
    readonly ownerType: GObject.Type
    /* Methods of GObject-2.0.GObject.ParamSpec */
    /**
     * Get the short description of a #GParamSpec.
     */
    getBlurb(): string | null
    /**
     * Gets the default value of `pspec` as a pointer to a #GValue.
     * 
     * The #GValue will remain valid for the life of `pspec`.
     */
    getDefaultValue(): any
    /**
     * Get the name of a #GParamSpec.
     * 
     * The name is always an "interned" string (as per g_intern_string()).
     * This allows for pointer-value comparisons.
     */
    getName(): string
    /**
     * Gets the GQuark for the name.
     */
    getNameQuark(): GLib.Quark
    /**
     * Get the nickname of a #GParamSpec.
     */
    getNick(): string
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * If the paramspec redirects operations to another paramspec,
     * returns that paramspec. Redirect is used typically for
     * providing a new implementation of a property in a derived
     * type while preserving all the properties from the parent
     * type. Redirection is established by creating a property
     * of type #GParamSpecOverride. See g_object_class_override_property()
     * for an example of the use of this capability.
     */
    getRedirectTarget(): GObject.ParamSpec | null
    /**
     * Sets an opaque, named pointer on a #GParamSpec. The name is
     * specified through a #GQuark (retrieved e.g. via
     * g_quark_from_static_string()), and the pointer can be gotten back
     * from the `pspec` with g_param_spec_get_qdata().  Setting a
     * previously set user data pointer, overrides (frees) the old pointer
     * set, using %NULL as pointer essentially removes the data stored.
     */
    setQdata(quark: GLib.Quark, data?: object | null): void
    /**
     * The initial reference count of a newly created #GParamSpec is 1,
     * even though no one has explicitly called g_param_spec_ref() on it
     * yet. So the initial reference count is flagged as "floating", until
     * someone calls `g_param_spec_ref (pspec); g_param_spec_sink
     * (pspec);` in sequence on it, taking over the initial
     * reference count (thus ending up with a `pspec` that has a reference
     * count of 1 still, but is not flagged "floating" anymore).
     */
    sink(): void
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata()
     * and removes the `data` from `pspec` without invoking its destroy()
     * function (if any was set).  Usually, calling this function is only
     * required to update user data pointers with a destroy notifier.
     */
    stealQdata(quark: GLib.Quark): object | null
    static name: string
}
interface Path_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Path */
    description?: string
}
class Path {
    /* Properties of Clutter-1.0.Clutter.Path */
    description: string
    readonly length: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Path */
    /**
     * Add the nodes of the Cairo path to the end of `path`.
     */
    addCairoPath(cpath: cairo.Path): void
    /**
     * Adds a %CLUTTER_PATH_CLOSE type node to the path. This creates a
     * straight line from the last node to the last %CLUTTER_PATH_MOVE_TO
     * type node.
     */
    addClose(): void
    /**
     * Adds a %CLUTTER_PATH_CURVE_TO type node to the path. This causes
     * the actor to follow a bezier from the last node to (`x_3`, `y_3`) using
     * (`x_1`, `y_1`) and (`x_2`,`y_2`) as control points.
     */
    addCurveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void
    /**
     * Adds a %CLUTTER_PATH_LINE_TO type node to the path. This causes the
     * actor to move to the new coordinates in a straight line.
     */
    addLineTo(x: number, y: number): void
    /**
     * Adds a %CLUTTER_PATH_MOVE_TO type node to the path. This is usually
     * used as the first node in a path. It can also be used in the middle
     * of the path to cause the actor to jump to the new coordinate.
     */
    addMoveTo(x: number, y: number): void
    /**
     * Adds `node` to the end of the path.
     */
    addNode(node: PathNode): void
    /**
     * Same as clutter_path_add_curve_to() except the coordinates are
     * relative to the previous node.
     */
    addRelCurveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void
    /**
     * Same as clutter_path_add_line_to() except the coordinates are
     * relative to the previous node.
     */
    addRelLineTo(x: number, y: number): void
    /**
     * Same as clutter_path_add_move_to() except the coordinates are
     * relative to the previous node.
     */
    addRelMoveTo(x: number, y: number): void
    /**
     * Adds new nodes to the end of the path as described in `str`. The
     * format is a subset of the SVG path format. Each node is represented
     * by a letter and is followed by zero, one or three pairs of
     * coordinates. The coordinates can be separated by spaces or a
     * comma. The types are:
     * 
     *  - `M`: Adds a %CLUTTER_PATH_MOVE_TO node. Takes one pair of coordinates.
     *  - `L`: Adds a %CLUTTER_PATH_LINE_TO node. Takes one pair of coordinates.
     *  - `C`: Adds a %CLUTTER_PATH_CURVE_TO node. Takes three pairs of coordinates.
     *  - `z`: Adds a %CLUTTER_PATH_CLOSE node. No coordinates are needed.
     * 
     * The M, L and C commands can also be specified in lower case which
     * means the coordinates are relative to the previous node.
     * 
     * For example, to move an actor in a 100 by 100 pixel square centered
     * on the point 300,300 you could use the following path:
     * 
     * |[
     *   M 250,350 l 0 -100 L 350,250 l 0 100 z
     * ```
     * 
     * 
     * If the path description isn't valid %FALSE will be returned and no
     * nodes will be added.
     */
    addString(str: string): boolean
    /**
     * Removes all nodes from the path.
     */
    clear(): void
    /**
     * Calls a function for each node of the path.
     */
    foreach(callback: PathCallback): void
    /**
     * Returns a newly allocated string describing the path in the same
     * format as used by clutter_path_add_string().
     */
    getDescription(): string
    /**
     * Retrieves an approximation of the total length of the path.
     */
    getLength(): number
    /**
     * Retrieves the number of nodes in the path.
     */
    getNNodes(): number
    /**
     * Retrieves the node of the path indexed by `index`.
     */
    getNode(index: number): /* node */ PathNode
    /**
     * Returns a #GSList of #ClutterPathNode<!-- -->s. The list should be
     * freed with g_slist_free(). The nodes are owned by the path and
     * should not be freed. Altering the path may cause the nodes in the
     * list to become invalid so you should copy them if you want to keep
     * the list.
     */
    getNodes(): PathNode[]
    /**
     * The value in `progress` represents a position along the path where
     * 0.0 is the beginning and 1.0 is the end of the path. An
     * interpolated position is then stored in `position`.
     */
    getPosition(progress: number): [ /* returnType */ number, /* position */ Knot ]
    /**
     * Inserts `node` into the path before the node at the given offset. If
     * `index_` is negative it will append the node to the end of the path.
     */
    insertNode(index: number, node: PathNode): void
    /**
     * Removes the node at the given offset from the path.
     */
    removeNode(index: number): void
    /**
     * Replaces the node at offset `index_` with `node`.
     */
    replaceNode(index: number, node: PathNode): void
    /**
     * Replaces all of the nodes in the path with nodes described by
     * `str`. See clutter_path_add_string() for details of the format.
     * 
     * If the string is invalid then %FALSE is returned and the path is
     * unaltered.
     */
    setDescription(str: string): boolean
    /**
     * Add the nodes of the ClutterPath to the path in the Cairo context.
     */
    toCairoPath(cr: cairo.Context): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::length", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::length", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Path_ConstructProps)
    _init (config?: Path_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Path
    static newWithDescription(desc: string): Path
    static $gtype: GObject.Type
}
interface PathConstraint_ConstructProps extends Constraint_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.PathConstraint */
    /**
     * The offset along the #ClutterPathConstraint:path, between -1.0 and 2.0.
     */
    offset?: number
    /**
     * The #ClutterPath used to constrain the position of an actor.
     */
    path?: Path
}
class PathConstraint {
    /* Properties of Clutter-1.0.Clutter.PathConstraint */
    /**
     * The offset along the #ClutterPathConstraint:path, between -1.0 and 2.0.
     */
    offset: number
    /**
     * The #ClutterPath used to constrain the position of an actor.
     */
    path: Path
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.PathConstraint */
    /**
     * Retrieves the offset along the #ClutterPath used by `constraint`.
     */
    getOffset(): number
    /**
     * Retrieves a pointer to the #ClutterPath used by `constraint`.
     */
    getPath(): Path
    /**
     * Sets the offset along the #ClutterPath used by `constraint`.
     */
    setOffset(offset: number): void
    /**
     * Sets the `path` to be followed by the #ClutterPathConstraint.
     * 
     * The `constraint` will take ownership of the #ClutterPath passed to this
     * function.
     */
    setPath(path?: Path | null): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.PathConstraint */
    /**
     * The ::node-reached signal is emitted each time a
     * #ClutterPathConstraint:offset value results in the actor
     * passing a #ClutterPathNode
     */
    connect(sigName: "node-reached", callback: ((actor: Actor, index: number) => void)): number
    on(sigName: "node-reached", callback: (actor: Actor, index: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "node-reached", callback: (actor: Actor, index: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "node-reached", callback: (actor: Actor, index: number) => void): NodeJS.EventEmitter
    emit(sigName: "node-reached", actor: Actor, index: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::path", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: PathConstraint_ConstructProps)
    _init (config?: PathConstraint_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(path: Path | null, offset: number): PathConstraint
    static $gtype: GObject.Type
}
class PipelineNode {
    /* Methods of Clutter-1.0.Clutter.PaintNode */
    /**
     * Adds `child` to the list of children of `node`.
     * 
     * This function will acquire a reference on `child`.
     */
    addChild(child: PaintNode): void
    /**
     * Adds a rectangle region to the `node,` as described by the
     * passed `rect`.
     */
    addRectangle(rect: ActorBox): void
    /**
     * Adds a rectangle region to the `node,` with texture coordinates.
     */
    addTextureRectangle(rect: ActorBox, x1: number, y1: number, x2: number, y2: number): void
    /**
     * Acquires a reference on `node`.
     */
    ref(): PaintNode
    /**
     * Sets a user-readable `name` for `node`.
     * 
     * The `name` will be used for debugging purposes.
     * 
     * The `node` will copy the passed string.
     */
    setName(name: string): void
    /**
     * Releases a reference on `node`.
     */
    unref(): void
    static name: string
}
interface PropertyTransition_ConstructProps extends Transition_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.PropertyTransition */
    /**
     * The name of the property of a #ClutterAnimatable to animate.
     */
    propertyName?: string
}
class PropertyTransition {
    /* Properties of Clutter-1.0.Clutter.PropertyTransition */
    /**
     * The name of the property of a #ClutterAnimatable to animate.
     */
    propertyName: string
    /* Properties of Clutter-1.0.Clutter.Transition */
    /**
     * The #ClutterAnimatable instance currently being animated.
     */
    animatable: Animatable
    /**
     * The #ClutterInterval used to describe the initial and final states
     * of the transition.
     */
    interval: Interval
    /**
     * Whether the #ClutterTransition should be automatically detached
     * from the #ClutterTransition:animatable instance whenever the
     * #ClutterTimeline::stopped signal is emitted.
     * 
     * The #ClutterTransition:remove-on-complete property takes into
     * account the value of the #ClutterTimeline:repeat-count property,
     * and it only detaches the transition if the transition is not
     * repeating.
     */
    removeOnComplete: boolean
    /* Properties of Clutter-1.0.Clutter.Timeline */
    /**
     * If the direction of the timeline should be automatically reversed
     * when reaching the end.
     */
    autoReverse: boolean
    /**
     * A delay, in milliseconds, that should be observed by the
     * timeline before actually starting.
     */
    delay: number
    /**
     * The direction of the timeline, either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    direction: TimelineDirection
    /**
     * Duration of the timeline in milliseconds, depending on the
     * ClutterTimeline:fps value.
     */
    duration: number
    /**
     * Whether the timeline should automatically rewind and restart.
     * 
     * As a side effect, setting this property to %TRUE will set the
     * #ClutterTimeline:repeat-count property to -1, while setting this
     * property to %FALSE will set the #ClutterTimeline:repeat-count
     * property to 0.
     */
    loop: boolean
    /**
     * Controls the way a #ClutterTimeline computes the normalized progress.
     */
    progressMode: AnimationMode
    /**
     * Defines how many times the timeline should repeat.
     * 
     * If the repeat count is 0, the timeline does not repeat.
     * 
     * If the repeat count is set to -1, the timeline will repeat until it is
     * stopped.
     */
    repeatCount: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.PropertyTransition */
    /**
     * Retrieves the value of the #ClutterPropertyTransition:property-name
     * property.
     */
    getPropertyName(): string
    /**
     * Sets the #ClutterPropertyTransition:property-name property of `transition`.
     */
    setPropertyName(propertyName?: string | null): void
    /* Methods of Clutter-1.0.Clutter.Transition */
    /**
     * Retrieves the #ClutterAnimatable set using clutter_transition_set_animatable().
     */
    getAnimatable(): Animatable
    /**
     * Retrieves the interval set using clutter_transition_set_interval()
     */
    getInterval(): Interval
    /**
     * Retrieves the value of the #ClutterTransition:remove-on-complete property.
     */
    getRemoveOnComplete(): boolean
    /**
     * Sets the #ClutterTransition:animatable property.
     * 
     * The `transition` will acquire a reference to the `animatable` instance,
     * and will call the #ClutterTransitionClass.attached() virtual function.
     * 
     * If an existing #ClutterAnimatable is attached to `transition,` the
     * reference will be released, and the #ClutterTransitionClass.detached()
     * virtual function will be called.
     */
    setAnimatable(animatable?: Animatable | null): void
    /**
     * Sets the initial value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setFrom(value: any): void
    /**
     * Sets the #ClutterTransition:interval property using `interval`.
     * 
     * The `transition` will acquire a reference on the `interval,` sinking
     * the floating flag on it if necessary.
     */
    setInterval(interval?: Interval | null): void
    /**
     * Sets whether `transition` should be detached from the #ClutterAnimatable
     * set using clutter_transition_set_animatable() when the
     * #ClutterTimeline::completed signal is emitted.
     */
    setRemoveOnComplete(removeComplete: boolean): void
    /**
     * Sets the final value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setTo(value: any): void
    /* Methods of Clutter-1.0.Clutter.Timeline */
    /**
     * Adds a named marker that will be hit when the timeline has reached
     * the specified `progress`.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `progress` of its duration,
     * if will emit a ::marker-reached signal for each marker attached to
     * that particular point.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker_at_time()
     */
    addMarker(markerName: string, progress: number): void
    /**
     * Adds a named marker that will be hit when the timeline has been
     * running for `msecs` milliseconds.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `msecs,` it will emit
     * a ::marker-reached signal for each marker attached to that position.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker()
     */
    addMarkerAtTime(markerName: string, msecs: number): void
    /**
     * Advance timeline to the requested point. The point is given as a
     * time in milliseconds since the timeline started.
     * 
     * The `timeline` will not emit the #ClutterTimeline::new-frame
     * signal for the given time. The first ::new-frame signal after the call to
     * clutter_timeline_advance() will be emit the skipped markers.
     */
    advance(msecs: number): void
    /**
     * Advances `timeline` to the time of the given `marker_name`.
     * 
     * Like clutter_timeline_advance(), this function will not
     * emit the #ClutterTimeline::new-frame for the time where `marker_name`
     * is set, nor it will emit #ClutterTimeline::marker-reached for
     * `marker_name`.
     */
    advanceToMarker(markerName: string): void
    /**
     * Create a new #ClutterTimeline instance which has property values
     * matching that of supplied timeline. The cloned timeline will not
     * be started and will not be positioned to the current position of
     * the original `timeline:` you will have to start it with
     * clutter_timeline_start().
     * 
     * The only cloned properties are:
     * 
     *  - #ClutterTimeline:duration
     *  - #ClutterTimeline:loop
     *  - #ClutterTimeline:delay
     *  - #ClutterTimeline:direction
     */
    clone(): Timeline
    /**
     * Retrieves the value set by clutter_timeline_set_auto_reverse().
     */
    getAutoReverse(): boolean
    /**
     * Retrieves the control points for the cubic bezier progress mode.
     */
    getCubicBezierProgress(): [ /* returnType */ boolean, /* c1 */ Point, /* c2 */ Point ]
    /**
     * Retrieves the current repeat for a timeline.
     * 
     * Repeats start at 0.
     */
    getCurrentRepeat(): number
    /**
     * Retrieves the delay set using clutter_timeline_set_delay().
     */
    getDelay(): number
    /**
     * Retrieves the amount of time elapsed since the last
     * ClutterTimeline::new-frame signal.
     * 
     * This function is only useful inside handlers for the ::new-frame
     * signal, and its behaviour is undefined if the timeline is not
     * playing.
     */
    getDelta(): number
    /**
     * Retrieves the direction of the timeline set with
     * clutter_timeline_set_direction().
     */
    getDirection(): TimelineDirection
    /**
     * Retrieves the duration of a #ClutterTimeline in milliseconds.
     * See clutter_timeline_set_duration().
     */
    getDuration(): number
    /**
     * Retrieves the full duration of the `timeline,` taking into account the
     * current value of the #ClutterTimeline:repeat-count property.
     * 
     * If the #ClutterTimeline:repeat-count property is set to -1, this function
     * will return %G_MAXINT64.
     * 
     * The returned value is to be considered a hint, and it's only valid
     * as long as the `timeline` hasn't been changed.
     */
    getDurationHint(): number
    /**
     * Request the current time position of the timeline.
     */
    getElapsedTime(): number
    /**
     * Gets whether `timeline` is looping
     */
    getLoop(): boolean
    /**
     * The position of the timeline in a normalized [-1, 2] interval.
     * 
     * The return value of this function is determined by the progress
     * mode set using clutter_timeline_set_progress_mode(), or by the
     * progress function set using clutter_timeline_set_progress_func().
     */
    getProgress(): number
    /**
     * Retrieves the progress mode set using clutter_timeline_set_progress_mode()
     * or clutter_timeline_set_progress_func().
     */
    getProgressMode(): AnimationMode
    /**
     * Retrieves the number set using clutter_timeline_set_repeat_count().
     */
    getRepeatCount(): number
    /**
     * Retrieves the parameters of the step progress mode used by `timeline`.
     */
    getStepProgress(): [ /* returnType */ boolean, /* nSteps */ number, /* stepMode */ StepMode ]
    /**
     * Checks whether `timeline` has a marker set with the given name.
     */
    hasMarker(markerName: string): boolean
    /**
     * Queries state of a #ClutterTimeline.
     */
    isPlaying(): boolean
    /**
     * Retrieves the list of markers at time `msecs`. If `msecs` is a
     * negative integer, all the markers attached to `timeline` will be
     * returned.
     */
    listMarkers(msecs: number): string[]
    /**
     * Pauses the #ClutterTimeline on current frame
     */
    pause(): void
    /**
     * Removes `marker_name,` if found, from `timeline`.
     */
    removeMarker(markerName: string): void
    /**
     * Rewinds #ClutterTimeline to the first frame if its direction is
     * %CLUTTER_TIMELINE_FORWARD and the last frame if it is
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    rewind(): void
    /**
     * Sets whether `timeline` should reverse the direction after the
     * emission of the #ClutterTimeline::completed signal.
     * 
     * Setting the #ClutterTimeline:auto-reverse property to %TRUE is the
     * equivalent of connecting a callback to the #ClutterTimeline::completed
     * signal and changing the direction of the timeline from that callback;
     * for instance, this code:
     * 
     * |[
     * static void
     * reverse_timeline (ClutterTimeline *timeline)
     * {
     *   ClutterTimelineDirection dir = clutter_timeline_get_direction (timeline);
     * 
     *   if (dir == CLUTTER_TIMELINE_FORWARD)
     *     dir = CLUTTER_TIMELINE_BACKWARD;
     *   else
     *     dir = CLUTTER_TIMELINE_FORWARD;
     * 
     *   clutter_timeline_set_direction (timeline, dir);
     * }
     * ...
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   g_signal_connect (timeline, "completed",
     *                     G_CALLBACK (reverse_timeline),
     *                     NULL);
     * ```
     * 
     * 
     * can be effectively replaced by:
     * 
     * |[
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   clutter_timeline_set_auto_reverse (timeline);
     * ```
     * 
     */
    setAutoReverse(reverse: boolean): void
    /**
     * Sets the #ClutterTimeline:progress-mode of `timeline`
     * to %CLUTTER_CUBIC_BEZIER, and sets the two control
     * points for the cubic bezier.
     * 
     * The cubic bezier curve is between (0, 0) and (1, 1). The X coordinate
     * of the two control points must be in the [ 0, 1 ] range, while the
     * Y coordinate of the two control points can exceed this range.
     */
    setCubicBezierProgress(c1: Point, c2: Point): void
    /**
     * Sets the delay, in milliseconds, before `timeline` should start.
     */
    setDelay(msecs: number): void
    /**
     * Sets the direction of `timeline,` either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    setDirection(direction: TimelineDirection): void
    /**
     * Sets the duration of the timeline, in milliseconds. The speed
     * of the timeline depends on the ClutterTimeline:fps setting.
     */
    setDuration(msecs: number): void
    /**
     * Sets whether `timeline` should loop.
     * 
     * This function is equivalent to calling clutter_timeline_set_repeat_count()
     * with -1 if `loop` is %TRUE, and with 0 if `loop` is %FALSE.
     */
    setLoop(loop: boolean): void
    /**
     * Sets a custom progress function for `timeline`. The progress function will
     * be called by clutter_timeline_get_progress() and will be used to compute
     * the progress value based on the elapsed time and the total duration of the
     * timeline.
     * 
     * If `func` is not %NULL, the #ClutterTimeline:progress-mode property will
     * be set to %CLUTTER_CUSTOM_MODE.
     * 
     * If `func` is %NULL, any previously set progress function will be unset, and
     * the #ClutterTimeline:progress-mode property will be set to %CLUTTER_LINEAR.
     */
    setProgressFunc(func: TimelineProgressFunc | null): void
    /**
     * Sets the progress function using a value from the #ClutterAnimationMode
     * enumeration. The `mode` cannot be %CLUTTER_CUSTOM_MODE or bigger than
     * %CLUTTER_ANIMATION_LAST.
     */
    setProgressMode(mode: AnimationMode): void
    /**
     * Sets the number of times the `timeline` should repeat.
     * 
     * If `count` is 0, the timeline never repeats.
     * 
     * If `count` is -1, the timeline will always repeat until
     * it's stopped.
     */
    setRepeatCount(count: number): void
    /**
     * Sets the #ClutterTimeline:progress-mode of the `timeline` to %CLUTTER_STEPS
     * and provides the parameters of the step function.
     */
    setStepProgress(nSteps: number, stepMode: StepMode): void
    /**
     * Advance timeline by the requested time in milliseconds
     */
    skip(msecs: number): void
    /**
     * Starts the #ClutterTimeline playing.
     */
    start(): void
    /**
     * Stops the #ClutterTimeline and moves to frame 0
     */
    stop(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Timeline */
    /**
     * The #ClutterTimeline::completed signal is emitted when the timeline's
     * elapsed time reaches the value of the #ClutterTimeline:duration
     * property.
     * 
     * This signal will be emitted even if the #ClutterTimeline is set to be
     * repeating.
     * 
     * If you want to get notification on whether the #ClutterTimeline has
     * been stopped or has finished its run, including its eventual repeats,
     * you should use the #ClutterTimeline::stopped signal instead.
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /**
     * The ::marker-reached signal is emitted each time a timeline
     * reaches a marker set with
     * clutter_timeline_add_marker_at_time(). This signal is detailed
     * with the name of the marker as well, so it is possible to connect
     * a callback to the ::marker-reached signal for a specific marker
     * with:
     * 
     * <informalexample><programlisting>
     *   clutter_timeline_add_marker_at_time (timeline, "foo", 500);
     *   clutter_timeline_add_marker_at_time (timeline, "bar", 750);
     * 
     *   g_signal_connect (timeline, "marker-reached",
     *                     G_CALLBACK (each_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::foo",
     *                     G_CALLBACK (foo_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::bar",
     *                     G_CALLBACK (bar_marker_reached), NULL);
     * </programlisting></informalexample>
     * 
     * In the example, the first callback will be invoked for both
     * the "foo" and "bar" marker, while the second and third callbacks
     * will be invoked for the "foo" or "bar" markers, respectively.
     */
    connect(sigName: "marker-reached", callback: ((markerName: string, msecs: number) => void)): number
    on(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "marker-reached", markerName: string, msecs: number): void
    /**
     * The ::new-frame signal is emitted for each timeline running
     * timeline before a new frame is drawn to give animations a chance
     * to update the scene.
     */
    connect(sigName: "new-frame", callback: ((msecs: number) => void)): number
    on(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-frame", callback: (msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "new-frame", msecs: number): void
    /**
     * The ::paused signal is emitted when clutter_timeline_pause() is invoked.
     */
    connect(sigName: "paused", callback: (() => void)): number
    on(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paused", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paused"): void
    /**
     * The ::started signal is emitted when the timeline starts its run.
     * This might be as soon as clutter_timeline_start() is invoked or
     * after the delay set in the ClutterTimeline:delay property has
     * expired.
     */
    connect(sigName: "started", callback: (() => void)): number
    on(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "started", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "started"): void
    /**
     * The #ClutterTimeline::stopped signal is emitted when the timeline
     * has been stopped, either because clutter_timeline_stop() has been
     * called, or because it has been exhausted.
     * 
     * This is different from the #ClutterTimeline::completed signal,
     * which gets emitted after every repeat finishes.
     * 
     * If the #ClutterTimeline has is marked as infinitely repeating,
     * this signal will never be emitted.
     */
    connect(sigName: "stopped", callback: ((isFinished: boolean) => void)): number
    on(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "stopped", callback: (isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "stopped", isFinished: boolean): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::property-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::property-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::property-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::property-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::property-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: PropertyTransition_ConstructProps)
    _init (config?: PropertyTransition_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(propertyName?: string | null): PropertyTransition
    /* Function overloads */
    static new(msecs: number): PropertyTransition
    static $gtype: GObject.Type
}
interface Rectangle_ConstructProps extends Actor_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Rectangle */
    /**
     * The color of the border of the rectangle.
     */
    borderColor?: Color
    /**
     * The width of the border of the rectangle, in pixels.
     */
    borderWidth?: number
    /**
     * The color of the rectangle.
     */
    color?: Color
    /**
     * Whether the #ClutterRectangle should be displayed with a border.
     */
    hasBorder?: boolean
}
class Rectangle {
    /* Properties of Clutter-1.0.Clutter.Rectangle */
    /**
     * The color of the border of the rectangle.
     */
    borderColor: Color
    /**
     * The width of the border of the rectangle, in pixels.
     */
    borderWidth: number
    /**
     * The color of the rectangle.
     */
    color: Color
    /**
     * Whether the #ClutterRectangle should be displayed with a border.
     */
    hasBorder: boolean
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Rectangle */
    /**
     * Gets the color of the border used by `rectangle` and places
     * it into `color`.
     */
    getBorderColor(): /* color */ Color
    /**
     * Gets the width (in pixels) of the border used by `rectangle`
     */
    getBorderWidth(): number
    /**
     * Retrieves the color of `rectangle`.
     */
    getColor(): /* color */ Color
    /**
     * Sets the color of the border used by `rectangle` using `color`
     */
    setBorderColor(color: Color): void
    /**
     * Sets the width (in pixel) of the border used by `rectangle`.
     * A `width` of 0 will unset the border.
     */
    setBorderWidth(width: number): void
    /**
     * Sets the color of `rectangle`.
     */
    setColor(color: Color): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::border-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::border-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::border-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::border-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::border-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::border-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::border-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::border-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::border-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::border-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-border", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-border", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-border", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-border", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-border", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Rectangle_ConstructProps)
    _init (config?: Rectangle_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Rectangle
    static newWithColor(color: Color): Rectangle
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
interface RotateAction_ConstructProps extends GestureAction_ConstructProps {
}
class RotateAction {
    /* Properties of Clutter-1.0.Clutter.GestureAction */
    /**
     * Number of touch points to trigger a gesture action.
     */
    nTouchPoints: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.GestureAction */
    /**
     * Cancel a #ClutterGestureAction before it begins
     */
    cancel(): void
    /**
     * Retrieves the #ClutterInputDevice of a touch point.
     */
    getDevice(point: number): InputDevice
    /**
     * Retrieves a reference to the last #ClutterEvent for a touch point. Call
     * clutter_event_copy() if you need to store the reference somewhere.
     */
    getLastEvent(point: number): Event
    /**
     * Retrieves the coordinates, in stage space, of the latest motion
     * event during the dragging.
     */
    getMotionCoords(point: number): [ /* motionX */ number | null, /* motionY */ number | null ]
    /**
     * Retrieves the incremental delta since the last motion event
     * during the dragging.
     */
    getMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the number of points currently active.
     */
    getNCurrentPoints(): number
    /**
     * Retrieves the number of requested points to trigger the gesture.
     */
    getNTouchPoints(): number
    /**
     * Retrieves the coordinates, in stage space, of the press event
     * that started the dragging for a specific touch point.
     */
    getPressCoords(point: number): [ /* pressX */ number | null, /* pressY */ number | null ]
    /**
     * Retrieves the coordinates, in stage space, where the touch point was
     * last released.
     */
    getReleaseCoords(point: number): [ /* releaseX */ number | null, /* releaseY */ number | null ]
    /**
     * Retrieves the #ClutterEventSequence of a touch point.
     */
    getSequence(point: number): EventSequence
    /**
     * Retrieves the threshold trigger distance of the gesture `action,`
     * as set using clutter_gesture_action_set_threshold_trigger_distance().
     */
    getThresholdTriggerDistance(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEdge(): GestureTriggerEdge
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEgde(): GestureTriggerEdge
    /**
     * Retrieves the velocity, in stage pixels per millisecond, of the
     * latest motion event during the dragging.
     */
    getVelocity(point: number): [ /* returnType */ number, /* velocityX */ number | null, /* velocityY */ number | null ]
    /**
     * Sets the number of points needed to trigger the gesture.
     */
    setNTouchPoints(nbPoints: number): void
    /**
     * Sets the threshold trigger distance for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerDistance(x: number, y: number): void
    /**
     * Sets the edge trigger for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerEdge(edge: GestureTriggerEdge): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.RotateAction */
    /**
     * The ::rotate signal is emitted when a rotate gesture is
     * recognized on the attached actor and when the gesture is
     * cancelled (in this case with an angle value of 0).
     */
    connect(sigName: "rotate", callback: ((actor: Actor, angle: number) => boolean)): number
    on(sigName: "rotate", callback: (actor: Actor, angle: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "rotate", callback: (actor: Actor, angle: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "rotate", callback: (actor: Actor, angle: number) => void): NodeJS.EventEmitter
    emit(sigName: "rotate", actor: Actor, angle: number): void
    /* Signals of Clutter-1.0.Clutter.GestureAction */
    /**
     * The ::gesture_begin signal is emitted when the #ClutterActor to which
     * a #ClutterGestureAction has been applied starts receiving a gesture.
     */
    connect(sigName: "gesture-begin", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-begin", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-begin", actor: Actor): void
    /**
     * The ::gesture-cancel signal is emitted when the ongoing gesture gets
     * cancelled from the #ClutterGestureAction::gesture-progress signal handler.
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-cancel", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-cancel", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-cancel", actor: Actor): void
    /**
     * The ::gesture-end signal is emitted at the end of the gesture gesture,
     * when the pointer's button is released
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-end", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-end", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-end", actor: Actor): void
    /**
     * The ::gesture-progress signal is emitted for each motion event after
     * the #ClutterGestureAction::gesture-begin signal has been emitted.
     */
    connect(sigName: "gesture-progress", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-progress", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-progress", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: RotateAction_ConstructProps)
    _init (config?: RotateAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): RotateAction
    static $gtype: GObject.Type
}
interface Score_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Score */
    /**
     * Whether the #ClutterScore should restart once finished.
     */
    loop?: boolean
}
class Score {
    /* Properties of Clutter-1.0.Clutter.Score */
    /**
     * Whether the #ClutterScore should restart once finished.
     */
    loop: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Score */
    /**
     * Appends a timeline to another one existing in the score; the newly
     * appended timeline will be started when `parent` is complete.
     * 
     * If `parent` is %NULL, the new #ClutterTimeline will be started when
     * clutter_score_start() is called.
     * 
     * #ClutterScore will take a reference on `timeline`.
     */
    append(parent: Timeline | null, timeline: Timeline): number
    /**
     * Appends `timeline` at the given `marker_name` on the `parent`
     * #ClutterTimeline.
     * 
     * If you want to append `timeline` at the end of `parent,` use
     * clutter_score_append().
     * 
     * The #ClutterScore will take a reference on `timeline`.
     */
    appendAtMarker(parent: Timeline, markerName: string, timeline: Timeline): number
    /**
     * Gets whether `score` is looping
     */
    getLoop(): boolean
    /**
     * Retrieves the #ClutterTimeline for `id_` inside `score`.
     */
    getTimeline(id: number): Timeline
    /**
     * Query state of a #ClutterScore instance.
     */
    isPlaying(): boolean
    /**
     * Retrieves a list of all the #ClutterTimelines managed by `score`.
     */
    listTimelines(): Timeline[]
    /**
     * Pauses a playing score `score`.
     */
    pause(): void
    /**
     * Removes the #ClutterTimeline with the given id inside `score`. If
     * the timeline has other timelines attached to it, those are removed
     * as well.
     */
    remove(id: number): void
    /**
     * Removes all the timelines inside `score`.
     */
    removeAll(): void
    /**
     * Rewinds a #ClutterScore to its initial state.
     */
    rewind(): void
    /**
     * Sets whether `score` should loop. A looping #ClutterScore will start
     * from its initial state after the ::complete signal has been fired.
     */
    setLoop(loop: boolean): void
    /**
     * Starts the score.
     */
    start(): void
    /**
     * Stops and rewinds a playing #ClutterScore instance.
     */
    stop(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.Score */
    /**
     * The ::completed signal is emitted each time a #ClutterScore terminates.
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /**
     * The ::paused signal is emitted each time a #ClutterScore
     * is paused.
     */
    connect(sigName: "paused", callback: (() => void)): number
    on(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paused", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paused"): void
    /**
     * The ::started signal is emitted each time a #ClutterScore starts playing.
     */
    connect(sigName: "started", callback: (() => void)): number
    on(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "started", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "started"): void
    /**
     * The ::timeline-completed signal is emitted each time a timeline
     * inside a #ClutterScore terminates.
     */
    connect(sigName: "timeline-completed", callback: ((timeline: Timeline) => void)): number
    on(sigName: "timeline-completed", callback: (timeline: Timeline) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "timeline-completed", callback: (timeline: Timeline) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "timeline-completed", callback: (timeline: Timeline) => void): NodeJS.EventEmitter
    emit(sigName: "timeline-completed", timeline: Timeline): void
    /**
     * The ::timeline-started signal is emitted each time a new timeline
     * inside a #ClutterScore starts playing.
     */
    connect(sigName: "timeline-started", callback: ((timeline: Timeline) => void)): number
    on(sigName: "timeline-started", callback: (timeline: Timeline) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "timeline-started", callback: (timeline: Timeline) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "timeline-started", callback: (timeline: Timeline) => void): NodeJS.EventEmitter
    emit(sigName: "timeline-started", timeline: Timeline): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Score_ConstructProps)
    _init (config?: Score_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Score
    static $gtype: GObject.Type
}
interface Script_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Script */
    /**
     * The translation domain, used to localize strings marked as translatable
     * inside a UI definition.
     * 
     * If #ClutterScript:translation-domain is set to %NULL, #ClutterScript
     * will use gettext(), otherwise g_dgettext() will be used.
     */
    translationDomain?: string
}
class Script {
    /* Properties of Clutter-1.0.Clutter.Script */
    /**
     * The path of the currently parsed file. If #ClutterScript:filename-set
     * is %FALSE then the value of this property is undefined.
     */
    readonly filename: string
    /**
     * Whether the #ClutterScript:filename property is set. If this property
     * is %TRUE then the currently parsed data comes from a file, and the
     * file name is stored inside the #ClutterScript:filename property.
     */
    readonly filenameSet: boolean
    /**
     * The translation domain, used to localize strings marked as translatable
     * inside a UI definition.
     * 
     * If #ClutterScript:translation-domain is set to %NULL, #ClutterScript
     * will use gettext(), otherwise g_dgettext() will be used.
     */
    translationDomain: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Script */
    /**
     * Adds `paths` to the list of search paths held by `script`.
     * 
     * The search paths are used by clutter_script_lookup_filename(), which
     * can be used to define search paths for the textures source file name
     * or other custom, file-based properties.
     */
    addSearchPaths(paths: string[]): void
    /**
     * Associates a #ClutterState to the #ClutterScript instance using the given
     * name.
     * 
     * The #ClutterScript instance will use `state` to resolve target states when
     * connecting signal handlers.
     * 
     * The #ClutterScript instance will take a reference on the #ClutterState
     * passed to this function.
     */
    addStates(name: string | null, state: State): void
    /**
     * Connects all the signals defined into a UI definition file to their
     * handlers.
     * 
     * This method invokes clutter_script_connect_signals_full() internally
     * and uses  #GModule's introspective features (by opening the current
     * module's scope) to look at the application's symbol table.
     * 
     * Note that this function will not work if #GModule is not supported by
     * the platform Clutter is running on.
     */
    connectSignals(userData?: object | null): void
    /**
     * Connects all the signals defined into a UI definition file to their
     * handlers.
     * 
     * This function allows to control how the signal handlers are
     * going to be connected to their respective signals. It is meant
     * primarily for language bindings to allow resolving the function
     * names using the native API, but it can also be used on platforms
     * that do not support GModule.
     * 
     * Applications should use clutter_script_connect_signals().
     */
    connectSignalsFull(func: ScriptConnectFunc): void
    /**
     * Ensure that every object defined inside `script` is correctly
     * constructed. You should rarely need to use this function.
     */
    ensureObjects(): void
    /**
     * Retrieves the object bound to `name`. This function does not increment
     * the reference count of the returned object.
     */
    getObject(name: string): GObject.Object
    /**
     * Retrieves the #ClutterState for the given `state_name`.
     * 
     * If `name` is %NULL, this function will return the default
     * #ClutterState instance.
     */
    getStates(name?: string | null): State
    /**
     * Retrieves the translation domain set using
     * clutter_script_set_translation_domain().
     */
    getTranslationDomain(): string
    /**
     * Looks up a type by name, using the virtual function that
     * #ClutterScript has for that purpose. This function should
     * rarely be used.
     */
    getTypeFromName(typeName: string): GObject.Type
    /**
     * Retrieves all the objects created by `script`.
     * 
     * Note: this function does not increment the reference count of the
     * objects it returns.
     */
    listObjects(): GObject.Object[]
    /**
     * Loads the definitions from `data` into `script` and merges with
     * the currently loaded ones, if any.
     */
    loadFromData(data: string, length: number): number
    /**
     * Loads the definitions from `filename` into `script` and merges with
     * the currently loaded ones, if any.
     */
    loadFromFile(filename: string): number
    /**
     * Loads the definitions from a resource file into `script` and merges with
     * the currently loaded ones, if any.
     */
    loadFromResource(resourcePath: string): number
    /**
     * Looks up `filename` inside the search paths of `script`. If `filename`
     * is found, its full path will be returned .
     */
    lookupFilename(filename: string): string
    /**
     * Sets the translation domain for `script`.
     */
    setTranslationDomain(domain?: string | null): void
    /**
     * Unmerges the objects identified by `merge_id`.
     */
    unmergeObjects(mergeId: number): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filename-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filename-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filename-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filename-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-domain", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-domain", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Script_ConstructProps)
    _init (config?: Script_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Script
    static $gtype: GObject.Type
}
interface ScrollActor_ConstructProps extends Actor_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ScrollActor */
    /**
     * The scrollin direction.
     */
    scrollMode?: ScrollMode
}
class ScrollActor {
    /* Properties of Clutter-1.0.Clutter.ScrollActor */
    /**
     * The scrollin direction.
     */
    scrollMode: ScrollMode
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ScrollActor */
    /**
     * Retrieves the #ClutterScrollActor:scroll-mode property
     */
    getScrollMode(): ScrollMode
    /**
     * Scrolls the contents of `actor` so that `point` is the new origin
     * of the visible area.
     * 
     * The coordinates of `point` must be relative to the `actor`.
     * 
     * This function will use the currently set easing state of the `actor`
     * to transition from the current scroll origin to the new one.
     */
    scrollToPoint(point: Point): void
    /**
     * Scrolls `actor` so that `rect` is in the visible portion.
     */
    scrollToRect(rect: Rect): void
    /**
     * Sets the #ClutterScrollActor:scroll-mode property.
     */
    setScrollMode(mode: ScrollMode): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::scroll-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scroll-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scroll-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scroll-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scroll-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ScrollActor_ConstructProps)
    _init (config?: ScrollActor_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): ScrollActor
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
interface Settings_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Settings */
    /**
     * A back pointer to the #ClutterBackend
     */
    backend?: Backend
    /**
     * The default distance that the cursor of a pointer device
     * should travel before a drag operation should start.
     */
    dndDragThreshold?: number
    /**
     * The maximum distance, in pixels, between button-press events that
     * determines whether or not to increase the click count by 1.
     */
    doubleClickDistance?: number
    /**
     * The time, in milliseconds, that should elapse between button-press
     * events in order to increase the click count by 1.
     */
    doubleClickTime?: number
    /**
     * Whether or not to use antialiasing when rendering text; a value
     * of 1 enables it unconditionally; a value of 0 disables it
     * unconditionally; and -1 will use the system's default.
     */
    fontAntialias?: number
    /**
     * The DPI used when rendering text, as a value of 1024 * dots/inch.
     * 
     * If set to -1, the system's default will be used instead
     */
    fontDpi?: number
    /**
     * The style of the hinting used when rendering text. Valid values
     * are:
     * 
     *   - hintnone
     *   - hintslight
     *   - hintmedium
     *   - hintfull
     */
    fontHintStyle?: string
    /**
     * Whether or not to use hinting when rendering text; a value of 1
     * unconditionally enables it; a value of 0 unconditionally disables
     * it; and a value of -1 will use the system's default.
     */
    fontHinting?: number
    /**
     * The default font name that should be used by text actors, as
     * a string that can be passed to pango_font_description_from_string().
     */
    fontName?: string
    /**
     * The type of sub-pixel antialiasing used when rendering text. Valid
     * values are:
     * 
     *   - none
     *   - rgb
     *   - bgr
     *   - vrgb
     *   - vbgr
     */
    fontSubpixelOrder?: string
    fontconfigTimestamp?: number
    /**
     * Sets the minimum duration for a press to be recognized as a long press
     * gesture. The duration is expressed in milliseconds.
     * 
     * See also #ClutterClickAction:long-press-duration.
     */
    longPressDuration?: number
    passwordHintTime?: number
    unscaledFontDpi?: number
    windowScalingFactor?: number
}
class Settings {
    /* Properties of Clutter-1.0.Clutter.Settings */
    /**
     * The default distance that the cursor of a pointer device
     * should travel before a drag operation should start.
     */
    dndDragThreshold: number
    /**
     * The maximum distance, in pixels, between button-press events that
     * determines whether or not to increase the click count by 1.
     */
    doubleClickDistance: number
    /**
     * The time, in milliseconds, that should elapse between button-press
     * events in order to increase the click count by 1.
     */
    doubleClickTime: number
    /**
     * Whether or not to use antialiasing when rendering text; a value
     * of 1 enables it unconditionally; a value of 0 disables it
     * unconditionally; and -1 will use the system's default.
     */
    fontAntialias: number
    /**
     * The DPI used when rendering text, as a value of 1024 * dots/inch.
     * 
     * If set to -1, the system's default will be used instead
     */
    fontDpi: number
    /**
     * The style of the hinting used when rendering text. Valid values
     * are:
     * 
     *   - hintnone
     *   - hintslight
     *   - hintmedium
     *   - hintfull
     */
    fontHintStyle: string
    /**
     * Whether or not to use hinting when rendering text; a value of 1
     * unconditionally enables it; a value of 0 unconditionally disables
     * it; and a value of -1 will use the system's default.
     */
    fontHinting: number
    /**
     * The default font name that should be used by text actors, as
     * a string that can be passed to pango_font_description_from_string().
     */
    fontName: string
    /**
     * The type of sub-pixel antialiasing used when rendering text. Valid
     * values are:
     * 
     *   - none
     *   - rgb
     *   - bgr
     *   - vrgb
     *   - vbgr
     */
    fontSubpixelOrder: string
    fontconfigTimestamp: number
    /**
     * Sets the minimum duration for a press to be recognized as a long press
     * gesture. The duration is expressed in milliseconds.
     * 
     * See also #ClutterClickAction:long-press-duration.
     */
    longPressDuration: number
    passwordHintTime: number
    unscaledFontDpi: number
    windowScalingFactor: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::dnd-drag-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dnd-drag-threshold", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::dnd-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::dnd-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::dnd-drag-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::double-click-distance", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::double-click-distance", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::double-click-distance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::double-click-distance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::double-click-distance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::double-click-time", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::double-click-time", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::double-click-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::double-click-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::double-click-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-antialias", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-antialias", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-antialias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-antialias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-antialias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-dpi", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-dpi", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-dpi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-dpi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-dpi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-hint-style", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-hint-style", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-hint-style", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-hint-style", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-hint-style", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-hinting", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-hinting", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-hinting", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-hinting", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-hinting", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-subpixel-order", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-subpixel-order", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-subpixel-order", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-subpixel-order", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-subpixel-order", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fontconfig-timestamp", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fontconfig-timestamp", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fontconfig-timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fontconfig-timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fontconfig-timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::long-press-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::long-press-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::long-press-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::long-press-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::long-press-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-hint-time", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-hint-time", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-hint-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-hint-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-hint-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::unscaled-font-dpi", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::unscaled-font-dpi", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::unscaled-font-dpi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::unscaled-font-dpi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::unscaled-font-dpi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::window-scaling-factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::window-scaling-factor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::window-scaling-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::window-scaling-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::window-scaling-factor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Settings_ConstructProps)
    _init (config?: Settings_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Retrieves the singleton instance of #ClutterSettings
     */
    static getDefault(): Settings
    static $gtype: GObject.Type
}
interface Shader_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Shader */
    /**
     * Whether the shader is currently used in the GL rendering pipeline.
     */
    enabled?: boolean
    /**
     * GLSL source code for the fragment shader part of the shader program.
     */
    fragmentSource?: string
    /**
     * GLSL source code for the vertex shader part of the shader
     * program, if any
     */
    vertexSource?: string
}
class Shader {
    /* Properties of Clutter-1.0.Clutter.Shader */
    /**
     * Whether the shader is compiled and linked, ready for use
     * in the GL context.
     */
    readonly compiled: boolean
    /**
     * Whether the shader is currently used in the GL rendering pipeline.
     */
    enabled: boolean
    /**
     * GLSL source code for the fragment shader part of the shader program.
     */
    fragmentSource: string
    /**
     * GLSL source code for the vertex shader part of the shader
     * program, if any
     */
    vertexSource: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Shader */
    /**
     * Compiles and links GLSL sources set for vertex and fragment shaders for
     * a #ClutterShader. If the compilation fails and a #GError return location is
     * provided the error will contain the errors from the compiler, if any.
     */
    compile(): boolean
    /**
     * Retrieves the underlying #CoglHandle for the fragment shader.
     */
    getCoglFragmentShader(): Cogl.Handle
    /**
     * Retrieves the underlying #CoglHandle for the shader program.
     */
    getCoglProgram(): Cogl.Handle
    /**
     * Retrieves the underlying #CoglHandle for the vertex shader.
     */
    getCoglVertexShader(): Cogl.Handle
    /**
     * Query the current GLSL fragment source set on `shader`.
     */
    getFragmentSource(): string
    /**
     * Checks whether `shader` is enabled.
     */
    getIsEnabled(): boolean
    /**
     * Query the current GLSL vertex source set on `shader`.
     */
    getVertexSource(): string
    /**
     * Checks whether `shader` is is currently compiled, linked and bound
     * to the GL context.
     */
    isCompiled(): boolean
    /**
     * Frees up any GL context resources held by the shader.
     */
    release(): void
    /**
     * Sets the GLSL source code to be used by a #ClutterShader for the fragment
     * program.
     */
    setFragmentSource(data: string, length: number): void
    /**
     * Enables a shader. This function will attempt to compile and link
     * the shader, if it isn't already.
     * 
     * When `enabled` is %FALSE the default state of the GL pipeline will be
     * used instead.
     */
    setIsEnabled(enabled: boolean): void
    /**
     * Sets a user configurable variable in the GLSL shader programs attached to
     * a #ClutterShader.
     */
    setUniform(name: string, value: any): void
    /**
     * Sets the GLSL source code to be used by a #ClutterShader for the vertex
     * program.
     */
    setVertexSource(data: string, length: number): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::compiled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::compiled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::compiled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::compiled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::compiled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fragment-source", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fragment-source", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fragment-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fragment-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fragment-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::vertex-source", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vertex-source", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::vertex-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::vertex-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::vertex-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Shader_ConstructProps)
    _init (config?: Shader_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Shader
    static $gtype: GObject.Type
}
interface ShaderEffect_ConstructProps extends OffscreenEffect_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ShaderEffect */
    /**
     * The type of shader that is used by the effect. This property
     * should be set by the constructor of #ClutterShaderEffect
     * sub-classes.
     */
    shaderType?: ShaderType
}
class ShaderEffect {
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ShaderEffect */
    /**
     * Retrieves a pointer to the program's handle
     */
    getProgram(): Cogl.Handle
    /**
     * Retrieves a pointer to the shader's handle
     */
    getShader(): Cogl.Handle
    /**
     * Sets the source of the GLSL shader used by `effect`
     * 
     * This function should only be called by implementations of
     * the #ClutterShaderEffect class, and not by application code.
     * 
     * This function can only be called once; subsequent calls will
     * yield no result.
     */
    setShaderSource(source: string): boolean
    /**
     * Sets `value` as the payload for the uniform `name` inside the shader
     * effect
     * 
     * The #GType of the `value` must be one of: %G_TYPE_INT, for a single
     * integer value; %G_TYPE_FLOAT, for a single floating point value;
     * %CLUTTER_TYPE_SHADER_INT, for an array of integer values;
     * %CLUTTER_TYPE_SHADER_FLOAT, for an array of floating point values;
     * and %CLUTTER_TYPE_SHADER_MATRIX, for a matrix of floating point
     * values. It also accepts %G_TYPE_DOUBLE for compatibility with other
     * languages than C.
     */
    setUniformValue(name: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.OffscreenEffect */
    /**
     * Calls the create_texture() virtual function of the `effect`
     */
    createTexture(width: number, height: number): Cogl.Handle
    /**
     * Retrieves the material used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned #CoglMaterial when painting. The
     * returned material might change between different frames.
     */
    getTarget(): Cogl.Material
    /**
     * Retrieves the origin and size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetRect(): [ /* returnType */ boolean, /* rect */ Rect ]
    /**
     * Retrieves the size of the offscreen buffer used by `effect` to
     * paint the actor to which it has been applied.
     * 
     * This function should only be called by #ClutterOffscreenEffect
     * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
     * virtual function.
     */
    getTargetSize(): [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    /**
     * Retrieves the texture used as a render target for the offscreen
     * buffer created by `effect`
     * 
     * You should only use the returned texture when painting. The texture
     * may change after ClutterEffect::pre_paint is called so the effect
     * implementation should update any references to the texture after
     * chaining-up to the parent's pre_paint implementation. This can be
     * used instead of clutter_offscreen_effect_get_target() when the
     * effect subclass wants to paint using its own material.
     */
    getTexture(): Cogl.Handle
    /**
     * Calls the paint_target() virtual function of the `effect`
     */
    paintTarget(): void
    /* Methods of Clutter-1.0.Clutter.Effect */
    /**
     * Queues a repaint of the effect. The effect can detect when the ‘paint’
     * method is called as a result of this function because it will not
     * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
     * effect is free to assume that the actor has not changed its
     * appearance since the last time it was painted so it doesn't need to
     * call clutter_actor_continue_paint() if it can draw a cached
     * image. This is mostly intended for effects that are using a
     * %CoglOffscreen to redirect the actor (such as
     * %ClutterOffscreenEffect). In that case the effect can save a bit of
     * rendering time by painting the cached texture without causing the
     * entire actor to be painted.
     * 
     * This function can be used by effects that have their own animatable
     * parameters. For example, an effect which adds a varying degree of a
     * red tint to an actor by redirecting it through a CoglOffscreen
     * might have a property to specify the level of tint. When this value
     * changes, the underlying actor doesn't need to be redrawn so the
     * effect can call clutter_effect_queue_repaint() to make sure the
     * effect is repainted.
     * 
     * Note however that modifying the position of the parent of an actor
     * may change the appearance of the actor because its transformation
     * matrix would change. In this case a redraw wouldn't be queued on
     * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
     * not be set. The effect can detect this case by keeping track of the
     * last modelview matrix that was used to render the actor and
     * veryifying that it remains the same in the next paint.
     * 
     * Any other effects that are layered on top of the passed in effect
     * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
     * anything queues a redraw on the actor without specifying an effect
     * or with an effect that is lower in the chain of effects than this
     * one then that will override this call. In that case this effect
     * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
     * flag set.
     */
    queueRepaint(): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ShaderEffect_ConstructProps)
    _init (config?: ShaderEffect_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(shaderType: ShaderType): ShaderEffect
    static $gtype: GObject.Type
}
class ShaderFloat {
    static name: string
}
class ShaderInt {
    static name: string
}
class ShaderMatrix {
    static name: string
}
interface SnapConstraint_ConstructProps extends Constraint_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.SnapConstraint */
    /**
     * The edge of the #ClutterActor that should be snapped
     */
    fromEdge?: SnapEdge
    /**
     * The offset, in pixels, between #ClutterSnapConstraint:from-edge
     * and #ClutterSnapConstraint:to-edge
     */
    offset?: number
    /**
     * The #ClutterActor used as the source for the constraint
     */
    source?: Actor
    /**
     * The edge of the #ClutterSnapConstraint:source that should be snapped
     */
    toEdge?: SnapEdge
}
class SnapConstraint {
    /* Properties of Clutter-1.0.Clutter.SnapConstraint */
    /**
     * The edge of the #ClutterActor that should be snapped
     */
    fromEdge: SnapEdge
    /**
     * The offset, in pixels, between #ClutterSnapConstraint:from-edge
     * and #ClutterSnapConstraint:to-edge
     */
    offset: number
    /**
     * The #ClutterActor used as the source for the constraint
     */
    source: Actor
    /**
     * The edge of the #ClutterSnapConstraint:source that should be snapped
     */
    toEdge: SnapEdge
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.SnapConstraint */
    /**
     * Retrieves the edges used by the `constraint`
     */
    getEdges(): [ /* fromEdge */ SnapEdge, /* toEdge */ SnapEdge ]
    /**
     * Retrieves the offset set using clutter_snap_constraint_set_offset()
     */
    getOffset(): number
    /**
     * Retrieves the #ClutterActor set using clutter_snap_constraint_set_source()
     */
    getSource(): Actor
    /**
     * Sets the edges to be used by the `constraint`
     * 
     * The `from_edge` is the edge on the #ClutterActor to which `constraint`
     * has been added. The `to_edge` is the edge of the #ClutterActor inside
     * the #ClutterSnapConstraint:source property.
     */
    setEdges(fromEdge: SnapEdge, toEdge: SnapEdge): void
    /**
     * Sets the offset to be applied to the constraint
     */
    setOffset(offset: number): void
    /**
     * Sets the source #ClutterActor for the constraint
     */
    setSource(source?: Actor | null): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::from-edge", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::from-edge", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::from-edge", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::from-edge", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::from-edge", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::to-edge", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::to-edge", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::to-edge", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::to-edge", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::to-edge", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SnapConstraint_ConstructProps)
    _init (config?: SnapConstraint_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(source: Actor | null, fromEdge: SnapEdge, toEdge: SnapEdge, offset: number): SnapConstraint
    static $gtype: GObject.Type
}
interface Stage_ConstructProps extends Group_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Stage */
    /**
     * Whether the #ClutterStage should accept key focus when shown.
     */
    acceptFocus?: boolean
    /**
     * The background color of the main stage.
     */
    color?: Color
    /**
     * Whether the mouse pointer should be visible
     */
    cursorVisible?: boolean
    /**
     * The settings for the GL "fog", used only if #ClutterStage:use-fog
     * is set to %TRUE
     */
    fog?: Fog
    /**
     * The #ClutterActor that will receive key events from the underlying
     * windowing system.
     * 
     * If %NULL, the #ClutterStage will receive the events.
     */
    keyFocus?: Actor
    /**
     * Whether or not the #ClutterStage should clear its contents
     * before each paint cycle.
     * 
     * See clutter_stage_set_no_clear_hint() for further information.
     */
    noClearHint?: boolean
    /**
     * Whether the stage should be rendered in an offscreen buffer.
     */
    offscreen?: boolean
    /**
     * The parameters used for the perspective projection from 3D
     * coordinates to 2D
     */
    perspective?: Perspective
    /**
     * The stage's title - usually displayed in stage windows title decorations.
     */
    title?: string
    /**
     * Whether the #ClutterStage should honour the alpha component of the
     * #ClutterStage:color property when painting. If Clutter is run under
     * a compositing manager this will result in the stage being blended
     * with the underlying window(s)
     */
    useAlpha?: boolean
    /**
     * Whether the stage should use a linear GL "fog" in creating the
     * depth-cueing effect, to enhance the perception of depth by fading
     * actors farther from the viewpoint.
     */
    useFog?: boolean
    /**
     * Whether the stage is resizable via user interaction.
     */
    userResizable?: boolean
}
class Stage {
    /* Properties of Clutter-1.0.Clutter.Stage */
    /**
     * Whether the #ClutterStage should accept key focus when shown.
     */
    acceptFocus: boolean
    /**
     * The background color of the main stage.
     */
    color: Color
    /**
     * Whether the mouse pointer should be visible
     */
    cursorVisible: boolean
    /**
     * The settings for the GL "fog", used only if #ClutterStage:use-fog
     * is set to %TRUE
     */
    fog: Fog
    readonly fullscreenSet: boolean
    /**
     * The #ClutterActor that will receive key events from the underlying
     * windowing system.
     * 
     * If %NULL, the #ClutterStage will receive the events.
     */
    keyFocus: Actor
    /**
     * Whether or not the #ClutterStage should clear its contents
     * before each paint cycle.
     * 
     * See clutter_stage_set_no_clear_hint() for further information.
     */
    noClearHint: boolean
    /**
     * Whether the stage should be rendered in an offscreen buffer.
     */
    offscreen: boolean
    /**
     * The parameters used for the perspective projection from 3D
     * coordinates to 2D
     */
    perspective: Perspective
    /**
     * The stage's title - usually displayed in stage windows title decorations.
     */
    title: string
    /**
     * Whether the #ClutterStage should honour the alpha component of the
     * #ClutterStage:color property when painting. If Clutter is run under
     * a compositing manager this will result in the stage being blended
     * with the underlying window(s)
     */
    useAlpha: boolean
    /**
     * Whether the stage should use a linear GL "fog" in creating the
     * depth-cueing effect, to enhance the perception of depth by fading
     * actors farther from the viewpoint.
     */
    useFog: boolean
    /**
     * Whether the stage is resizable via user interaction.
     */
    userResizable: boolean
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Stage */
    /**
     * This function essentially makes sure the right GL context is
     * current for the passed stage. It is not intended to
     * be used by applications.
     */
    ensureCurrent(): void
    /**
     * Ensures that `stage` is redrawn
     * 
     * This function should not be called by applications: it is
     * used when embedding a #ClutterStage into a toolkit with
     * another windowing system, like GTK+.
     */
    ensureRedraw(): void
    /**
     * Ensures that the GL viewport is updated with the current
     * stage window size.
     * 
     * This function will queue a redraw of `stage`.
     * 
     * This function should not be called by applications; it is used
     * when embedding a #ClutterStage into a toolkit with another
     * windowing system, like GTK+.
     */
    ensureViewport(): void
    /**
     * This function is used to emit an event on the main stage.
     * 
     * You should rarely need to use this function, except for
     * synthetised events.
     */
    event(event: Event): boolean
    /**
     * Retrieves the value set with clutter_stage_set_accept_focus().
     */
    getAcceptFocus(): boolean
    /**
     * Checks the scene at the coordinates `x` and `y` and returns a pointer
     * to the #ClutterActor at those coordinates.
     * 
     * By using `pick_mode` it is possible to control which actors will be
     * painted and thus available.
     */
    getActorAtPos(pickMode: PickMode, x: number, y: number): Actor
    /**
     * Retrieves the stage color.
     */
    getColor(): /* color */ Color
    /**
     * Retrieves the current depth cueing settings from the stage.
     */
    getFog(): /* fog */ Fog
    /**
     * Retrieves whether the stage is full screen or not
     */
    getFullscreen(): boolean
    /**
     * Retrieves the actor that is currently under key focus.
     */
    getKeyFocus(): Actor
    /**
     * Retrieves the minimum size for a stage window as set using
     * clutter_stage_set_minimum_size().
     * 
     * The returned size may not correspond to the actual minimum size and
     * it is specific to the #ClutterStage implementation inside the
     * Clutter backend
     */
    getMinimumSize(): [ /* width */ number, /* height */ number ]
    /**
     * Retrieves the value set using clutter_stage_set_motion_events_enabled().
     */
    getMotionEventsEnabled(): boolean
    /**
     * Retrieves the hint set with clutter_stage_set_no_clear_hint()
     */
    getNoClearHint(): boolean
    /**
     * Retrieves the stage perspective.
     */
    getPerspective(): /* perspective */ Perspective | null
    /**
     * Gets the bounds of the current redraw for `stage` in stage pixel
     * coordinates. E.g., if only a single actor has queued a redraw then
     * Clutter may redraw the stage with a clip so that it doesn't have to
     * paint every pixel in the stage. This function would then return the
     * bounds of that clip. An application can use this information to
     * avoid some extra work if it knows that some regions of the stage
     * aren't going to be painted. This should only be called while the
     * stage is being painted. If there is no current redraw clip then
     * this function will set `clip` to the full extents of the stage.
     */
    getRedrawClipBounds(): /* clip */ cairo.RectangleInt
    /**
     * Retrieves the value set with clutter_stage_set_throttle_motion_events()
     */
    getThrottleMotionEvents(): boolean
    /**
     * Gets the stage title.
     */
    getTitle(): string
    /**
     * Retrieves the value set using clutter_stage_set_use_alpha()
     */
    getUseAlpha(): boolean
    /**
     * Gets whether the depth cueing effect is enabled on `stage`.
     */
    getUseFog(): boolean
    /**
     * Retrieves the value set with clutter_stage_set_user_resizable().
     */
    getUserResizable(): boolean
    /**
     * Makes the cursor invisible on the stage window
     */
    hideCursor(): void
    /**
     * Checks if `stage` is the default stage, or an instance created using
     * clutter_stage_new() but internally using the same implementation.
     */
    isDefault(): boolean
    /**
     * Queues a redraw for the passed stage.
     * 
     * Applications should call clutter_actor_queue_redraw() and not
     * this function.
     */
    queueRedraw(): void
    /**
     * Makes a screenshot of the stage in RGBA 8bit data, returns a
     * linear buffer with `width` * 4 as rowstride.
     * 
     * The alpha data contained in the returned buffer is driver-dependent,
     * and not guaranteed to hold any sensible value.
     */
    readPixels(x: number, y: number, width: number, height: number): Uint8Array
    /**
     * Sets whether the `stage` should accept the key focus when shown.
     * 
     * This function should be called before showing `stage` using
     * clutter_actor_show().
     */
    setAcceptFocus(acceptFocus: boolean): void
    /**
     * Sets the stage color.
     */
    setColor(color: Color): void
    /**
     * Sets the fog (also known as "depth cueing") settings for the `stage`.
     * 
     * A #ClutterStage will only use a linear fog progression, which
     * depends solely on the distance from the viewer. The cogl_set_fog()
     * function in COGL exposes more of the underlying implementation,
     * and allows changing the for progression function. It can be directly
     * used by disabling the #ClutterStage:use-fog property and connecting
     * a signal handler to the #ClutterActor::paint signal on the `stage,`
     * like:
     * 
     * |[
     *   clutter_stage_set_use_fog (stage, FALSE);
     *   g_signal_connect (stage, "paint", G_CALLBACK (on_stage_paint), NULL);
     * ```
     * 
     * 
     * The paint signal handler will call cogl_set_fog() with the
     * desired settings:
     * 
     * |[
     *   static void
     *   on_stage_paint (ClutterActor *actor)
     *   {
     *     ClutterColor stage_color = { 0, };
     *     CoglColor fog_color = { 0, };
     * 
     *     // set the fog color to the stage background color
     *     clutter_stage_get_color (CLUTTER_STAGE (actor), &stage_color);
     *     cogl_color_init_from_4ub (&fog_color,
     *                               stage_color.red,
     *                               stage_color.green,
     *                               stage_color.blue,
     *                               stage_color.alpha);
     * 
     *     // enable fog //
     *     cogl_set_fog (&fog_color,
     *                   COGL_FOG_MODE_EXPONENTIAL, // mode
     *                   0.5,                       // density
     *                   5.0, 30.0);                // z_near and z_far
     *   }
     * ```
     * 
     * 
     * The fogging functions only work correctly when the visible actors use
     * unmultiplied alpha colors. By default Cogl will premultiply textures and
     * cogl_set_source_color() will premultiply colors, so unless you explicitly
     * load your textures requesting an unmultiplied internal format and use
     * cogl_material_set_color() you can only use fogging with fully opaque actors.
     * Support for premultiplied colors will improve in the future when we can
     * depend on fragment shaders.
     */
    setFog(fog: Fog): void
    /**
     * Asks to place the stage window in the fullscreen or unfullscreen
     * states.
     * 
     *  ( Note that you shouldn't assume the window is definitely full screen
     * afterward, because other entities (e.g. the user or window manager)
     * could unfullscreen it again, and not all window managers honor
     * requests to fullscreen windows.
     * 
     * If you want to receive notification of the fullscreen state you
     * should either use the #ClutterStage::fullscreen and
     * #ClutterStage::unfullscreen signals, or use the notify signal
     * for the #ClutterStage:fullscreen-set property
     */
    setFullscreen(fullscreen: boolean): void
    /**
     * Sets the key focus on `actor`. An actor with key focus will receive
     * all the key events. If `actor` is %NULL, the stage will receive
     * focus.
     */
    setKeyFocus(actor?: Actor | null): void
    /**
     * Sets the minimum size for a stage window, if the default backend
     * uses #ClutterStage inside a window
     * 
     * This is a convenience function, and it is equivalent to setting the
     * #ClutterActor:min-width and #ClutterActor:min-height on `stage`
     * 
     * If the current size of `stage` is smaller than the minimum size, the
     * `stage` will be resized to the new `width` and `height`
     * 
     * This function has no effect if `stage` is fullscreen
     */
    setMinimumSize(width: number, height: number): void
    /**
     * Sets whether per-actor motion events (and relative crossing
     * events) should be disabled or not.
     * 
     * The default is %TRUE.
     * 
     * If `enable` is %FALSE the following signals will not be emitted
     * by the actors children of `stage:`
     * 
     *  - #ClutterActor::motion-event
     *  - #ClutterActor::enter-event
     *  - #ClutterActor::leave-event
     * 
     * The events will still be delivered to the #ClutterStage.
     * 
     * The main side effect of this function is that disabling the motion
     * events will disable picking to detect the #ClutterActor underneath
     * the pointer for each motion event. This is useful, for instance,
     * when dragging a #ClutterActor across the `stage:` the actor underneath
     * the pointer is not going to change, so it's meaningless to perform
     * a pick.
     */
    setMotionEventsEnabled(enabled: boolean): void
    /**
     * Sets whether the `stage` should clear itself at the beginning
     * of each paint cycle or not.
     * 
     * Clearing the #ClutterStage can be a costly operation, especially
     * if the stage is always covered - for instance, in a full-screen
     * video player or in a game with a background texture.
     * 
     * This setting is a hint; Clutter might discard this hint
     * depending on its internal state.
     * 
     * If parts of the stage are visible and you disable clearing you
     * might end up with visual artifacts while painting the contents of
     * the stage.
     */
    setNoClearHint(noClear: boolean): void
    /**
     * Sets the stage perspective. Using this function is not recommended
     * because it will disable Clutter's attempts to generate an
     * appropriate perspective based on the size of the stage.
     */
    setPerspective(perspective: Perspective): void
    /**
     * Sets whether motion events received between redraws should
     * be throttled or not. If motion events are throttled, those
     * events received by the windowing system between redraws will
     * be compressed so that only the last event will be propagated
     * to the `stage` and its actors.
     * 
     * This function should only be used if you want to have all
     * the motion events delivered to your application code.
     */
    setThrottleMotionEvents(throttle: boolean): void
    /**
     * Sets the stage title.
     */
    setTitle(title: string): void
    /**
     * Sets whether the `stage` should honour the #ClutterActor:opacity and
     * the alpha channel of the #ClutterStage:color
     */
    setUseAlpha(useAlpha: boolean): void
    /**
     * Sets whether the depth cueing effect on the stage should be enabled
     * or not.
     * 
     * Depth cueing is a 3D effect that makes actors farther away from the
     * viewing point less opaque, by fading them with the stage color.
     * 
     * The parameters of the GL fog used can be changed using the
     * clutter_stage_set_fog() function.
     */
    setUseFog(fog: boolean): void
    /**
     * Sets if the stage is resizable by user interaction (e.g. via
     * window manager controls)
     */
    setUserResizable(resizable: boolean): void
    /**
     * Shows the cursor on the stage window
     */
    showCursor(): void
    /* Methods of Clutter-1.0.Clutter.Group */
    /**
     * Gets the number of actors held in the group.
     */
    getNChildren(): number
    /**
     * Gets a groups child held at `index_` in stack.
     */
    getNthChild(index: number): Actor
    /**
     * Removes all children actors from the #ClutterGroup.
     */
    removeAll(): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Stage */
    /**
     * The ::activate signal is emitted when the stage receives key focus
     * from the underlying window system.
     */
    connect(sigName: "activate", callback: (() => void)): number
    on(sigName: "activate", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "activate", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "activate", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "activate"): void
    /**
     * The ::after-paint signal is emitted after the stage is painted,
     * but before the results are displayed on the screen.
     */
    connect(sigName: "after-paint", callback: (() => void)): number
    on(sigName: "after-paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "after-paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "after-paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "after-paint"): void
    /**
     * The ::deactivate signal is emitted when the stage loses key focus
     * from the underlying window system.
     */
    connect(sigName: "deactivate", callback: (() => void)): number
    on(sigName: "deactivate", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "deactivate", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "deactivate", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "deactivate"): void
    /**
     * The ::delete-event signal is emitted when the user closes a
     * #ClutterStage window using the window controls.
     * 
     * Clutter by default will call clutter_main_quit() if `stage` is
     * the default stage, and clutter_actor_destroy() for any other
     * stage.
     * 
     * It is possible to override the default behaviour by connecting
     * a new handler and returning %TRUE there.
     * 
     * This signal is emitted only on Clutter backends that
     * embed #ClutterStage in native windows. It is not emitted for
     * backends that use a static frame buffer.
     */
    connect(sigName: "delete-event", callback: ((event: Event) => boolean)): number
    on(sigName: "delete-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "delete-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "delete-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "delete-event", event: Event): void
    /**
     * The ::fullscreen signal is emitted when the stage is made fullscreen.
     */
    connect(sigName: "fullscreen", callback: (() => void)): number
    on(sigName: "fullscreen", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "fullscreen", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "fullscreen", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "fullscreen"): void
    /**
     * The ::unfullscreen signal is emitted when the stage leaves a fullscreen
     * state.
     */
    connect(sigName: "unfullscreen", callback: (() => void)): number
    on(sigName: "unfullscreen", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unfullscreen", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unfullscreen", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unfullscreen"): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::accept-focus", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::accept-focus", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::accept-focus", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::accept-focus", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::accept-focus", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cursor-visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cursor-visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cursor-visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cursor-visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cursor-visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fog", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fog", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fullscreen-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fullscreen-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fullscreen-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fullscreen-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fullscreen-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::key-focus", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::key-focus", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::key-focus", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::key-focus", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::key-focus", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::no-clear-hint", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::no-clear-hint", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::no-clear-hint", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::no-clear-hint", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::no-clear-hint", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::perspective", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::perspective", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::perspective", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::perspective", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::perspective", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::title", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::title", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::use-alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::use-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::use-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::use-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::use-fog", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-fog", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::use-fog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::use-fog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::use-fog", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::user-resizable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::user-resizable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::user-resizable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::user-resizable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::user-resizable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Stage_ConstructProps)
    _init (config?: Stage_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Stage
    /**
     * Retrieves a #ClutterStage singleton.
     * 
     * This function is not as useful as it sounds, and will most likely
     * by deprecated in the future. Application code should only create
     * a #ClutterStage instance using clutter_stage_new(), and manage the
     * lifetime of the stage manually.
     * 
     * The default stage singleton has a platform-specific behaviour: on
     * platforms without the %CLUTTER_FEATURE_STAGE_MULTIPLE feature flag
     * set, the first #ClutterStage instance will also be set to be the
     * default stage instance, and this function will always return a
     * pointer to it.
     * 
     * On platforms with the %CLUTTER_FEATURE_STAGE_MULTIPLE feature flag
     * set, the default stage will be created by the first call to this
     * function, and every following call will return the same pointer to
     * it.
     */
    static getDefault(): Stage
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
interface StageManager_ConstructProps extends GObject.Object_ConstructProps {
}
class StageManager {
    /* Properties of Clutter-1.0.Clutter.StageManager */
    /**
     * The default stage used by Clutter.
     */
    readonly defaultStage: Stage
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.StageManager */
    /**
     * Returns the default #ClutterStage.
     */
    getDefaultStage(): Stage
    /**
     * Lists all currently used stages.
     */
    listStages(): Stage[]
    /**
     * Lists all currently used stages.
     */
    peekStages(): Stage[]
    /**
     * Sets `stage` as the default stage.
     */
    setDefaultStage(stage: Stage): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.StageManager */
    /**
     * The ::stage-added signal is emitted each time a new #ClutterStage
     * has been added to the stage manager.
     */
    connect(sigName: "stage-added", callback: ((stage: Stage) => void)): number
    on(sigName: "stage-added", callback: (stage: Stage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "stage-added", callback: (stage: Stage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "stage-added", callback: (stage: Stage) => void): NodeJS.EventEmitter
    emit(sigName: "stage-added", stage: Stage): void
    /**
     * The ::stage-removed signal is emitted each time a #ClutterStage
     * has been removed from the stage manager.
     */
    connect(sigName: "stage-removed", callback: ((stage: Stage) => void)): number
    on(sigName: "stage-removed", callback: (stage: Stage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "stage-removed", callback: (stage: Stage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "stage-removed", callback: (stage: Stage) => void): NodeJS.EventEmitter
    emit(sigName: "stage-removed", stage: Stage): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::default-stage", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::default-stage", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::default-stage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::default-stage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::default-stage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: StageManager_ConstructProps)
    _init (config?: StageManager_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Returns the default #ClutterStageManager.
     */
    static getDefault(): StageManager
    static $gtype: GObject.Type
}
interface State_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.State */
    /**
     * Default duration used if an duration has not been specified for a specific
     * source/target state pair. The values is in milliseconds.
     */
    duration?: number
    /**
     * The currently set target state, setting it causes the
     * state machine to transition to the new state, use
     * clutter_state_warp_to_state() to change state without
     * a transition.
     */
    state?: string
}
class State {
    /* Properties of Clutter-1.0.Clutter.State */
    /**
     * Default duration used if an duration has not been specified for a specific
     * source/target state pair. The values is in milliseconds.
     */
    duration: number
    /**
     * The currently set target state, setting it causes the
     * state machine to transition to the new state, use
     * clutter_state_warp_to_state() to change state without
     * a transition.
     */
    state: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.State */
    /**
     * Retrieves the #ClutterAnimator that is being used for transitioning
     * between the two states, if any has been set
     */
    getAnimator(sourceStateName: string, targetStateName: string): Animator
    /**
     * Queries the duration used for transitions between a source and
     * target state pair
     * 
     * The semantics for the query are the same as the semantics used for
     * setting the duration with clutter_state_set_duration()
     */
    getDuration(sourceStateName?: string | null, targetStateName?: string | null): number
    /**
     * Returns a list of pointers to opaque structures with accessor functions
     * that describe the keys added to an animator.
     */
    getKeys(sourceStateName?: string | null, targetStateName?: string | null, object?: GObject.Object | null, propertyName?: string | null): StateKey[]
    /**
     * Queries the currently set target state.
     * 
     * During a transition this function will return the target of the transition.
     * 
     * This function is useful when called from handlers of the
     * #ClutterState::completed signal.
     */
    getState(): string
    /**
     * Gets a list of all the state names managed by this #ClutterState.
     */
    getStates(): string[]
    /**
     * Gets the timeline driving the #ClutterState
     */
    getTimeline(): Timeline
    /**
     * Removes all keys matching the search criteria passed in arguments.
     */
    removeKey(sourceStateName?: string | null, targetStateName?: string | null, object?: GObject.Object | null, propertyName?: string | null): void
    /**
     * Specifies a #ClutterAnimator to be used when transitioning between
     * the two named states.
     * 
     * The `animator` allows specifying a transition between the state that is
     * more elaborate than the basic transitions allowed by the tweening of
     * properties defined in the #ClutterState keys.
     * 
     * If `animator` is %NULL it will unset an existing animator.
     * 
     * #ClutterState will take a reference on the passed `animator,` if any
     */
    setAnimator(sourceStateName: string, targetStateName: string, animator?: Animator | null): void
    /**
     * Sets the duration of a transition.
     * 
     * If both state names are %NULL the default duration for `state` is set.
     * 
     * If only `target_state_name` is specified, the passed `duration` becomes
     * the default duration for transitions to the target state.
     * 
     * If both states names are specified, the passed `duration` only applies
     * to the specified transition.
     */
    setDuration(sourceStateName: string | null, targetStateName: string | null, duration: number): void
    /**
     * Sets one specific end key for a state name, `object,` `property_name`
     * combination.
     */
    setKey(sourceStateName: string | null, targetStateName: string, object: GObject.Object, propertyName: string, mode: number, value: any, preDelay: number, postDelay: number): State
    /**
     * Change the current state of #ClutterState to `target_state_name`.
     * 
     * The state will animate during its transition, see
     * #clutter_state_warp_to_state for animation-free state switching.
     * 
     * Setting a %NULL state will stop the current animation and unset
     * the current state, but keys will be left intact.
     */
    setState(targetStateName: string): Timeline
    /**
     * Change to the specified target state immediately with no animation.
     * 
     * See clutter_state_set_state().
     */
    warpToState(targetStateName: string): Timeline
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.State */
    /**
     * The ::completed signal is emitted when a #ClutterState reaches
     * the target state specified by clutter_state_set_state() or
     * clutter_state_warp_to_state().
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: State_ConstructProps)
    _init (config?: State_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): State
    static $gtype: GObject.Type
}
interface SwipeAction_ConstructProps extends GestureAction_ConstructProps {
}
class SwipeAction {
    /* Properties of Clutter-1.0.Clutter.GestureAction */
    /**
     * Number of touch points to trigger a gesture action.
     */
    nTouchPoints: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.GestureAction */
    /**
     * Cancel a #ClutterGestureAction before it begins
     */
    cancel(): void
    /**
     * Retrieves the #ClutterInputDevice of a touch point.
     */
    getDevice(point: number): InputDevice
    /**
     * Retrieves a reference to the last #ClutterEvent for a touch point. Call
     * clutter_event_copy() if you need to store the reference somewhere.
     */
    getLastEvent(point: number): Event
    /**
     * Retrieves the coordinates, in stage space, of the latest motion
     * event during the dragging.
     */
    getMotionCoords(point: number): [ /* motionX */ number | null, /* motionY */ number | null ]
    /**
     * Retrieves the incremental delta since the last motion event
     * during the dragging.
     */
    getMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the number of points currently active.
     */
    getNCurrentPoints(): number
    /**
     * Retrieves the number of requested points to trigger the gesture.
     */
    getNTouchPoints(): number
    /**
     * Retrieves the coordinates, in stage space, of the press event
     * that started the dragging for a specific touch point.
     */
    getPressCoords(point: number): [ /* pressX */ number | null, /* pressY */ number | null ]
    /**
     * Retrieves the coordinates, in stage space, where the touch point was
     * last released.
     */
    getReleaseCoords(point: number): [ /* releaseX */ number | null, /* releaseY */ number | null ]
    /**
     * Retrieves the #ClutterEventSequence of a touch point.
     */
    getSequence(point: number): EventSequence
    /**
     * Retrieves the threshold trigger distance of the gesture `action,`
     * as set using clutter_gesture_action_set_threshold_trigger_distance().
     */
    getThresholdTriggerDistance(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEdge(): GestureTriggerEdge
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEgde(): GestureTriggerEdge
    /**
     * Retrieves the velocity, in stage pixels per millisecond, of the
     * latest motion event during the dragging.
     */
    getVelocity(point: number): [ /* returnType */ number, /* velocityX */ number | null, /* velocityY */ number | null ]
    /**
     * Sets the number of points needed to trigger the gesture.
     */
    setNTouchPoints(nbPoints: number): void
    /**
     * Sets the threshold trigger distance for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerDistance(x: number, y: number): void
    /**
     * Sets the edge trigger for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerEdge(edge: GestureTriggerEdge): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.SwipeAction */
    /**
     * The ::swept signal is emitted when a swipe gesture is recognized on the
     * attached actor.
     */
    connect(sigName: "swept", callback: ((actor: Actor, direction: SwipeDirection) => void)): number
    on(sigName: "swept", callback: (actor: Actor, direction: SwipeDirection) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "swept", callback: (actor: Actor, direction: SwipeDirection) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "swept", callback: (actor: Actor, direction: SwipeDirection) => void): NodeJS.EventEmitter
    emit(sigName: "swept", actor: Actor, direction: SwipeDirection): void
    /**
     * The ::swipe signal is emitted when a swipe gesture is recognized on the
     * attached actor.
     */
    connect(sigName: "swipe", callback: ((actor: Actor, direction: SwipeDirection) => boolean)): number
    on(sigName: "swipe", callback: (actor: Actor, direction: SwipeDirection) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "swipe", callback: (actor: Actor, direction: SwipeDirection) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "swipe", callback: (actor: Actor, direction: SwipeDirection) => void): NodeJS.EventEmitter
    emit(sigName: "swipe", actor: Actor, direction: SwipeDirection): void
    /* Signals of Clutter-1.0.Clutter.GestureAction */
    /**
     * The ::gesture_begin signal is emitted when the #ClutterActor to which
     * a #ClutterGestureAction has been applied starts receiving a gesture.
     */
    connect(sigName: "gesture-begin", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-begin", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-begin", actor: Actor): void
    /**
     * The ::gesture-cancel signal is emitted when the ongoing gesture gets
     * cancelled from the #ClutterGestureAction::gesture-progress signal handler.
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-cancel", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-cancel", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-cancel", actor: Actor): void
    /**
     * The ::gesture-end signal is emitted at the end of the gesture gesture,
     * when the pointer's button is released
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-end", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-end", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-end", actor: Actor): void
    /**
     * The ::gesture-progress signal is emitted for each motion event after
     * the #ClutterGestureAction::gesture-begin signal has been emitted.
     */
    connect(sigName: "gesture-progress", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-progress", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-progress", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SwipeAction_ConstructProps)
    _init (config?: SwipeAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SwipeAction
    static $gtype: GObject.Type
}
interface TableLayout_ConstructProps extends LayoutManager_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.TableLayout */
    /**
     * The spacing between columns of the #ClutterTableLayout, in pixels
     */
    columnSpacing?: number
    /**
     * The duration of the animations, in case #ClutterTableLayout:use-animations
     * is set to %TRUE.
     * 
     * The duration is expressed in milliseconds.
     */
    easingDuration?: number
    /**
     * The easing mode for the animations, in case
     * #ClutterTableLayout:use-animations is set to %TRUE.
     * 
     * The easing mode has the same semantics of #ClutterAnimation:mode: it can
     * either be a value from the #ClutterAnimationMode enumeration, like
     * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
     * clutter_alpha_register_func().
     * 
     * The default value is %CLUTTER_EASE_OUT_CUBIC.
     */
    easingMode?: number
    /**
     * The spacing between rows of the #ClutterTableLayout, in pixels
     */
    rowSpacing?: number
    /**
     * Whether the #ClutterTableLayout should animate changes in the
     * layout properties.
     * 
     * By default, #ClutterTableLayout will honour the easing state of
     * the children when allocating them. Setting this property to
     * %TRUE will override the easing state with the layout manager's
     * #ClutterTableLayout:easing-mode and #ClutterTableLayout:easing-duration
     * properties.
     */
    useAnimations?: boolean
}
class TableLayout {
    /* Properties of Clutter-1.0.Clutter.TableLayout */
    /**
     * The spacing between columns of the #ClutterTableLayout, in pixels
     */
    columnSpacing: number
    /**
     * The duration of the animations, in case #ClutterTableLayout:use-animations
     * is set to %TRUE.
     * 
     * The duration is expressed in milliseconds.
     */
    easingDuration: number
    /**
     * The easing mode for the animations, in case
     * #ClutterTableLayout:use-animations is set to %TRUE.
     * 
     * The easing mode has the same semantics of #ClutterAnimation:mode: it can
     * either be a value from the #ClutterAnimationMode enumeration, like
     * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
     * clutter_alpha_register_func().
     * 
     * The default value is %CLUTTER_EASE_OUT_CUBIC.
     */
    easingMode: number
    /**
     * The spacing between rows of the #ClutterTableLayout, in pixels
     */
    rowSpacing: number
    /**
     * Whether the #ClutterTableLayout should animate changes in the
     * layout properties.
     * 
     * By default, #ClutterTableLayout will honour the easing state of
     * the children when allocating them. Setting this property to
     * %TRUE will override the easing state with the layout manager's
     * #ClutterTableLayout:easing-mode and #ClutterTableLayout:easing-duration
     * properties.
     */
    useAnimations: boolean
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.TableLayout */
    /**
     * Retrieves the horizontal and vertical alignment policies for `actor`
     * as set using clutter_table_layout_pack() or
     * clutter_table_layout_set_alignment().
     */
    getAlignment(actor: Actor): [ /* xAlign */ TableAlignment, /* yAlign */ TableAlignment ]
    /**
     * Retrieve the current number of columns in `layout`
     */
    getColumnCount(): number
    /**
     * Retrieves the spacing set using clutter_table_layout_set_column_spacing()
     */
    getColumnSpacing(): number
    /**
     * Retrieves the duration set using clutter_table_layout_set_easing_duration()
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode set using clutter_table_layout_set_easing_mode()
     */
    getEasingMode(): number
    /**
     * Retrieves the horizontal and vertical expand policies for `actor`
     * as set using clutter_table_layout_pack() or clutter_table_layout_set_expand()
     */
    getExpand(actor: Actor): [ /* xExpand */ boolean, /* yExpand */ boolean ]
    /**
     * Retrieves the horizontal and vertical fill policies for `actor`
     * as set using clutter_table_layout_pack() or clutter_table_layout_set_fill()
     */
    getFill(actor: Actor): [ /* xFill */ boolean, /* yFill */ boolean ]
    /**
     * Retrieve the current number rows in the `layout`
     */
    getRowCount(): number
    /**
     * Retrieves the spacing set using clutter_table_layout_set_row_spacing()
     */
    getRowSpacing(): number
    /**
     * Retrieves the row and column span for `actor` as set using
     * clutter_table_layout_pack() or clutter_table_layout_set_span()
     */
    getSpan(actor: Actor): [ /* columnSpan */ number, /* rowSpan */ number ]
    /**
     * Retrieves whether `layout` should animate changes in the layout properties
     * 
     * Since clutter_table_layout_set_use_animations()
     */
    getUseAnimations(): boolean
    /**
     * Packs `actor` inside the #ClutterContainer associated to `layout`
     * at the given row and column.
     */
    pack(actor: Actor, column: number, row: number): void
    /**
     * Sets the horizontal and vertical alignment policies for `actor`
     * inside `layout`
     */
    setAlignment(actor: Actor, xAlign: TableAlignment, yAlign: TableAlignment): void
    /**
     * Sets the spacing between columns of `layout`
     */
    setColumnSpacing(spacing: number): void
    /**
     * Sets the duration of the animations used by `layout` when animating changes
     * in the layout properties
     * 
     * Use clutter_table_layout_set_use_animations() to enable and disable the
     * animations
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode to be used by `layout` when animating changes in layout
     * properties
     * 
     * Use clutter_table_layout_set_use_animations() to enable and disable the
     * animations
     */
    setEasingMode(mode: number): void
    /**
     * Sets the horizontal and vertical expand policies for `actor`
     * inside `layout`
     */
    setExpand(actor: Actor, xExpand: boolean, yExpand: boolean): void
    /**
     * Sets the horizontal and vertical fill policies for `actor`
     * inside `layout`
     */
    setFill(actor: Actor, xFill: boolean, yFill: boolean): void
    /**
     * Sets the spacing between rows of `layout`
     */
    setRowSpacing(spacing: number): void
    /**
     * Sets the row and column span for `actor`
     * inside `layout`
     */
    setSpan(actor: Actor, columnSpan: number, rowSpan: number): void
    /**
     * Sets whether `layout` should animate changes in the layout properties
     * 
     * The duration of the animations is controlled by
     * clutter_table_layout_set_easing_duration(); the easing mode to be used
     * by the animations is controlled by clutter_table_layout_set_easing_mode()
     */
    setUseAnimations(animate: boolean): void
    /* Methods of Clutter-1.0.Clutter.LayoutManager */
    /**
     * Allocates the children of `container` given an area
     * 
     * See also clutter_actor_allocate()
     */
    allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void
    /**
     * Begins an animation of `duration` milliseconds, using the provided
     * easing `mode`
     * 
     * The easing mode can be specified either as a #ClutterAnimationMode
     * or as a logical id returned by clutter_alpha_register_func()
     * 
     * The result of this function depends on the `manager` implementation
     */
    beginAnimation(duration: number, mode: number): Alpha
    /**
     * Gets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     * 
     * The #GValue must already be initialized to the type of the property
     * and has to be unset with g_value_unset() after extracting the real
     * value out of it
     */
    childGetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Sets a property on the #ClutterLayoutMeta created by `manager` and
     * attached to a child of `container`
     */
    childSetProperty(container: Container, actor: Actor, propertyName: string, value: any): void
    /**
     * Ends an animation started by clutter_layout_manager_begin_animation()
     * 
     * The result of this call depends on the `manager` implementation
     */
    endAnimation(): void
    /**
     * Retrieves the #GParamSpec for the layout property `name` inside
     * the #ClutterLayoutMeta sub-class used by `manager`
     */
    findChildProperty(name: string): GObject.ParamSpec
    /**
     * Retrieves the progress of the animation, if one has been started by
     * clutter_layout_manager_begin_animation()
     * 
     * The returned value has the same semantics of the #ClutterAlpha:alpha
     * value
     */
    getAnimationProgress(): number
    /**
     * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
     * to the `actor` child of `container,` eventually by creating one if the
     * #ClutterLayoutManager supports layout properties
     */
    getChildMeta(container: Container, actor: Actor): LayoutMeta
    /**
     * Computes the minimum and natural heights of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_height()
     */
    getPreferredHeight(container: Container, forWidth: number): [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    /**
     * Computes the minimum and natural widths of the `container` according
     * to `manager`.
     * 
     * See also clutter_actor_get_preferred_width()
     */
    getPreferredWidth(container: Container, forHeight: number): [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    /**
     * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
     * 
     * This function should only be called by implementations of the
     * #ClutterLayoutManager class
     */
    layoutChanged(): void
    /**
     * Retrieves all the #GParamSpec<!-- -->s for the layout properties
     * stored inside the #ClutterLayoutMeta sub-class used by `manager`
     */
    listChildProperties(): GObject.ParamSpec[]
    /**
     * If the #ClutterLayoutManager sub-class allows it, allow
     * adding a weak reference of the `container` using `manager`
     * from within the layout manager
     * 
     * The layout manager should not increase the reference
     * count of the `container`
     */
    setContainer(container?: Container | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.LayoutManager */
    /**
     * The ::layout-changed signal is emitted each time a layout manager
     * has been changed. Every #ClutterActor using the `manager` instance
     * as a layout manager should connect a handler to the ::layout-changed
     * signal and queue a relayout on themselves:
     * 
     * |[
     *   static void layout_changed (ClutterLayoutManager *manager,
     *                               ClutterActor         *self)
     *   {
     *     clutter_actor_queue_relayout (self);
     *   }
     *   ...
     *     self->manager = g_object_ref_sink (manager);
     *     g_signal_connect (self->manager, "layout-changed",
     *                       G_CALLBACK (layout_changed),
     *                       self);
     * ```
     * 
     * 
     * Sub-classes of #ClutterLayoutManager that implement a layout that
     * can be controlled or changed using parameters should emit the
     * ::layout-changed signal whenever one of the parameters changes,
     * by using clutter_layout_manager_layout_changed().
     */
    connect(sigName: "layout-changed", callback: (() => void)): number
    on(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "layout-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "layout-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "layout-changed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::column-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::column-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::column-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::easing-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::easing-duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::easing-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::easing-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::easing-duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::easing-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::easing-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::easing-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::easing-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::easing-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::row-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::row-spacing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::row-spacing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::use-animations", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-animations", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::use-animations", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::use-animations", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::use-animations", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TableLayout_ConstructProps)
    _init (config?: TableLayout_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TableLayout
    static $gtype: GObject.Type
}
interface TapAction_ConstructProps extends GestureAction_ConstructProps {
}
class TapAction {
    /* Properties of Clutter-1.0.Clutter.GestureAction */
    /**
     * Number of touch points to trigger a gesture action.
     */
    nTouchPoints: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.GestureAction */
    /**
     * Cancel a #ClutterGestureAction before it begins
     */
    cancel(): void
    /**
     * Retrieves the #ClutterInputDevice of a touch point.
     */
    getDevice(point: number): InputDevice
    /**
     * Retrieves a reference to the last #ClutterEvent for a touch point. Call
     * clutter_event_copy() if you need to store the reference somewhere.
     */
    getLastEvent(point: number): Event
    /**
     * Retrieves the coordinates, in stage space, of the latest motion
     * event during the dragging.
     */
    getMotionCoords(point: number): [ /* motionX */ number | null, /* motionY */ number | null ]
    /**
     * Retrieves the incremental delta since the last motion event
     * during the dragging.
     */
    getMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the number of points currently active.
     */
    getNCurrentPoints(): number
    /**
     * Retrieves the number of requested points to trigger the gesture.
     */
    getNTouchPoints(): number
    /**
     * Retrieves the coordinates, in stage space, of the press event
     * that started the dragging for a specific touch point.
     */
    getPressCoords(point: number): [ /* pressX */ number | null, /* pressY */ number | null ]
    /**
     * Retrieves the coordinates, in stage space, where the touch point was
     * last released.
     */
    getReleaseCoords(point: number): [ /* releaseX */ number | null, /* releaseY */ number | null ]
    /**
     * Retrieves the #ClutterEventSequence of a touch point.
     */
    getSequence(point: number): EventSequence
    /**
     * Retrieves the threshold trigger distance of the gesture `action,`
     * as set using clutter_gesture_action_set_threshold_trigger_distance().
     */
    getThresholdTriggerDistance(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEdge(): GestureTriggerEdge
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEgde(): GestureTriggerEdge
    /**
     * Retrieves the velocity, in stage pixels per millisecond, of the
     * latest motion event during the dragging.
     */
    getVelocity(point: number): [ /* returnType */ number, /* velocityX */ number | null, /* velocityY */ number | null ]
    /**
     * Sets the number of points needed to trigger the gesture.
     */
    setNTouchPoints(nbPoints: number): void
    /**
     * Sets the threshold trigger distance for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerDistance(x: number, y: number): void
    /**
     * Sets the edge trigger for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerEdge(edge: GestureTriggerEdge): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.TapAction */
    /**
     * The ::tap signal is emitted when the tap gesture is complete.
     */
    connect(sigName: "tap", callback: ((actor: Actor) => void)): number
    on(sigName: "tap", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "tap", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "tap", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "tap", actor: Actor): void
    /* Signals of Clutter-1.0.Clutter.GestureAction */
    /**
     * The ::gesture_begin signal is emitted when the #ClutterActor to which
     * a #ClutterGestureAction has been applied starts receiving a gesture.
     */
    connect(sigName: "gesture-begin", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-begin", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-begin", actor: Actor): void
    /**
     * The ::gesture-cancel signal is emitted when the ongoing gesture gets
     * cancelled from the #ClutterGestureAction::gesture-progress signal handler.
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-cancel", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-cancel", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-cancel", actor: Actor): void
    /**
     * The ::gesture-end signal is emitted at the end of the gesture gesture,
     * when the pointer's button is released
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-end", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-end", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-end", actor: Actor): void
    /**
     * The ::gesture-progress signal is emitted for each motion event after
     * the #ClutterGestureAction::gesture-begin signal has been emitted.
     */
    connect(sigName: "gesture-progress", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-progress", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-progress", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TapAction_ConstructProps)
    _init (config?: TapAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TapAction
    static $gtype: GObject.Type
}
interface Text_ConstructProps extends Actor_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Text */
    /**
     * Toggles whether return invokes the activate signal or not.
     */
    activatable?: boolean
    /**
     * A list of #PangoStyleAttribute<!-- -->s to be applied to the
     * contents of the #ClutterText actor.
     */
    attributes?: Pango.AttrList
    /**
     * The buffer which stores the text for this #ClutterText.
     * 
     * If set to %NULL, a default buffer will be created.
     */
    buffer?: TextBuffer
    /**
     * The color used to render the text.
     */
    color?: Color
    /**
     * The color of the cursor.
     */
    cursorColor?: Color
    /**
     * The current input cursor position. -1 is taken to be the end of the text
     */
    cursorPosition?: number
    /**
     * The size of the cursor, in pixels. If set to -1 the size used will
     * be the default cursor size of 2 pixels.
     */
    cursorSize?: number
    /**
     * Whether the input cursor is visible or not.
     * 
     * The cursor will only be visible if this property and either
     * the #ClutterText:editable or the #ClutterText:selectable properties
     * are set to %TRUE.
     */
    cursorVisible?: boolean
    /**
     * Whether key events delivered to the actor causes editing.
     */
    editable?: boolean
    /**
     * The preferred place to ellipsize the contents of the #ClutterText actor
     */
    ellipsize?: Pango.EllipsizeMode
    /**
     * The #PangoFontDescription that should be used by the #ClutterText
     * 
     * If you have a string describing the font then you should look at
     * #ClutterText:font-name instead
     */
    fontDescription?: Pango.FontDescription
    /**
     * The font to be used by the #ClutterText, as a string
     * that can be parsed by pango_font_description_from_string().
     * 
     * If set to %NULL, the default system font will be used instead.
     */
    fontName?: string
    /**
     * Whether the contents of the #ClutterText should be justified
     * on both margins.
     */
    justify?: boolean
    /**
     * The preferred alignment for the text. This property controls
     * the alignment of multi-line paragraphs.
     */
    lineAlignment?: Pango.Alignment
    /**
     * Whether to wrap the lines of #ClutterText:text if the contents
     * exceed the available allocation. The wrapping strategy is
     * controlled by the #ClutterText:line-wrap-mode property.
     */
    lineWrap?: boolean
    /**
     * If #ClutterText:line-wrap is set to %TRUE, this property will
     * control how the text is wrapped.
     */
    lineWrapMode?: Pango.WrapMode
    /**
     * The maximum length of the contents of the #ClutterText actor.
     */
    maxLength?: number
    /**
     * If non-zero, the character that should be used in place of
     * the actual text in a password text actor.
     */
    passwordChar?: number
    /**
     * The current input cursor position. -1 is taken to be the end of the text
     */
    position?: number & Point
    /**
     * Whether it is possible to select text, either using the pointer
     * or the keyboard.
     * 
     * This property depends on the #ClutterActor:reactive property being
     * set to %TRUE.
     */
    selectable?: boolean
    /**
     * The color of selected text.
     */
    selectedTextColor?: Color
    /**
     * The current input cursor position. -1 is taken to be the end of the text
     */
    selectionBound?: number
    /**
     * The color of the selection.
     */
    selectionColor?: Color
    /**
     * Whether the #ClutterText actor should be in single line mode
     * or not. A single line #ClutterText actor will only contain a
     * single line of text, scrolling it in case its length is bigger
     * than the allocated size.
     * 
     * Setting this property will also set the #ClutterText:activatable
     * property as a side-effect.
     * 
     * The #ClutterText:single-line-mode property is used only if the
     * #ClutterText:editable property is set to %TRUE.
     */
    singleLineMode?: boolean
    /**
     * The text to render inside the actor.
     */
    text?: string
    /**
     * Whether the text includes Pango markup.
     * 
     * For more informations about the Pango markup format, see
     * pango_layout_set_markup() in the Pango documentation.
     * 
     * It is not possible to round-trip this property between
     * %TRUE and %FALSE. Once a string with markup has been set on
     * a #ClutterText actor with :use-markup set to %TRUE, the markup
     * is stripped from the string.
     */
    useMarkup?: boolean
}
class Text {
    /* Properties of Clutter-1.0.Clutter.Text */
    /**
     * Toggles whether return invokes the activate signal or not.
     */
    activatable: boolean
    /**
     * A list of #PangoStyleAttribute<!-- -->s to be applied to the
     * contents of the #ClutterText actor.
     */
    attributes: Pango.AttrList
    /**
     * The buffer which stores the text for this #ClutterText.
     * 
     * If set to %NULL, a default buffer will be created.
     */
    buffer: TextBuffer
    /**
     * The color used to render the text.
     */
    color: Color
    /**
     * The color of the cursor.
     */
    cursorColor: Color
    /**
     * Will be set to %TRUE if #ClutterText:cursor-color has been set.
     */
    readonly cursorColorSet: boolean
    /**
     * The current input cursor position. -1 is taken to be the end of the text
     */
    cursorPosition: number
    /**
     * The size of the cursor, in pixels. If set to -1 the size used will
     * be the default cursor size of 2 pixels.
     */
    cursorSize: number
    /**
     * Whether the input cursor is visible or not.
     * 
     * The cursor will only be visible if this property and either
     * the #ClutterText:editable or the #ClutterText:selectable properties
     * are set to %TRUE.
     */
    cursorVisible: boolean
    /**
     * Whether key events delivered to the actor causes editing.
     */
    editable: boolean
    /**
     * The preferred place to ellipsize the contents of the #ClutterText actor
     */
    ellipsize: Pango.EllipsizeMode
    /**
     * The #PangoFontDescription that should be used by the #ClutterText
     * 
     * If you have a string describing the font then you should look at
     * #ClutterText:font-name instead
     */
    fontDescription: Pango.FontDescription
    /**
     * The font to be used by the #ClutterText, as a string
     * that can be parsed by pango_font_description_from_string().
     * 
     * If set to %NULL, the default system font will be used instead.
     */
    fontName: string
    /**
     * Whether the contents of the #ClutterText should be justified
     * on both margins.
     */
    justify: boolean
    /**
     * The preferred alignment for the text. This property controls
     * the alignment of multi-line paragraphs.
     */
    lineAlignment: Pango.Alignment
    /**
     * Whether to wrap the lines of #ClutterText:text if the contents
     * exceed the available allocation. The wrapping strategy is
     * controlled by the #ClutterText:line-wrap-mode property.
     */
    lineWrap: boolean
    /**
     * If #ClutterText:line-wrap is set to %TRUE, this property will
     * control how the text is wrapped.
     */
    lineWrapMode: Pango.WrapMode
    /**
     * The maximum length of the contents of the #ClutterText actor.
     */
    maxLength: number
    /**
     * If non-zero, the character that should be used in place of
     * the actual text in a password text actor.
     */
    passwordChar: number
    /**
     * The current input cursor position. -1 is taken to be the end of the text
     */
    position: number
    /**
     * Whether it is possible to select text, either using the pointer
     * or the keyboard.
     * 
     * This property depends on the #ClutterActor:reactive property being
     * set to %TRUE.
     */
    selectable: boolean
    /**
     * The color of selected text.
     */
    selectedTextColor: Color
    /**
     * Will be set to %TRUE if #ClutterText:selected-text-color has been set.
     */
    readonly selectedTextColorSet: boolean
    /**
     * The current input cursor position. -1 is taken to be the end of the text
     */
    selectionBound: number
    /**
     * The color of the selection.
     */
    selectionColor: Color
    /**
     * Will be set to %TRUE if #ClutterText:selection-color has been set.
     */
    readonly selectionColorSet: boolean
    /**
     * Whether the #ClutterText actor should be in single line mode
     * or not. A single line #ClutterText actor will only contain a
     * single line of text, scrolling it in case its length is bigger
     * than the allocated size.
     * 
     * Setting this property will also set the #ClutterText:activatable
     * property as a side-effect.
     * 
     * The #ClutterText:single-line-mode property is used only if the
     * #ClutterText:editable property is set to %TRUE.
     */
    singleLineMode: boolean
    /**
     * The text to render inside the actor.
     */
    text: string
    /**
     * Whether the text includes Pango markup.
     * 
     * For more informations about the Pango markup format, see
     * pango_layout_set_markup() in the Pango documentation.
     * 
     * It is not possible to round-trip this property between
     * %TRUE and %FALSE. Once a string with markup has been set on
     * a #ClutterText actor with :use-markup set to %TRUE, the markup
     * is stripped from the string.
     */
    useMarkup: boolean
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Text */
    /**
     * Emits the #ClutterText::activate signal, if `self` has been set
     * as activatable using clutter_text_set_activatable().
     * 
     * This function can be used to emit the ::activate signal inside
     * a #ClutterActor::captured-event or #ClutterActor::key-press-event
     * signal handlers before the default signal handler for the
     * #ClutterText is invoked.
     */
    activate(): boolean
    /**
     * Retrieves the position of the character at the given coordinates.
     */
    coordsToPosition(x: number, y: number): number
    /**
     * Deletes `n_chars` inside a #ClutterText actor, starting from the
     * current cursor position.
     * 
     * Somewhat awkwardly, the cursor position is decremented by the same
     * number of characters you've deleted.
     */
    deleteChars(nChars: number): void
    /**
     * Deletes the currently selected text
     * 
     * This function is only useful in subclasses of #ClutterText
     */
    deleteSelection(): boolean
    /**
     * Deletes the text inside a #ClutterText actor between `start_pos`
     * and `end_pos`.
     * 
     * The starting and ending positions are expressed in characters,
     * not in bytes.
     */
    deleteText(startPos: number, endPos: number): void
    /**
     * Retrieves whether a #ClutterText is activatable or not.
     */
    getActivatable(): boolean
    /**
     * Gets the attribute list that was set on the #ClutterText actor
     * clutter_text_set_attributes(), if any.
     */
    getAttributes(): Pango.AttrList
    /**
     * Get the #ClutterTextBuffer object which holds the text for
     * this widget.
     */
    getBuffer(): TextBuffer
    /**
     * Retrieves the contents of the #ClutterText actor between
     * `start_pos` and `end_pos,` but not including `end_pos`.
     * 
     * The positions are specified in characters, not in bytes.
     */
    getChars(startPos: number, endPos: number): string
    /**
     * Retrieves the text color as set by clutter_text_set_color().
     */
    getColor(): /* color */ Color
    /**
     * Retrieves the color of the cursor of a #ClutterText actor.
     */
    getCursorColor(): /* color */ Color
    /**
     * Retrieves the cursor position.
     */
    getCursorPosition(): number
    /**
     * Retrieves the rectangle that contains the cursor.
     * 
     * The coordinates of the rectangle's origin are in actor-relative
     * coordinates.
     */
    getCursorRect(): /* rect */ Rect
    /**
     * Retrieves the size of the cursor of a #ClutterText actor.
     */
    getCursorSize(): number
    /**
     * Retrieves whether the cursor of a #ClutterText actor is visible.
     */
    getCursorVisible(): boolean
    /**
     * Retrieves whether a #ClutterText is editable or not.
     */
    getEditable(): boolean
    /**
     * Returns the ellipsizing position of a #ClutterText actor, as
     * set by clutter_text_set_ellipsize().
     */
    getEllipsize(): Pango.EllipsizeMode
    /**
     * Retrieves the #PangoFontDescription used by `self`
     */
    getFontDescription(): Pango.FontDescription
    /**
     * Retrieves the font name as set by clutter_text_set_font_name().
     */
    getFontName(): string
    /**
     * Retrieves whether the #ClutterText actor should justify its contents
     * on both margins.
     */
    getJustify(): boolean
    /**
     * Retrieves the current #PangoLayout used by a #ClutterText actor.
     */
    getLayout(): Pango.Layout
    /**
     * Obtains the coordinates where the #ClutterText will draw the #PangoLayout
     * representing the text.
     */
    getLayoutOffsets(): [ /* x */ number, /* y */ number ]
    /**
     * Retrieves the alignment of a #ClutterText, as set by
     * clutter_text_set_line_alignment().
     */
    getLineAlignment(): Pango.Alignment
    /**
     * Retrieves the value set using clutter_text_set_line_wrap().
     */
    getLineWrap(): boolean
    /**
     * Retrieves the line wrap mode used by the #ClutterText actor.
     * 
     * See clutter_text_set_line_wrap_mode ().
     */
    getLineWrapMode(): Pango.WrapMode
    /**
     * Gets the maximum length of text that can be set into a text actor.
     * 
     * See clutter_text_set_max_length().
     */
    getMaxLength(): number
    /**
     * Retrieves the character to use in place of the actual text
     * as set by clutter_text_set_password_char().
     */
    getPasswordChar(): number
    /**
     * Retrieves whether a #ClutterText is selectable or not.
     */
    getSelectable(): boolean
    /**
     * Retrieves the color of selected text of a #ClutterText actor.
     */
    getSelectedTextColor(): /* color */ Color
    /**
     * Retrieves the currently selected text.
     */
    getSelection(): string
    /**
     * Retrieves the other end of the selection of a #ClutterText actor,
     * in characters from the current cursor position.
     */
    getSelectionBound(): number
    /**
     * Retrieves the color of the selection of a #ClutterText actor.
     */
    getSelectionColor(): /* color */ Color
    /**
     * Retrieves whether the #ClutterText actor is in single line mode.
     */
    getSingleLineMode(): boolean
    /**
     * Retrieves a pointer to the current contents of a #ClutterText
     * actor.
     * 
     * If you need a copy of the contents for manipulating, either
     * use g_strdup() on the returned string, or use:
     * 
     * |[
     *    copy = clutter_text_get_chars (text, 0, -1);
     * ```
     * 
     * 
     * Which will return a newly allocated string.
     * 
     * If the #ClutterText actor is empty, this function will return
     * an empty string, and not %NULL.
     */
    getText(): string
    /**
     * Retrieves whether the contents of the #ClutterText actor should be
     * parsed for the Pango text markup.
     */
    getUseMarkup(): boolean
    /**
     * Inserts `text` into a #ClutterActor at the given position.
     * 
     * If `position` is a negative number, the text will be appended
     * at the end of the current contents of the #ClutterText.
     * 
     * The position is expressed in characters, not in bytes.
     */
    insertText(text: string, position: number): void
    /**
     * Inserts `wc` at the current cursor position of a
     * #ClutterText actor.
     */
    insertUnichar(wc: number): void
    /**
     * Retrieves the coordinates of the given `position`.
     */
    positionToCoords(position: number): [ /* returnType */ boolean, /* x */ number, /* y */ number, /* lineHeight */ number ]
    /**
     * Sets whether a #ClutterText actor should be activatable.
     * 
     * An activatable #ClutterText actor will emit the #ClutterText::activate
     * signal whenever the 'Enter' (or 'Return') key is pressed; if it is not
     * activatable, a new line will be appended to the current content.
     * 
     * An activatable #ClutterText must also be set as editable using
     * clutter_text_set_editable().
     */
    setActivatable(activatable: boolean): void
    /**
     * Sets the attributes list that are going to be applied to the
     * #ClutterText contents.
     * 
     * The #ClutterText actor will take a reference on the #PangoAttrList
     * passed to this function.
     */
    setAttributes(attrs?: Pango.AttrList | null): void
    /**
     * Set the #ClutterTextBuffer object which holds the text for
     * this widget.
     */
    setBuffer(buffer: TextBuffer): void
    /**
     * Sets the color of the contents of a #ClutterText actor.
     * 
     * The overall opacity of the #ClutterText actor will be the
     * result of the alpha value of `color` and the composited
     * opacity of the actor itself on the scenegraph, as returned
     * by clutter_actor_get_paint_opacity().
     */
    setColor(color: Color): void
    /**
     * Sets the color of the cursor of a #ClutterText actor.
     * 
     * If `color` is %NULL, the cursor color will be the same as the
     * text color.
     */
    setCursorColor(color?: Color | null): void
    /**
     * Sets the cursor of a #ClutterText actor at `position`.
     * 
     * The position is expressed in characters, not in bytes.
     */
    setCursorPosition(position: number): void
    /**
     * Sets the size of the cursor of a #ClutterText. The cursor
     * will only be visible if the #ClutterText:cursor-visible property
     * is set to %TRUE.
     */
    setCursorSize(size: number): void
    /**
     * Sets whether the cursor of a #ClutterText actor should be
     * visible or not.
     * 
     * The color of the cursor will be the same as the text color
     * unless clutter_text_set_cursor_color() has been called.
     * 
     * The size of the cursor can be set using clutter_text_set_cursor_size().
     * 
     * The position of the cursor can be changed programmatically using
     * clutter_text_set_cursor_position().
     */
    setCursorVisible(cursorVisible: boolean): void
    /**
     * Sets whether the #ClutterText actor should be editable.
     * 
     * An editable #ClutterText with key focus set using
     * clutter_actor_grab_key_focus() or clutter_stage_set_key_focus()
     * will receive key events and will update its contents accordingly.
     */
    setEditable(editable: boolean): void
    /**
     * Sets the mode used to ellipsize (add an ellipsis: "...") to the
     * text if there is not enough space to render the entire contents
     * of a #ClutterText actor
     */
    setEllipsize(mode: Pango.EllipsizeMode): void
    /**
     * Sets `font_desc` as the font description for a #ClutterText
     * 
     * The #PangoFontDescription is copied by the #ClutterText actor
     * so you can safely call pango_font_description_free() on it after
     * calling this function.
     */
    setFontDescription(fontDesc: Pango.FontDescription): void
    /**
     * Sets the font used by a #ClutterText. The `font_name` string
     * must either be %NULL, which means that the font name from the
     * default #ClutterBackend will be used; or be something that can
     * be parsed by the pango_font_description_from_string() function,
     * like:
     * 
     * |[
     *   // Set the font to the system's Sans, 10 points
     *   clutter_text_set_font_name (text, "Sans 10");
     * 
     *   // Set the font to the system's Serif, 16 pixels
     *   clutter_text_set_font_name (text, "Serif 16px");
     * 
     *   // Set the font to Helvetica, 10 points
     *   clutter_text_set_font_name (text, "Helvetica 10");
     * ```
     * 
     */
    setFontName(fontName?: string | null): void
    /**
     * Sets whether the text of the #ClutterText actor should be justified
     * on both margins. This setting is ignored if Clutter is compiled
     * against Pango &lt; 1.18.
     */
    setJustify(justify: boolean): void
    /**
     * Sets the way that the lines of a wrapped label are aligned with
     * respect to each other. This does not affect the overall alignment
     * of the label within its allocated or specified width.
     * 
     * To align a #ClutterText actor you should add it to a container
     * that supports alignment, or use the anchor point.
     */
    setLineAlignment(alignment: Pango.Alignment): void
    /**
     * Sets whether the contents of a #ClutterText actor should wrap,
     * if they don't fit the size assigned to the actor.
     */
    setLineWrap(lineWrap: boolean): void
    /**
     * If line wrapping is enabled (see clutter_text_set_line_wrap()) this
     * function controls how the line wrapping is performed. The default is
     * %PANGO_WRAP_WORD which means wrap on word boundaries.
     */
    setLineWrapMode(wrapMode: Pango.WrapMode): void
    /**
     * Sets `markup` as the contents of a #ClutterText.
     * 
     * This is a convenience function for setting a string containing
     * Pango markup, and it is logically equivalent to:
     * 
     * |[
     *   /&ast; the order is important &ast;/
     *   clutter_text_set_text (CLUTTER_TEXT (actor), markup);
     *   clutter_text_set_use_markup (CLUTTER_TEXT (actor), TRUE);
     * ```
     * 
     */
    setMarkup(markup?: string | null): void
    /**
     * Sets the maximum allowed length of the contents of the actor. If the
     * current contents are longer than the given length, then they will be
     * truncated to fit.
     */
    setMaxLength(max: number): void
    /**
     * Sets the character to use in place of the actual text in a
     * password text actor.
     * 
     * If `wc` is 0 the text will be displayed as it is entered in the
     * #ClutterText actor.
     */
    setPasswordChar(wc: number): void
    /**
     * Sets, or unsets, the pre-edit string. This function is useful
     * for input methods to display a string (with eventual specific
     * Pango attributes) before it is entered inside the #ClutterText
     * buffer.
     * 
     * The preedit string and attributes are ignored if the #ClutterText
     * actor is not editable.
     * 
     * This function should not be used by applications
     */
    setPreeditString(preeditStr: string | null, preeditAttrs: Pango.AttrList | null, cursorPos: number): void
    /**
     * Sets whether a #ClutterText actor should be selectable.
     * 
     * A selectable #ClutterText will allow selecting its contents using
     * the pointer or the keyboard.
     */
    setSelectable(selectable: boolean): void
    /**
     * Sets the selected text color of a #ClutterText actor.
     * 
     * If `color` is %NULL, the selected text color will be the same as the
     * selection color, which then falls back to cursor, and then text color.
     */
    setSelectedTextColor(color?: Color | null): void
    /**
     * Selects the region of text between `start_pos` and `end_pos`.
     * 
     * This function changes the position of the cursor to match
     * `start_pos` and the selection bound to match `end_pos`.
     */
    setSelection(startPos: number, endPos: number): void
    /**
     * Sets the other end of the selection, starting from the current
     * cursor position.
     * 
     * If `selection_bound` is -1, the selection unset.
     */
    setSelectionBound(selectionBound: number): void
    /**
     * Sets the color of the selection of a #ClutterText actor.
     * 
     * If `color` is %NULL, the selection color will be the same as the
     * cursor color, or if no cursor color is set either then it will be
     * the same as the text color.
     */
    setSelectionColor(color?: Color | null): void
    /**
     * Sets whether a #ClutterText actor should be in single line mode
     * or not. Only editable #ClutterText<!-- -->s can be in single line
     * mode.
     * 
     * A text actor in single line mode will not wrap text and will clip
     * the visible area to the predefined size. The contents of the
     * text actor will scroll to display the end of the text if its length
     * is bigger than the allocated width.
     * 
     * When setting the single line mode the #ClutterText:activatable
     * property is also set as a side effect. Instead of entering a new
     * line character, the text actor will emit the #ClutterText::activate
     * signal.
     */
    setSingleLineMode(singleLine: boolean): void
    /**
     * Sets the contents of a #ClutterText actor.
     * 
     * If the #ClutterText:use-markup property was set to %TRUE it
     * will be reset to %FALSE as a side effect. If you want to
     * maintain the #ClutterText:use-markup you should use the
     * clutter_text_set_markup() function instead
     */
    setText(text?: string | null): void
    /**
     * Sets whether the contents of the #ClutterText actor contains markup
     * in <link linkend="PangoMarkupFormat">Pango's text markup language</link>.
     * 
     * Setting #ClutterText:use-markup on an editable #ClutterText will
     * not have any effect except hiding the markup.
     * 
     * See also #ClutterText:use-markup.
     */
    setUseMarkup(setting: boolean): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Text */
    /**
     * The ::activate signal is emitted each time the actor is 'activated'
     * by the user, normally by pressing the 'Enter' key. The signal is
     * emitted only if #ClutterText:activatable is set to %TRUE.
     */
    connect(sigName: "activate", callback: (() => void)): number
    on(sigName: "activate", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "activate", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "activate", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "activate"): void
    /**
     * The ::cursor-changed signal is emitted whenever the cursor
     * position or size changes.
     */
    connect(sigName: "cursor-changed", callback: (() => void)): number
    on(sigName: "cursor-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "cursor-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "cursor-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "cursor-changed"): void
    /**
     * The ::cursor-event signal is emitted whenever the cursor position
     * changes inside a #ClutterText actor. Inside `geometry` it is stored
     * the current position and size of the cursor, relative to the actor
     * itself.
     */
    connect(sigName: "cursor-event", callback: ((geometry: Geometry) => void)): number
    on(sigName: "cursor-event", callback: (geometry: Geometry) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "cursor-event", callback: (geometry: Geometry) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "cursor-event", callback: (geometry: Geometry) => void): NodeJS.EventEmitter
    emit(sigName: "cursor-event", geometry: Geometry): void
    /**
     * This signal is emitted when text is deleted from the actor by
     * the user. It is emitted before `self` text changes.
     */
    connect(sigName: "delete-text", callback: ((startPos: number, endPos: number) => void)): number
    on(sigName: "delete-text", callback: (startPos: number, endPos: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "delete-text", callback: (startPos: number, endPos: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "delete-text", callback: (startPos: number, endPos: number) => void): NodeJS.EventEmitter
    emit(sigName: "delete-text", startPos: number, endPos: number): void
    /**
     * This signal is emitted when text is inserted into the actor by
     * the user. It is emitted before `self` text changes.
     */
    connect(sigName: "insert-text", callback: ((newText: string, newTextLength: number, position?: object | null) => void)): number
    on(sigName: "insert-text", callback: (newText: string, newTextLength: number, position?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "insert-text", callback: (newText: string, newTextLength: number, position?: object | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "insert-text", callback: (newText: string, newTextLength: number, position?: object | null) => void): NodeJS.EventEmitter
    emit(sigName: "insert-text", newText: string, newTextLength: number, position?: object | null): void
    /**
     * The ::text-changed signal is emitted after `actor'`s text changes
     */
    connect(sigName: "text-changed", callback: (() => void)): number
    on(sigName: "text-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "text-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "text-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "text-changed"): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::activatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::activatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::activatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::activatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::activatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::attributes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::attributes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::buffer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::buffer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::buffer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::buffer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::buffer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cursor-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cursor-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cursor-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cursor-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cursor-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cursor-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cursor-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cursor-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cursor-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cursor-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cursor-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cursor-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cursor-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cursor-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cursor-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cursor-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cursor-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cursor-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cursor-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cursor-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cursor-visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cursor-visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cursor-visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cursor-visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cursor-visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::editable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::editable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::editable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::editable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::editable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::ellipsize", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ellipsize", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::ellipsize", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::ellipsize", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::ellipsize", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::font-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::font-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::font-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::font-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::font-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::justify", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::justify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::justify", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::justify", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::justify", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::line-alignment", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::line-alignment", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::line-alignment", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::line-alignment", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::line-alignment", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::line-wrap", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::line-wrap", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::line-wrap", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::line-wrap", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::line-wrap", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::line-wrap-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::line-wrap-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::line-wrap-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::line-wrap-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::line-wrap-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::max-length", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-length", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::max-length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::max-length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::max-length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-char", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-char", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-char", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-char", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-char", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::selectable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::selectable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::selectable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::selectable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::selectable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::selected-text-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::selected-text-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::selected-text-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::selected-text-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::selected-text-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::selected-text-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::selected-text-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::selected-text-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::selected-text-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::selected-text-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::selection-bound", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::selection-bound", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::selection-bound", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::selection-bound", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::selection-bound", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::selection-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::selection-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::selection-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::selection-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::selection-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::selection-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::selection-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::selection-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::selection-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::selection-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::single-line-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::single-line-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::single-line-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::single-line-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::single-line-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::use-markup", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-markup", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::use-markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::use-markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::use-markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Text_ConstructProps)
    _init (config?: Text_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Text
    static newFull(fontName: string, text: string, color: Color): Text
    static newWithBuffer(buffer: TextBuffer): Text
    static newWithText(fontName: string | null, text: string): Text
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
interface TextBuffer_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.TextBuffer */
    /**
     * The maximum length (in characters) of the text in the buffer.
     */
    maxLength?: number
}
class TextBuffer {
    /* Properties of Clutter-1.0.Clutter.TextBuffer */
    /**
     * The length (in characters) of the text in buffer.
     */
    readonly length: number
    /**
     * The maximum length (in characters) of the text in the buffer.
     */
    maxLength: number
    /**
     * The contents of the buffer.
     */
    readonly text: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.TextBuffer */
    /**
     * Deletes a sequence of characters from the buffer. `n_chars` characters are
     * deleted starting at `position`. If `n_chars` is negative, then all characters
     * until the end of the text are deleted.
     * 
     * If `position` or `n_chars` are out of bounds, then they are coerced to sane
     * values.
     * 
     * Note that the positions are specified in characters, not bytes.
     */
    deleteText(position: number, nChars: number): number
    /**
     * Emits the #ClutterTextBuffer::deleted-text signal on `buffer`.
     * 
     * Used when subclassing #ClutterTextBuffer
     */
    emitDeletedText(position: number, nChars: number): void
    /**
     * Emits the #ClutterTextBuffer::inserted-text signal on `buffer`.
     * 
     * Used when subclassing #ClutterTextBuffer
     */
    emitInsertedText(position: number, chars: string, nChars: number): void
    /**
     * Retrieves the length in bytes of the buffer.
     * See clutter_text_buffer_get_length().
     */
    getBytes(): number
    /**
     * Retrieves the length in characters of the buffer.
     */
    getLength(): number
    /**
     * Retrieves the maximum allowed length of the text in
     * `buffer`. See clutter_text_buffer_set_max_length().
     */
    getMaxLength(): number
    /**
     * Retrieves the contents of the buffer.
     * 
     * The memory pointer returned by this call will not change
     * unless this object emits a signal, or is finalized.
     */
    getText(): string
    /**
     * Inserts `n_chars` characters of `chars` into the contents of the
     * buffer, at position `position`.
     * 
     * If `n_chars` is negative, then characters from chars will be inserted
     * until a null-terminator is found. If `position` or `n_chars` are out of
     * bounds, or the maximum buffer text length is exceeded, then they are
     * coerced to sane values.
     * 
     * Note that the position and length are in characters, not in bytes.
     */
    insertText(position: number, chars: string, nChars: number): number
    /**
     * Sets the maximum allowed length of the contents of the buffer. If
     * the current contents are longer than the given length, then they
     * will be truncated to fit.
     */
    setMaxLength(maxLength: number): void
    /**
     * Sets the text in the buffer.
     * 
     * This is roughly equivalent to calling clutter_text_buffer_delete_text()
     * and clutter_text_buffer_insert_text().
     * 
     * Note that `n_chars` is in characters, not in bytes.
     */
    setText(chars: string, nChars: number): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.TextBuffer */
    /**
     * This signal is emitted after text is deleted from the buffer.
     */
    connect(sigName: "deleted-text", callback: ((position: number, nChars: number) => void)): number
    on(sigName: "deleted-text", callback: (position: number, nChars: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "deleted-text", callback: (position: number, nChars: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "deleted-text", callback: (position: number, nChars: number) => void): NodeJS.EventEmitter
    emit(sigName: "deleted-text", position: number, nChars: number): void
    /**
     * This signal is emitted after text is inserted into the buffer.
     */
    connect(sigName: "inserted-text", callback: ((position: number, chars: string, nChars: number) => void)): number
    on(sigName: "inserted-text", callback: (position: number, chars: string, nChars: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "inserted-text", callback: (position: number, chars: string, nChars: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "inserted-text", callback: (position: number, chars: string, nChars: number) => void): NodeJS.EventEmitter
    emit(sigName: "inserted-text", position: number, chars: string, nChars: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::length", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::length", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::max-length", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-length", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::max-length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::max-length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::max-length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TextBuffer_ConstructProps)
    _init (config?: TextBuffer_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TextBuffer
    static newWithText(text: string | null, textLen: number): TextBuffer
    static $gtype: GObject.Type
}
class TextNode {
    /* Methods of Clutter-1.0.Clutter.PaintNode */
    /**
     * Adds `child` to the list of children of `node`.
     * 
     * This function will acquire a reference on `child`.
     */
    addChild(child: PaintNode): void
    /**
     * Adds a rectangle region to the `node,` as described by the
     * passed `rect`.
     */
    addRectangle(rect: ActorBox): void
    /**
     * Adds a rectangle region to the `node,` with texture coordinates.
     */
    addTextureRectangle(rect: ActorBox, x1: number, y1: number, x2: number, y2: number): void
    /**
     * Acquires a reference on `node`.
     */
    ref(): PaintNode
    /**
     * Sets a user-readable `name` for `node`.
     * 
     * The `name` will be used for debugging purposes.
     * 
     * The `node` will copy the passed string.
     */
    setName(name: string): void
    /**
     * Releases a reference on `node`.
     */
    unref(): void
    static name: string
    static new(layout?: Pango.Layout | null, color?: Color | null): TextNode
    constructor(layout?: Pango.Layout | null, color?: Color | null)
    /* Static methods and pseudo-constructors */
    static new(layout?: Pango.Layout | null, color?: Color | null): TextNode
}
interface Texture_ConstructProps extends Actor_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Texture */
    disableSlicing?: boolean
    /**
     * The path of the file containing the image data to be displayed by
     * the texture.
     * 
     * This property is unset when using the clutter_texture_set_from_*_data()
     * family of functions.
     */
    filename?: string
    filterQuality?: TextureQuality
    keepAspectRatio?: boolean
    /**
     * Tries to load a texture from a filename by using a local thread to perform
     * the read operations. The initially created texture has dimensions 0x0 when
     * the true size becomes available the #ClutterTexture::size-change signal is
     * emitted and when the image has completed loading the
     * #ClutterTexture::load-finished signal is emitted.
     * 
     * Threading is only enabled if g_thread_init() has been called prior to
     * clutter_init(), otherwise #ClutterTexture will use the main loop to load
     * the image.
     * 
     * The upload of the texture data on the GL pipeline is not asynchronous, as
     * it must be performed from within the same thread that called
     * clutter_main().
     */
    loadAsync?: boolean
    /**
     * Like #ClutterTexture:load-async but loads the width and height
     * synchronously causing some blocking.
     */
    loadDataAsync?: boolean
    pickWithAlpha?: boolean
    repeatX?: boolean
    repeatY?: boolean
    syncSize?: boolean
}
class Texture {
    /* Properties of Clutter-1.0.Clutter.Texture */
    /**
     * The path of the file containing the image data to be displayed by
     * the texture.
     * 
     * This property is unset when using the clutter_texture_set_from_*_data()
     * family of functions.
     */
    filename: string
    filterQuality: TextureQuality
    keepAspectRatio: boolean
    /**
     * Tries to load a texture from a filename by using a local thread to perform
     * the read operations. The initially created texture has dimensions 0x0 when
     * the true size becomes available the #ClutterTexture::size-change signal is
     * emitted and when the image has completed loading the
     * #ClutterTexture::load-finished signal is emitted.
     * 
     * Threading is only enabled if g_thread_init() has been called prior to
     * clutter_init(), otherwise #ClutterTexture will use the main loop to load
     * the image.
     * 
     * The upload of the texture data on the GL pipeline is not asynchronous, as
     * it must be performed from within the same thread that called
     * clutter_main().
     */
    loadAsync: boolean
    /**
     * Like #ClutterTexture:load-async but loads the width and height
     * synchronously causing some blocking.
     */
    loadDataAsync: boolean
    pickWithAlpha: boolean
    readonly pixelFormat: Cogl.PixelFormat
    repeatX: boolean
    repeatY: boolean
    syncSize: boolean
    readonly tileWaste: number
    /* Properties of Clutter-1.0.Clutter.Actor */
    /**
     * Adds a #ClutterAction to the actor
     */
    actions: Action
    /**
     * The allocation for the actor, in pixels
     * 
     * This is property is read-only, but you might monitor it to know when an
     * actor moves or resizes
     */
    readonly allocation: ActorBox
    /**
     * The anchor point expressed as a #ClutterGravity
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorGravity: Gravity
    /**
     * The X coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels.
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorX: number
    /**
     * The Y coordinate of an actor's anchor point, relative to
     * the actor coordinate space, in pixels
     * 
     * It is highly recommended not to use #ClutterActor:anchor-x,
     * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
     * written code; the anchor point adds an additional translation that
     * will affect the actor's relative position with regards to its
     * parent, as well as the position of its children. This change needs
     * to always be taken into account when positioning the actor. It is
     * recommended to use the #ClutterActor:pivot-point property instead,
     * as it will affect only the transformations.
     */
    anchorY: number
    /**
     * Paints a solid fill of the actor's allocation using the specified
     * color.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    backgroundColor: Color
    /**
     * Whether the #ClutterActor:background-color property has been set.
     */
    readonly backgroundColorSet: boolean
    /**
     * Applies a transformation matrix on each child of an actor.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:child-transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:child-transform-set property to %FALSE.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    childTransform: Matrix
    /**
     * Whether the #ClutterActor:child-transform property is set.
     */
    readonly childTransformSet: boolean
    /**
     * The visible region of the actor, in actor-relative coordinates
     */
    clip: Geometry
    /**
     * The visible region of the actor, in actor-relative coordinates,
     * expressed as a #ClutterRect.
     * 
     * Setting this property to %NULL will unset the existing clip.
     * 
     * Setting this property will change the #ClutterActor:has-clip
     * property as a side effect.
     */
    clipRect: Rect
    /**
     * Whether the clip region should track the allocated area
     * of the actor.
     * 
     * This property is ignored if a clip area has been explicitly
     * set using clutter_actor_set_clip().
     */
    clipToAllocation: boolean
    /**
     * Adds a #ClutterConstraint to the actor
     */
    constraints: Constraint
    /**
     * The #ClutterContent implementation that controls the content
     * of the actor.
     */
    content: Content
    /**
     * The bounding box for the #ClutterContent used by the actor.
     * 
     * The value of this property is controlled by the #ClutterActor:allocation
     * and #ClutterActor:content-gravity properties of #ClutterActor.
     * 
     * The bounding box for the content is guaranteed to never exceed the
     * allocation's of the actor.
     */
    readonly contentBox: ActorBox
    /**
     * The alignment that should be honoured by the #ClutterContent
     * set with the #ClutterActor:content property.
     * 
     * Changing the value of this property will change the bounding box of
     * the content; you can use the #ClutterActor:content-box property to
     * get the position and size of the content within the actor's
     * allocation.
     * 
     * This property is meaningful only for #ClutterContent implementations
     * that have a preferred size, and if the preferred size is smaller than
     * the actor's allocation.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    contentGravity: ContentGravity
    /**
     * The repeat policy for the actor's #ClutterActor:content.
     */
    contentRepeat: ContentRepeat
    /**
     * The position of the actor on the Z axis.
     * 
     * The #ClutterActor:depth property is relative to the parent's
     * modelview matrix.
     * 
     * Setting this property will call #ClutterContainerIface.sort_depth_order()
     * which is usually a no-op, and it's most likely not what you want.
     * 
     * The #ClutterActor:depth property is animatable.
     */
    depth: number
    /**
     * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
     */
    effect: Effect
    /**
     * The actor's first child.
     */
    readonly firstChild: Actor
    /**
     * This flag controls whether the #ClutterActor:fixed-x and
     * #ClutterActor:fixed-y properties are used
     */
    fixedPositionSet: boolean
    /**
     * The fixed X position of the actor in pixels.
     * 
     * Writing this property sets #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedX: number
    /**
     * The fixed Y position of the actor in pixels.
     * 
     * Writing this property sets the #ClutterActor:fixed-position-set
     * property as well, as a side effect
     */
    fixedY: number
    /**
     * Whether the actor has the #ClutterActor:clip property set or not
     */
    readonly hasClip: boolean
    /**
     * Whether the actor contains the pointer of a #ClutterInputDevice
     * or not.
     */
    readonly hasPointer: boolean
    /**
     * Height of the actor (in pixels).  If written, forces the minimum and
     * natural size request of the actor to the given height. If read, returns
     * the allocated height if available, otherwise the height request.
     * 
     * The #ClutterActor:height property is animatable.
     */
    height: number
    /**
     * The actor's last child.
     */
    readonly lastChild: Actor
    /**
     * A delegate object for controlling the layout of the children of
     * an actor.
     */
    layoutManager: LayoutManager
    magnificationFilter: ScalingFilter
    /**
     * Whether the actor is mapped (will be painted when the stage
     * to which it belongs is mapped)
     */
    readonly mapped: boolean
    /**
     * The margin (in pixels) from the bottom of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    marginBottom: number
    /**
     * The margin (in pixels) from the left of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    marginLeft: number
    /**
     * The margin (in pixels) from the right of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    marginRight: number
    /**
     * The margin (in pixels) from the top of the actor.
     * 
     * This property adds a margin to the actor's preferred size; the margin
     * will be automatically taken into account when allocating the actor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    marginTop: number
    /**
     * A forced minimum height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-height-set property
     * as well, as a side effect. This property overrides the usual height
     * request of the actor.
     */
    minHeight: number
    /**
     * This flag controls whether the #ClutterActor:min-height property
     * is used
     */
    minHeightSet: boolean
    /**
     * A forced minimum width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:min-width-set property
     * as well, as a side effect.
     * 
     * This property overrides the usual width request of the actor.
     */
    minWidth: number
    /**
     * This flag controls whether the #ClutterActor:min-width property
     * is used
     */
    minWidthSet: boolean
    minificationFilter: ScalingFilter
    /**
     * The name of the actor
     */
    name: string
    /**
     * A forced natural height request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-height-set
     * property as well, as a side effect. This property overrides the
     * usual height request of the actor
     */
    naturalHeight: number
    /**
     * This flag controls whether the #ClutterActor:natural-height property
     * is used
     */
    naturalHeightSet: boolean
    /**
     * A forced natural width request for the actor, in pixels
     * 
     * Writing this property sets the #ClutterActor:natural-width-set
     * property as well, as a side effect. This property overrides the
     * usual width request of the actor
     */
    naturalWidth: number
    /**
     * This flag controls whether the #ClutterActor:natural-width property
     * is used
     */
    naturalWidthSet: boolean
    /**
     * Determines the conditions in which the actor will be redirected
     * to an offscreen framebuffer while being painted. For example this
     * can be used to cache an actor in a framebuffer or for improved
     * handling of transparent actors. See
     * clutter_actor_set_offscreen_redirect() for details.
     */
    offscreenRedirect: OffscreenRedirect
    /**
     * Opacity of an actor, between 0 (fully transparent) and
     * 255 (fully opaque)
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    opacity: number
    /**
     * The point around which the scaling and rotation transformations occur.
     * 
     * The pivot point is expressed in normalized coordinates space, with (0, 0)
     * being the top left corner of the actor and (1, 1) the bottom right corner
     * of the actor.
     * 
     * The default pivot point is located at (0, 0).
     * 
     * The #ClutterActor:pivot-point property is animatable.
     */
    pivotPoint: Point
    /**
     * The Z component of the #ClutterActor:pivot-point, expressed as a value
     * along the Z axis.
     * 
     * The #ClutterActor:pivot-point-z property is animatable.
     */
    pivotPointZ: number
    /**
     * The position of the origin of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:x and #ClutterActor:y properties at the same
     * time.
     * 
     * The #ClutterActor:position property is animatable.
     */
    position: Point
    /**
     * Whether the actor is reactive to events or not
     * 
     * Only reactive actors will emit event-related signals
     */
    reactive: boolean
    /**
     * Whether the actor has been realized
     */
    readonly realized: boolean
    /**
     * Request mode for the #ClutterActor. The request mode determines the
     * type of geometry management used by the actor, either height for width
     * (the default) or width for height.
     * 
     * For actors implementing height for width, the parent container should get
     * the preferred width first, and then the preferred height for that width.
     * 
     * For actors implementing width for height, the parent container should get
     * the preferred height first, and then the preferred width for that height.
     * 
     * For instance:
     * 
     * 
     * ```c
     *   ClutterRequestMode mode;
     *   gfloat natural_width, min_width;
     *   gfloat natural_height, min_height;
     * 
     *   mode = clutter_actor_get_request_mode (child);
     *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (child, -1,
     *                                          &min_width,
     *                                          &natural_width);
     *       clutter_actor_get_preferred_height (child, natural_width,
     *                                           &min_height,
     *                                           &natural_height);
     *     }
     *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (child, -1,
     *                                           &min_height,
     *                                           &natural_height);
     *       clutter_actor_get_preferred_width (child, natural_height,
     *                                          &min_width,
     *                                          &natural_width);
     *     }
     *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       ClutterContent *content = clutter_actor_get_content (child);
     * 
     *       min_width, min_height = 0;
     *       natural_width = natural_height = 0;
     * 
     *       if (content != NULL)
     *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     *     }
     * ```
     * 
     * 
     * will retrieve the minimum and natural width and height depending on the
     * preferred request mode of the #ClutterActor "child".
     * 
     * The clutter_actor_get_preferred_size() function will implement this
     * check for you.
     */
    requestMode: RequestMode
    /**
     * The rotation angle on the X axis.
     * 
     * The #ClutterActor:rotation-angle-x property is animatable.
     */
    rotationAngleX: number
    /**
     * The rotation angle on the Y axis
     * 
     * The #ClutterActor:rotation-angle-y property is animatable.
     */
    rotationAngleY: number
    /**
     * The rotation angle on the Z axis
     * 
     * The #ClutterActor:rotation-angle-z property is animatable.
     */
    rotationAngleZ: number
    /**
     * The rotation center on the X axis.
     */
    rotationCenterX: Vertex
    /**
     * The rotation center on the Y axis.
     */
    rotationCenterY: Vertex
    /**
     * The rotation center on the Z axis.
     */
    rotationCenterZ: Vertex
    /**
     * The rotation center on the Z axis expressed as a #ClutterGravity.
     */
    rotationCenterZGravity: Gravity
    /**
     * The horizontal center point for scaling
     */
    scaleCenterX: number
    /**
     * The vertical center point for scaling
     */
    scaleCenterY: number
    /**
     * The center point for scaling expressed as a #ClutterGravity
     */
    scaleGravity: Gravity
    /**
     * The horizontal scale of the actor.
     * 
     * The #ClutterActor:scale-x property is animatable.
     */
    scaleX: number
    /**
     * The vertical scale of the actor.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleY: number
    /**
     * The scale factor of the actor along the Z axis.
     * 
     * The #ClutterActor:scale-y property is animatable.
     */
    scaleZ: number
    /**
     * If %TRUE, the actor is automatically shown when parented.
     * 
     * Calling clutter_actor_hide() on an actor which has not been
     * parented will set this property to %FALSE as a side effect.
     */
    showOnSetParent: boolean
    /**
     * The size of the actor.
     * 
     * This property is a shorthand for setting and getting the
     * #ClutterActor:width and #ClutterActor:height at the same time.
     * 
     * The #ClutterActor:size property is animatable.
     */
    size: Size
    /**
     * The direction of the text inside a #ClutterActor.
     */
    textDirection: TextDirection
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix.
     * 
     * The matrix specified by the #ClutterActor:transform property is
     * applied to the actor and its children relative to the actor's
     * #ClutterActor:allocation and #ClutterActor:pivot-point.
     * 
     * Application code should rarely need to use this function directly.
     * 
     * Setting this property with a #ClutterMatrix will set the
     * #ClutterActor:transform-set property to %TRUE as a side effect;
     * setting this property with %NULL will set the
     * #ClutterActor:transform-set property to %FALSE.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    transform: Matrix
    /**
     * Whether the #ClutterActor:transform property is set.
     */
    readonly transformSet: boolean
    /**
     * An additional translation applied along the X axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-x property is animatable.
     */
    translationX: number
    /**
     * An additional translation applied along the Y axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-y property is animatable.
     */
    translationY: number
    /**
     * An additional translation applied along the Z axis, relative
     * to the actor's #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:translation-z property is animatable.
     */
    translationZ: number
    /**
     * Whether the actor is set to be visible or not
     * 
     * See also #ClutterActor:mapped
     */
    visible: boolean
    /**
     * Width of the actor (in pixels). If written, forces the minimum and
     * natural size request of the actor to the given width. If read, returns
     * the allocated width if available, otherwise the width request.
     * 
     * The #ClutterActor:width property is animatable.
     */
    width: number
    /**
     * X coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor. If read, returns the fixed position if any,
     * otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:x property is animatable.
     */
    x: number
    /**
     * The alignment of an actor on the X axis, if the actor has been given
     * extra space for its allocation. See also the #ClutterActor:x-expand
     * property.
     */
    xAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the X axis.
     */
    xExpand: boolean
    /**
     * Y coordinate of the actor in pixels. If written, forces a fixed
     * position for the actor.  If read, returns the fixed position if
     * any, otherwise the allocation if available, otherwise 0.
     * 
     * The #ClutterActor:y property is animatable.
     */
    y: number
    /**
     * The alignment of an actor on the Y axis, if the actor has been given
     * extra space for its allocation.
     */
    yAlign: ActorAlign
    /**
     * Whether a layout manager should assign more space to the actor on
     * the Y axis.
     */
    yExpand: boolean
    /**
     * The actor's position on the Z axis, relative to the parent's
     * transformations.
     * 
     * Positive values will bring the actor's position nearer to the user,
     * whereas negative values will bring the actor's position farther from
     * the user.
     * 
     * The #ClutterActor:z-position does not affect the paint or allocation
     * order.
     * 
     * The #ClutterActor:z-position property is animatable.
     */
    zPosition: number
    /* Fields of Clutter-1.0.Clutter.Actor */
    /**
     * #ClutterActorFlags
     */
    readonly flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Texture */
    /**
     * Gets the size in pixels of the untransformed underlying image
     */
    getBaseSize(): [ /* width */ number, /* height */ number ]
    /**
     * Returns a handle to the underlying COGL material used for drawing
     * the actor.
     */
    getCoglMaterial(): Cogl.Handle
    /**
     * Retrieves the handle to the underlying COGL texture used for drawing
     * the actor. No extra reference is taken so if you need to keep the
     * handle then you should call cogl_handle_ref() on it.
     * 
     * The texture handle returned is the first layer of the material
     * handle used by the #ClutterTexture. If you need to access the other
     * layers you should use clutter_texture_get_cogl_material() instead
     * and use the #CoglMaterial API.
     */
    getCoglTexture(): Cogl.Handle
    /**
     * Gets the filter quality used when scaling a texture.
     */
    getFilterQuality(): TextureQuality
    /**
     * Retrieves the value set using clutter_texture_set_keep_aspect_ratio()
     */
    getKeepAspectRatio(): boolean
    /**
     * Retrieves the value set using clutter_texture_set_load_async()
     */
    getLoadAsync(): boolean
    /**
     * Retrieves the value set by clutter_texture_set_load_data_async()
     */
    getLoadDataAsync(): boolean
    /**
     * Gets the maximum waste that will be used when creating a texture or
     * -1 if slicing is disabled.
     */
    getMaxTileWaste(): number
    /**
     * Retrieves the value set by clutter_texture_set_load_data_async()
     */
    getPickWithAlpha(): boolean
    /**
     * Retrieves the pixel format used by `texture`. This is
     * equivalent to:
     * 
     * |[
     *   handle = clutter_texture_get_pixel_format (texture);
     * 
     *   if (handle != COGL_INVALID_HANDLE)
     *     format = cogl_texture_get_format (handle);
     * ```
     * 
     */
    getPixelFormat(): Cogl.PixelFormat
    /**
     * Retrieves the horizontal and vertical repeat values set
     * using clutter_texture_set_repeat()
     */
    getRepeat(): [ /* repeatX */ boolean, /* repeatY */ boolean ]
    /**
     * Retrieves the value set with clutter_texture_set_sync_size()
     */
    getSyncSize(): boolean
    /**
     * Updates a sub-region of the pixel data in a #ClutterTexture.
     */
    setAreaFromRgbData(data: Uint8Array, hasAlpha: boolean, x: number, y: number, width: number, height: number, rowstride: number, bpp: number, flags: TextureFlags): boolean
    /**
     * Replaces the underlying Cogl material drawn by this actor with
     * `cogl_material`. A reference to the material is taken so if the
     * handle is no longer needed it should be deref'd with
     * cogl_handle_unref. Texture data is attached to the material so
     * calling this function also replaces the Cogl
     * texture. #ClutterTexture requires that the material have a texture
     * layer so you should set one on the material before calling this
     * function.
     */
    setCoglMaterial(coglMaterial: Cogl.Handle): void
    /**
     * Replaces the underlying COGL texture drawn by this actor with
     * `cogl_tex`. A reference to the texture is taken so if the handle is
     * no longer needed it should be deref'd with cogl_handle_unref.
     */
    setCoglTexture(coglTex: Cogl.Handle): void
    /**
     * Sets the filter quality when scaling a texture. The quality is an
     * enumeration currently the following values are supported:
     * %CLUTTER_TEXTURE_QUALITY_LOW which is fast but only uses nearest neighbour
     * interpolation. %CLUTTER_TEXTURE_QUALITY_MEDIUM which is computationally a
     * bit more expensive (bilinear interpolation), and
     * %CLUTTER_TEXTURE_QUALITY_HIGH which uses extra texture memory resources to
     * improve scaled down rendering as well (by using mipmaps). The default value
     * is %CLUTTER_TEXTURE_QUALITY_MEDIUM.
     */
    setFilterQuality(filterQuality: TextureQuality): void
    /**
     * Sets the #ClutterTexture image data from an image file. In case of
     * failure, %FALSE is returned and `error` is set.
     * 
     * If #ClutterTexture:load-async is set to %TRUE, this function
     * will return as soon as possible, and the actual image loading
     * from disk will be performed asynchronously. #ClutterTexture::size-change
     * will be emitten when the size of the texture is available and
     * #ClutterTexture::load-finished will be emitted when the image has been
     * loaded or if an error occurred.
     */
    setFromFile(filename: string): boolean
    /**
     * Sets #ClutterTexture image data.
     */
    setFromRgbData(data: Uint8Array, hasAlpha: boolean, width: number, height: number, rowstride: number, bpp: number, flags: TextureFlags): boolean
    /**
     * Sets a #ClutterTexture from YUV image data. If an error occurred,
     * %FALSE is returned and `error` is set.
     * 
     * The YUV support depends on the driver; the format supported by the
     * few drivers exposing this capability are not really useful.
     * 
     * The proper way to convert image data in any YUV colorspace to any
     * RGB colorspace is to use a fragment shader associated with the
     * #ClutterTexture material.
     */
    setFromYuvData(data: Uint8Array, width: number, height: number, flags: TextureFlags): boolean
    /**
     * Sets whether `texture` should have a preferred size maintaining
     * the aspect ratio of the underlying image
     */
    setKeepAspectRatio(keepAspect: boolean): void
    /**
     * Sets whether `texture` should use a worker thread to load the data
     * from disk asynchronously. Setting `load_async` to %TRUE will make
     * clutter_texture_set_from_file() return immediately.
     * 
     * See the #ClutterTexture:load-async property documentation, and
     * clutter_texture_set_load_data_async().
     */
    setLoadAsync(loadAsync: boolean): void
    /**
     * Sets whether `texture` should use a worker thread to load the data
     * from disk asynchronously. Setting `load_async` to %TRUE will make
     * clutter_texture_set_from_file() block until the #ClutterTexture has
     * determined the width and height of the image data.
     * 
     * See the #ClutterTexture:load-async property documentation, and
     * clutter_texture_set_load_async().
     */
    setLoadDataAsync(loadAsync: boolean): void
    /**
     * Sets whether `texture` should have it's shape defined by the alpha
     * channel when picking.
     * 
     * Be aware that this is a bit more costly than the default picking
     * due to the texture lookup, extra test against the alpha value and
     * the fact that it will also interrupt the batching of geometry done
     * internally.
     * 
     * Also there is currently no control over the threshold used to
     * determine what value of alpha is considered pickable, and so only
     * fully opaque parts of the texture will react to picking.
     */
    setPickWithAlpha(pickWithAlpha: boolean): void
    /**
     * Sets whether the `texture` should repeat horizontally or
     * vertically when the actor size is bigger than the image size
     */
    setRepeat(repeatX: boolean, repeatY: boolean): void
    /**
     * Sets whether `texture` should have the same preferred size as the
     * underlying image data.
     */
    setSyncSize(syncSize: boolean): void
    /* Methods of Clutter-1.0.Clutter.Actor */
    /**
     * Adds `action` to the list of actions applied to `self`
     * 
     * A #ClutterAction can only belong to one actor at a time
     * 
     * The #ClutterActor will hold a reference on `action` until either
     * clutter_actor_remove_action() or clutter_actor_clear_actions()
     * is called
     */
    addAction(action: Action): void
    /**
     * A convenience function for setting the name of a #ClutterAction
     * while adding it to the list of actions applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
     *   clutter_actor_add_action (self, action);
     * ```
     * 
     */
    addActionWithName(name: string, action: Action): void
    /**
     * Adds `child` to the children of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will take into consideration the #ClutterActor:depth
     * of `child,` and will keep the list of children sorted.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    addChild(child: Actor): void
    /**
     * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
     * to `self`
     * 
     * The #ClutterActor will hold a reference on the `constraint` until
     * either clutter_actor_remove_constraint() or
     * clutter_actor_clear_constraints() is called.
     */
    addConstraint(constraint: Constraint): void
    /**
     * A convenience function for setting the name of a #ClutterConstraint
     * while adding it to the list of constraints applied to `self`
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
     *   clutter_actor_add_constraint (self, constraint);
     * ```
     * 
     */
    addConstraintWithName(name: string, constraint: Constraint): void
    /**
     * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
     * 
     * The #ClutterActor will hold a reference on the `effect` until either
     * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
     * called.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect() will sink any floating reference on `effect`.
     */
    addEffect(effect: Effect): void
    /**
     * A convenience function for setting the name of a #ClutterEffect
     * while adding it to the list of effects applied to `self`.
     * 
     * Note that as #ClutterEffect is initially unowned,
     * clutter_actor_add_effect_with_name() will sink any floating
     * reference on `effect`.
     * 
     * This function is the logical equivalent of:
     * 
     * 
     * ```c
     *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
     *   clutter_actor_add_effect (self, effect);
     * ```
     * 
     */
    addEffectWithName(name: string, effect: Effect): void
    /**
     * Adds a `transition` to the #ClutterActor's list of animations.
     * 
     * The `name` string is a per-actor unique identifier of the `transition:` only
     * one #ClutterTransition can be associated to the specified `name`.
     * 
     * The `transition` will be started once added.
     * 
     * This function will take a reference on the `transition`.
     * 
     * This function is usually called implicitly when modifying an animatable
     * property.
     */
    addTransition(name: string, transition: Transition): void
    /**
     * Assigns the size of a #ClutterActor from the given `box`.
     * 
     * This function should only be called on the children of an actor when
     * overriding the #ClutterActorClass.allocate() virtual function.
     * 
     * This function will adjust the stored allocation to take into account
     * the alignment flags set in the #ClutterActor:x-align and
     * #ClutterActor:y-align properties, as well as the margin values set in
     * the #ClutterActor:margin-top, #ClutterActor:margin-right,
     * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
     * 
     * This function will respect the easing state of the #ClutterActor and
     * interpolate between the current allocation and the new one if the
     * easing state duration is a positive value.
     * 
     * Actors can know from their allocation box whether they have moved
     * with respect to their parent actor. The `flags` parameter describes
     * additional information about the allocation, for instance whether
     * the parent has moved with respect to the stage, for example because
     * a grandparent's origin has moved.
     */
    allocate(box: ActorBox, flags: AllocationFlags): void
    /**
     * Allocates `self` by taking into consideration the available allocation
     * area; an alignment factor on either axis; and whether the actor should
     * fill the allocation on either axis.
     * 
     * The `box` should contain the available allocation width and height;
     * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
     * allocation will be offset by their value.
     * 
     * This function takes into consideration the geometry request specified by
     * the #ClutterActor:request-mode property, and the text direction.
     * 
     * This function is useful for fluid layout managers using legacy alignment
     * flags. Newly written layout managers should use the #ClutterActor:x-align
     * and #ClutterActor:y-align properties, instead, and just call
     * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
     * implementation.
     */
    allocateAlignFill(box: ActorBox, xAlign: number, yAlign: number, xFill: boolean, yFill: boolean, flags: AllocationFlags): void
    /**
     * Allocates `self` taking into account the #ClutterActor's
     * preferred size, but limiting it to the maximum available width
     * and height provided.
     * 
     * This function will do the right thing when dealing with the
     * actor's request mode.
     * 
     * The implementation of this function is equivalent to:
     * 
     * 
     * ```c
     *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
     *     {
     *       clutter_actor_get_preferred_width (self, available_height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     * 
     *       clutter_actor_get_preferred_height (self, width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
     *     {
     *       clutter_actor_get_preferred_height (self, available_width,
     *                                           &min_height,
     *                                           &natural_height);
     *       height = CLAMP (natural_height, min_height, available_height);
     * 
     *       clutter_actor_get_preferred_width (self, height,
     *                                          &min_width,
     *                                          &natural_width);
     *       width = CLAMP (natural_width, min_width, available_width);
     *     }
     *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
     *     {
     *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
     * 
     *       width = CLAMP (natural_width, 0, available_width);
     *       height = CLAMP (natural_height, 0, available_height);
     *     }
     * 
     *   box.x1 = x; box.y1 = y;
     *   box.x2 = box.x1 + available_width;
     *   box.y2 = box.y1 + available_height;
     *   clutter_actor_allocate (self, &box, flags);
     * ```
     * 
     * 
     * This function can be used by fluid layout managers to allocate
     * an actor's preferred size without making it bigger than the area
     * available for the container.
     */
    allocateAvailableSize(x: number, y: number, availableWidth: number, availableHeight: number, flags: AllocationFlags): void
    /**
     * Allocates the natural size of `self`.
     * 
     * This function is a utility call for #ClutterActor implementations
     * that allocates the actor's preferred natural size. It can be used
     * by fixed layout managers (like #ClutterGroup or so called
     * 'composite actors') inside the ClutterActor::allocate
     * implementation to give each child exactly how much space it
     * requires, regardless of the size of the parent.
     * 
     * This function is not meant to be used by applications. It is also
     * not meant to be used outside the implementation of the
     * #ClutterActorClass.allocate virtual function.
     */
    allocatePreferredSize(flags: AllocationFlags): void
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite behaviour given by the passed `alpha`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing #ClutterAlpha
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_alpha(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_alpha(), this function will
     * not allow you to specify "signal::" names and callbacks.
     */
    animateWithAlphav(alpha: Alpha, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration given by `timeline` and a speed given by the `mode`.
     * 
     * See clutter_actor_animate() for further details.
     * 
     * This function is useful if you want to use an existing timeline
     * to animate `actor`.
     * 
     * This is the vector-based variant of clutter_actor_animate_with_timeline(),
     * useful for language bindings.
     * 
     * Unlike clutter_actor_animate_with_timeline(), this function
     * will not allow you to specify "signal::" names and callbacks.
     */
    animateWithTimelinev(mode: number, timeline: Timeline, properties: string[], values: any[]): Animation
    /**
     * Animates the given list of properties of `actor` between the current
     * value for each property and a new final value. The animation has a
     * definite duration and a speed given by the `mode`.
     * 
     * This is the vector-based variant of clutter_actor_animate(), useful
     * for language bindings.
     * 
     * Unlike clutter_actor_animate(), this function will not
     * allow you to specify "signal::" names and callbacks.
     */
    animatev(mode: number, duration: number, properties: string[], values: any[]): Animation
    /**
     * Transforms `point` in coordinates relative to the actor into
     * ancestor-relative coordinates using the relevant transform
     * stack (i.e. scale, rotation, etc).
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_apply_transform_to_point().
     */
    applyRelativeTransformToPoint(ancestor: Actor | null, point: Vertex): /* vertex */ Vertex
    /**
     * Transforms `point` in coordinates relative to the actor
     * into screen-relative coordinates with the current actor
     * transformation (i.e. scale, rotation, etc)
     */
    applyTransformToPoint(point: Vertex): /* vertex */ Vertex
    /**
     * Binds a #GListModel to a #ClutterActor.
     * 
     * If the #ClutterActor was already bound to a #GListModel, the previous
     * binding is destroyed.
     * 
     * The existing children of #ClutterActor are destroyed when setting a
     * model, and new children are created and added, representing the contents
     * of the `model`. The #ClutterActor is updated whenever the `model` changes.
     * If `model` is %NULL, the #ClutterActor is left empty.
     * 
     * When a #ClutterActor is bound to a model, adding and removing children
     * directly is undefined behaviour.
     */
    bindModel(model: Gio.ListModel | null, createChildFunc: ActorCreateChildFunc): void
    /**
     * Clears the list of actions applied to `self`
     */
    clearActions(): void
    /**
     * Clears the list of constraints applied to `self`
     */
    clearConstraints(): void
    /**
     * Clears the list of effects applied to `self`
     */
    clearEffects(): void
    /**
     * Determines if `descendant` is contained inside `self` (either as an
     * immediate child, or as a deeper descendant). If `self` and
     * `descendant` point to the same actor then it will also return %TRUE.
     */
    contains(descendant: Actor): boolean
    /**
     * Run the next stage of the paint sequence. This function should only
     * be called within the implementation of the ‘run’ virtual of a
     * #ClutterEffect. It will cause the run method of the next effect to
     * be applied, or it will paint the actual actor if the current effect
     * is the last effect in the chain.
     */
    continuePaint(): void
    /**
     * Creates a #PangoContext for the given actor. The #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * See also clutter_actor_get_pango_context().
     */
    createPangoContext(): Pango.Context
    /**
     * Creates a new #PangoLayout from the same #PangoContext used
     * by the #ClutterActor. The #PangoLayout is already configured
     * with the font map, resolution and font options, and the
     * given `text`.
     * 
     * If you want to keep around a #PangoLayout created by this
     * function you will have to connect to the #ClutterBackend::font-changed
     * and #ClutterBackend::resolution-changed signals, and call
     * pango_layout_context_changed() in response to them.
     */
    createPangoLayout(text?: string | null): Pango.Layout
    /**
     * Destroys an actor.  When an actor is destroyed, it will break any
     * references it holds to other objects.  If the actor is inside a
     * container, the actor will be removed.
     * 
     * When you destroy a container, its children will be destroyed as well.
     * 
     * Note: you cannot destroy the #ClutterStage returned by
     * clutter_stage_get_default().
     */
    destroy(): void
    /**
     * Destroys all children of `self`.
     * 
     * This function releases the reference added by inserting a child
     * actor in the list of children of `self,` and ensures that the
     * #ClutterActor::destroy signal is emitted on each child of the
     * actor.
     * 
     * By default, #ClutterActor will emit the #ClutterActor::destroy signal
     * when its reference count drops to 0; the default handler of the
     * #ClutterActor::destroy signal will destroy all the children of an
     * actor. This function ensures that all children are destroyed, instead
     * of just removed from `self,` unlike clutter_actor_remove_all_children()
     * which will merely release the reference and remove each child.
     * 
     * Unless you acquired an additional reference on each child of `self`
     * prior to calling clutter_actor_remove_all_children() and want to reuse
     * the actors, you should use clutter_actor_destroy_all_children() in
     * order to make sure that children are destroyed and signal handlers
     * are disconnected even in cases where circular references prevent this
     * from automatically happening through reference counting alone.
     */
    destroyAllChildren(): void
    /**
     * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     * 
     * Once the animation has been detached, it loses a reference. If it was
     * the only reference then the #ClutterAnimation becomes invalid.
     * 
     * The #ClutterAnimation::completed signal will not be emitted.
     */
    detachAnimation(): void
    /**
     * This function is used to emit an event on the main stage.
     * You should rarely need to use this function, except for
     * synthetising events.
     */
    event(event: Event, capture: boolean): boolean
    /**
     * Calculates the transformed screen coordinates of the four corners of
     * the actor; the returned vertices relate to the #ClutterActorBox
     * coordinates  as follows:
     * 
     *  - v[0] contains (x1, y1)
     *  - v[1] contains (x2, y1)
     *  - v[2] contains (x1, y2)
     *  - v[3] contains (x2, y2)
     */
    getAbsAllocationVertices(): /* verts */ Vertex[]
    /**
     * Returns the accessible object that describes the actor to an
     * assistive technology.
     * 
     * If no class-specific #AtkObject implementation is available for the
     * actor instance in question, it will inherit an #AtkObject
     * implementation from the first ancestor class for which such an
     * implementation is defined.
     * 
     * The documentation of the <ulink
     * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
     * library contains more information about accessible objects and
     * their uses.
     */
    getAccessible(): Atk.Object
    /**
     * Retrieves the #ClutterAction with the given name in the list
     * of actions applied to `self`
     */
    getAction(name: string): Action
    /**
     * Retrieves the list of actions applied to `self`
     */
    getActions(): Action[]
    /**
     * Gets the layout box an actor has been assigned. The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * Do not call any of the clutter_actor_get_allocation_*() family
     * of functions inside the implementation of the get_preferred_width()
     * or get_preferred_height() virtual functions.
     */
    getAllocationBox(): /* box */ ActorBox
    /**
     * Gets the layout box an actor has been assigned.  The allocation can
     * only be assumed valid inside a paint() method; anywhere else, it
     * may be out-of-date.
     * 
     * An allocation does not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     * 
     * The returned rectangle is in pixels.
     */
    getAllocationGeometry(): /* geom */ Geometry
    /**
     * Calculates the transformed coordinates of the four corners of the
     * actor in the plane of `ancestor`. The returned vertices relate to
     * the #ClutterActorBox coordinates as follows:
     * 
     *  - `verts[`0] contains (x1, y1)
     *  - `verts[`1] contains (x2, y1)
     *  - `verts[`2] contains (x1, y2)
     *  - `verts[`3] contains (x2, y2)
     * 
     * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
     * this case, the coordinates returned will be the coordinates on
     * the stage before the projection is applied. This is different from
     * the behaviour of clutter_actor_get_abs_allocation_vertices().
     */
    getAllocationVertices(ancestor?: Actor | null): /* verts */ Vertex[]
    /**
     * Gets the current anchor point of the `actor` in pixels.
     */
    getAnchorPoint(): [ /* anchorX */ number, /* anchorY */ number ]
    /**
     * Retrieves the anchor position expressed as a #ClutterGravity. If
     * the anchor point was specified using pixels or units this will
     * return %CLUTTER_GRAVITY_NONE.
     */
    getAnchorPointGravity(): Gravity
    /**
     * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
     * has been called on `actor`.
     */
    getAnimation(): Animation
    /**
     * Retrieves the color set using clutter_actor_set_background_color().
     */
    getBackgroundColor(): /* color */ Color
    /**
     * Retrieves the actor at the given `index_` inside the list of
     * children of `self`.
     */
    getChildAtIndex(index: number): Actor
    /**
     * Retrieves the child transformation matrix set using
     * clutter_actor_set_child_transform(); if none is currently set,
     * the `transform` matrix will be initialized to the identity matrix.
     */
    getChildTransform(): /* transform */ Matrix
    /**
     * Retrieves the list of children of `self`.
     */
    getChildren(): Actor[]
    /**
     * Gets the clip area for `self,` if any is set.
     */
    getClip(): [ /* xoff */ number | null, /* yoff */ number | null, /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the value set using clutter_actor_set_clip_to_allocation()
     */
    getClipToAllocation(): boolean
    /**
     * Retrieves the #ClutterConstraint with the given name in the list
     * of constraints applied to `self`
     */
    getConstraint(name: string): Constraint
    /**
     * Retrieves the list of constraints applied to `self`
     */
    getConstraints(): Constraint[]
    /**
     * Retrieves the contents of `self`.
     */
    getContent(): Content
    /**
     * Retrieves the bounding box for the #ClutterContent of `self`.
     * 
     * The bounding box is relative to the actor's allocation.
     * 
     * If no #ClutterContent is set for `self,` or if `self` has not been
     * allocated yet, then the result is undefined.
     * 
     * The content box is guaranteed to be, at most, as big as the allocation
     * of the #ClutterActor.
     * 
     * If the #ClutterContent used by the actor has a preferred size, then
     * it is possible to modify the content box by using the
     * #ClutterActor:content-gravity property.
     */
    getContentBox(): /* box */ ActorBox
    /**
     * Retrieves the content gravity as set using
     * clutter_actor_set_content_gravity().
     */
    getContentGravity(): ContentGravity
    /**
     * Retrieves the repeat policy for a #ClutterActor set by
     * clutter_actor_set_content_repeat().
     */
    getContentRepeat(): ContentRepeat
    /**
     * Retrieves the values set using clutter_actor_set_content_scaling_filters().
     */
    getContentScalingFilters(): [ /* minFilter */ ScalingFilter | null, /* magFilter */ ScalingFilter | null ]
    /**
     * Retrieves the default paint volume for `self`.
     * 
     * This function provides the same #ClutterPaintVolume that would be
     * computed by the default implementation inside #ClutterActor of the
     * #ClutterActorClass.get_paint_volume() virtual function.
     * 
     * This function should only be used by #ClutterActor subclasses that
     * cannot chain up to the parent implementation when computing their
     * paint volume.
     */
    getDefaultPaintVolume(): PaintVolume
    /**
     * Retrieves the depth of `self`.
     */
    getDepth(): number
    /**
     * Retrieves the delay that should be applied when tweening animatable
     * properties.
     */
    getEasingDelay(): number
    /**
     * Retrieves the duration of the tweening for animatable
     * properties of `self` for the current easing state.
     */
    getEasingDuration(): number
    /**
     * Retrieves the easing mode for the tweening of animatable properties
     * of `self` for the current easing state.
     */
    getEasingMode(): AnimationMode
    /**
     * Retrieves the #ClutterEffect with the given name in the list
     * of effects applied to `self`
     */
    getEffect(name: string): Effect
    /**
     * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
     */
    getEffects(): Effect[]
    /**
     * Retrieves the first child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getFirstChild(): Actor
    /**
     * Checks whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    getFixedPositionSet(): boolean
    /**
     * Retrieves the flags set on `self`
     */
    getFlags(): ActorFlags
    /**
     * Gets the size and position of an actor relative to its parent
     * actor. This is the same as calling clutter_actor_get_position() and
     * clutter_actor_get_size(). It tries to "do what you mean" and get the
     * requested size and position if the actor's allocation is invalid.
     */
    getGeometry(): /* geometry */ Geometry
    /**
     * Retrieves the unique id for `self`.
     */
    getGid(): number
    /**
     * Retrieves the height of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * height of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural height, that is the preferred height of
     * the actor.
     * 
     * If you care whether you get the preferred height or the height that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_height() to retrieve the
     * preferred height.
     * 
     * If an actor has a fixed height, for instance a height that has been
     * assigned using clutter_actor_set_height(), the height returned will
     * be the same value.
     */
    getHeight(): number
    /**
     * Retrieves the last child of `self`.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getLastChild(): Actor
    /**
     * Retrieves the #ClutterLayoutManager used by `self`.
     */
    getLayoutManager(): LayoutManager
    /**
     * Retrieves all the components of the margin of a #ClutterActor.
     */
    getMargin(): /* margin */ Margin
    /**
     * Retrieves the bottom margin of a #ClutterActor.
     */
    getMarginBottom(): number
    /**
     * Retrieves the left margin of a #ClutterActor.
     */
    getMarginLeft(): number
    /**
     * Retrieves the right margin of a #ClutterActor.
     */
    getMarginRight(): number
    /**
     * Retrieves the top margin of a #ClutterActor.
     */
    getMarginTop(): number
    /**
     * Retrieves the number of children of `self`.
     */
    getNChildren(): number
    /**
     * Retrieves the name of `self`.
     */
    getName(): string
    /**
     * Retrieves the sibling of `self` that comes after it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getNextSibling(): Actor
    /**
     * Retrieves whether to redirect the actor to an offscreen buffer, as
     * set by clutter_actor_set_offscreen_redirect().
     */
    getOffscreenRedirect(): OffscreenRedirect
    /**
     * Retrieves the opacity value of an actor, as set by
     * clutter_actor_set_opacity().
     * 
     * For retrieving the absolute opacity of the actor inside a paint
     * virtual function, see clutter_actor_get_paint_opacity().
     */
    getOpacity(): number
    /**
     * Retrieves the paint volume of the passed #ClutterActor, and
     * transforms it into a 2D bounding box in stage coordinates.
     * 
     * This function is useful to determine the on screen area occupied by
     * the actor. The box is only an approximation and may often be
     * considerably larger due to the optimizations used to calculate the
     * box. The box is never smaller though, so it can reliably be used
     * for culling.
     * 
     * There are times when a 2D paint box can't be determined, e.g.
     * because the actor isn't yet parented under a stage or because
     * the actor is unable to determine a paint volume.
     */
    getPaintBox(): [ /* returnType */ boolean, /* box */ ActorBox ]
    /**
     * Retrieves the absolute opacity of the actor, as it appears on the stage.
     * 
     * This function traverses the hierarchy chain and composites the opacity of
     * the actor with that of its parents.
     * 
     * This function is intended for subclasses to use in the paint virtual
     * function, to paint themselves with the correct opacity.
     */
    getPaintOpacity(): number
    /**
     * Retrieves the 'paint' visibility of an actor recursively checking for non
     * visible parents.
     * 
     * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
     */
    getPaintVisibility(): boolean
    /**
     * Retrieves the paint volume of the passed #ClutterActor, or %NULL
     * when a paint volume can't be determined.
     * 
     * The paint volume is defined as the 3D space occupied by an actor
     * when being painted.
     * 
     * This function will call the #ClutterActorClass.get_paint_volume()
     * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
     * should not usually care about overriding the default implementation,
     * unless they are, for instance: painting outside their allocation, or
     * actors with a depth factor (not in terms of #ClutterActor:depth but real
     * 3D depth).
     * 
     * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
     * should ensure that their volume has a depth of 0. (This will be true
     * as long as you don't call clutter_paint_volume_set_depth().)
     */
    getPaintVolume(): PaintVolume
    /**
     * Retrieves the #PangoContext for `self`. The actor's #PangoContext
     * is already configured using the appropriate font map, resolution
     * and font options.
     * 
     * Unlike clutter_actor_create_pango_context(), this context is owend
     * by the #ClutterActor and it will be updated each time the options
     * stored by the #ClutterBackend change.
     * 
     * You can use the returned #PangoContext to create a #PangoLayout
     * and render text using cogl_pango_render_layout() to reuse the
     * glyphs cache also used by Clutter.
     */
    getPangoContext(): Pango.Context
    /**
     * Retrieves the parent of `self`.
     */
    getParent(): Actor
    /**
     * Retrieves the coordinates of the #ClutterActor:pivot-point.
     */
    getPivotPoint(): [ /* pivotX */ number | null, /* pivotY */ number | null ]
    /**
     * Retrieves the Z component of the #ClutterActor:pivot-point.
     */
    getPivotPointZ(): number
    /**
     * This function tries to "do what you mean" and tell you where the
     * actor is, prior to any transformations. Retrieves the fixed
     * position of an actor in pixels, if one has been set; otherwise, if
     * the allocation is valid, returns the actor's allocated position;
     * otherwise, returns 0,0.
     * 
     * The returned position is in pixels.
     */
    getPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Computes the requested minimum and natural heights for an actor,
     * or if they are already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredHeight(forWidth: number): [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the preferred minimum and natural size of an actor, taking into
     * account the actor's geometry management (either height-for-width
     * or width-for-height).
     * 
     * The width and height used to compute the preferred height and preferred
     * width are the actor's natural ones.
     * 
     * If you need to control the height for the preferred width, or the width for
     * the preferred height, you should use clutter_actor_get_preferred_width()
     * and clutter_actor_get_preferred_height(), and check the actor's preferred
     * geometry management using the #ClutterActor:request-mode property.
     */
    getPreferredSize(): [ /* minWidthP */ number | null, /* minHeightP */ number | null, /* naturalWidthP */ number | null, /* naturalHeightP */ number | null ]
    /**
     * Computes the requested minimum and natural widths for an actor,
     * optionally depending on the specified height, or if they are
     * already computed, returns the cached values.
     * 
     * An actor may not get its request - depending on the layout
     * manager that's in effect.
     * 
     * A request should not incorporate the actor's scale or anchor point;
     * those transformations do not affect layout, only rendering.
     */
    getPreferredWidth(forHeight: number): [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    /**
     * Retrieves the sibling of `self` that comes before it in the list
     * of children of `self'`s parent.
     * 
     * The returned pointer is only valid until the scene graph changes; it
     * is not safe to modify the list of children of `self` while iterating
     * it.
     */
    getPreviousSibling(): Actor
    /**
     * Checks whether `actor` is marked as reactive.
     */
    getReactive(): boolean
    /**
     * Retrieves the geometry request mode of `self`
     */
    getRequestMode(): RequestMode
    /**
     * Retrieves the angle and center of rotation on the given axis,
     * set using clutter_actor_set_rotation().
     */
    getRotation(axis: RotateAxis): [ /* returnType */ number, /* x */ number, /* y */ number, /* z */ number ]
    /**
     * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
     */
    getRotationAngle(axis: RotateAxis): number
    /**
     * Retrieves an actors scale factors.
     */
    getScale(): [ /* scaleX */ number | null, /* scaleY */ number | null ]
    /**
     * Retrieves the scale center coordinate in pixels relative to the top
     * left corner of the actor. If the scale center was specified using a
     * #ClutterGravity this will calculate the pixel offset using the
     * current size of the actor.
     */
    getScaleCenter(): [ /* centerX */ number | null, /* centerY */ number | null ]
    /**
     * Retrieves the scale center as a compass direction. If the scale
     * center was specified in pixels or units this will return
     * %CLUTTER_GRAVITY_NONE.
     */
    getScaleGravity(): Gravity
    /**
     * Retrieves the scaling factor along the Z axis, as set using
     * clutter_actor_set_scale_z().
     */
    getScaleZ(): number
    /**
     * Queries the currently set #ClutterShader on `self`.
     */
    getShader(): Shader
    /**
     * This function tries to "do what you mean" and return
     * the size an actor will have. If the actor has a valid
     * allocation, the allocation will be returned; otherwise,
     * the actors natural size request will be returned.
     * 
     * If you care whether you get the request vs. the allocation, you
     * should probably call a different function like
     * clutter_actor_get_allocation_box() or
     * clutter_actor_get_preferred_width().
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterStage where `actor` is contained.
     */
    getStage(): Stage
    /**
     * Retrieves the value set using clutter_actor_set_text_direction()
     * 
     * If no text direction has been previously set, the default text
     * direction, as returned by clutter_get_default_text_direction(), will
     * be returned instead
     */
    getTextDirection(): TextDirection
    /**
     * Retrieves the current transformation matrix of a #ClutterActor.
     */
    getTransform(): /* transform */ Matrix
    /**
     * Retrieves the transformations applied to `self` relative to its
     * parent.
     */
    getTransformationMatrix(): /* matrix */ Matrix
    /**
     * Retrieves the 3D paint volume of an actor like
     * clutter_actor_get_paint_volume() does (Please refer to the
     * documentation of clutter_actor_get_paint_volume() for more
     * details.) and it additionally transforms the paint volume into the
     * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
     * is passed for `relative_to_ancestor)`
     * 
     * This can be used by containers that base their paint volume on
     * the volume of their children. Such containers can query the
     * transformed paint volume of all of its children and union them
     * together using clutter_paint_volume_union().
     */
    getTransformedPaintVolume(relativeToAncestor: Actor): PaintVolume
    /**
     * Gets the absolute position of an actor, in pixels relative to the stage.
     */
    getTransformedPosition(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Gets the absolute size of an actor in pixels, taking into account the
     * scaling factors.
     * 
     * If the actor has a valid allocation, the allocated size will be used.
     * If the actor has not a valid allocation then the preferred size will
     * be transformed and returned.
     * 
     * If you want the transformed allocation, see
     * clutter_actor_get_abs_allocation_vertices() instead.
     * 
     * When the actor (or one of its ancestors) is rotated around the
     * X or Y axis, it no longer appears as on the stage as a rectangle, but
     * as a generic quadrangle; in that case this function returns the size
     * of the smallest rectangle that encapsulates the entire quad. Please
     * note that in this case no assumptions can be made about the relative
     * position of this envelope to the absolute position of the actor, as
     * returned by clutter_actor_get_transformed_position(); if you need this
     * information, you need to use clutter_actor_get_abs_allocation_vertices()
     * to get the coords of the actual quadrangle.
     */
    getTransformedSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the #ClutterTransition of a #ClutterActor by using the
     * transition `name`.
     * 
     * Transitions created for animatable properties use the name of the
     * property itself, for instance the code below:
     * 
     * 
     * ```c
     *   clutter_actor_set_easing_duration (actor, 1000);
     *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
     * 
     *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
     *   g_signal_connect (transition, "stopped",
     *                     G_CALLBACK (on_transition_stopped),
     *                     actor);
     * ```
     * 
     * 
     * will call the `on_transition_stopped` callback when the transition
     * is finished.
     * 
     * If you just want to get notifications of the completion of a transition,
     * you should use the #ClutterActor::transition-stopped signal, using the
     * transition name as the signal detail.
     */
    getTransition(name: string): Transition
    /**
     * Retrieves the translation set using clutter_actor_set_translation().
     */
    getTranslation(): [ /* translateX */ number | null, /* translateY */ number | null, /* translateZ */ number | null ]
    /**
     * Retrieves the width of a #ClutterActor.
     * 
     * If the actor has a valid allocation, this function will return the
     * width of the allocated area given to the actor.
     * 
     * If the actor does not have a valid allocation, this function will
     * return the actor's natural width, that is the preferred width of
     * the actor.
     * 
     * If you care whether you get the preferred width or the width that
     * has been assigned to the actor, you should probably call a different
     * function like clutter_actor_get_allocation_box() to retrieve the
     * allocated size or clutter_actor_get_preferred_width() to retrieve the
     * preferred width.
     * 
     * If an actor has a fixed width, for instance a width that has been
     * assigned using clutter_actor_set_width(), the width returned will
     * be the same value.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the X coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_x(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getX(): number
    /**
     * Retrieves the horizontal alignment policy set using
     * clutter_actor_set_x_align().
     */
    getXAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_x_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getXExpand(): boolean
    /**
     * Retrieves the Y coordinate of a #ClutterActor.
     * 
     * This function tries to "do what you mean", by returning the
     * correct value depending on the actor's state.
     * 
     * If the actor has a valid allocation, this function will return
     * the Y coordinate of the origin of the allocation box.
     * 
     * If the actor has any fixed coordinate set using clutter_actor_set_y(),
     * clutter_actor_set_position() or clutter_actor_set_geometry(), this
     * function will return that coordinate.
     * 
     * If both the allocation and a fixed position are missing, this function
     * will return 0.
     */
    getY(): number
    /**
     * Retrieves the vertical alignment policy set using
     * clutter_actor_set_y_align().
     */
    getYAlign(): ActorAlign
    /**
     * Retrieves the value set with clutter_actor_set_y_expand().
     * 
     * See also: clutter_actor_needs_expand()
     */
    getYExpand(): boolean
    /**
     * Retrieves the actor's position on the Z axis.
     */
    getZPosition(): number
    /**
     * Retrieves the center for the rotation around the Z axis as a
     * compass direction. If the center was specified in pixels or units
     * this will return %CLUTTER_GRAVITY_NONE.
     */
    getZRotationGravity(): Gravity
    /**
     * Sets the key focus of the #ClutterStage including `self`
     * to this #ClutterActor.
     */
    grabKeyFocus(): void
    /**
     * Returns whether the actor has any actions applied.
     */
    hasActions(): boolean
    /**
     * Checks if the actor has an up-to-date allocation assigned to
     * it. This means that the actor should have an allocation: it's
     * visible and has a parent. It also means that there is no
     * outstanding relayout request in progress for the actor or its
     * children (There might be other outstanding layout requests in
     * progress that will cause the actor to get a new allocation
     * when the stage is laid out, however).
     * 
     * If this function returns %FALSE, then the actor will normally
     * be allocated before it is next drawn on the screen.
     */
    hasAllocation(): boolean
    /**
     * Returns whether the actor has any constraints applied.
     */
    hasConstraints(): boolean
    /**
     * Returns whether the actor has any effects applied.
     */
    hasEffects(): boolean
    /**
     * Checks whether `self` is the #ClutterActor that has key focus
     */
    hasKeyFocus(): boolean
    /**
     * Asks the actor's implementation whether it may contain overlapping
     * primitives.
     * 
     * For example; Clutter may use this to determine whether the painting
     * should be redirected to an offscreen buffer to correctly implement
     * the opacity property.
     * 
     * Custom actors can override the default response by implementing the
     * #ClutterActorClass.has_overlaps() virtual function. See
     * clutter_actor_set_offscreen_redirect() for more information.
     */
    hasOverlaps(): boolean
    /**
     * Flags an actor to be hidden. A hidden actor will not be
     * rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent property will be set to %FALSE
     * as a side-effect.
     */
    hide(): void
    /**
     * Calls clutter_actor_hide() on all child actors (if any).
     */
    hideAll(): void
    /**
     * Inserts `child` into the list of children of `self,` above another
     * child of `self` or, if `sibling` is %NULL, above all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAbove(child: Actor, sibling?: Actor | null): void
    /**
     * Inserts `child` into the list of children of `self,` using the
     * given `index_`. If `index_` is greater than the number of children
     * in `self,` or is less than 0, then the new child is added at the end.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildAtIndex(child: Actor, index: number): void
    /**
     * Inserts `child` into the list of children of `self,` below another
     * child of `self` or, if `sibling` is %NULL, below all the children
     * of `self`.
     * 
     * This function will acquire a reference on `child` that will only
     * be released when calling clutter_actor_remove_child().
     * 
     * This function will not take into consideration the #ClutterActor:depth
     * of `child`.
     * 
     * This function will emit the #ClutterContainer::actor-added signal
     * on `self`.
     */
    insertChildBelow(child: Actor, sibling?: Actor | null): void
    /**
     * Checks whether `self` is being currently painted by a #ClutterClone
     * 
     * This function is useful only inside the ::paint virtual function
     * implementations or within handlers for the #ClutterActor::paint
     * signal
     * 
     * This function should not be used by applications
     */
    isInClonePaint(): boolean
    /**
     * Checks whether a #ClutterActor has been set as mapped.
     * 
     * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
     */
    isMapped(): boolean
    /**
     * Checks whether a #ClutterActor is realized.
     * 
     * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
     */
    isRealized(): boolean
    /**
     * Checks whether any rotation is applied to the actor.
     */
    isRotated(): boolean
    /**
     * Checks whether the actor is scaled in either dimension.
     */
    isScaled(): boolean
    /**
     * Checks whether an actor is marked as visible.
     * 
     * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
     */
    isVisible(): boolean
    /**
     * Puts `self` below `above`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface.
     * 
     * This function calls clutter_container_lower_child() internally.
     */
    lower(above?: Actor | null): void
    /**
     * Lowers `self` to the bottom.
     * 
     * This function calls clutter_actor_lower() internally.
     */
    lowerBottom(): void
    /**
     * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
     * and realizes its children if they are visible. Does nothing if the
     * actor is not visible.
     * 
     * Calling this function is strongly disencouraged: the default
     * implementation of #ClutterActorClass.map() will map all the children
     * of an actor when mapping its parent.
     * 
     * When overriding map, it is mandatory to chain up to the parent
     * implementation.
     */
    map(): void
    /**
     * Sets an anchor point for the actor, and adjusts the actor postion so that
     * the relative position of the actor toward its parent remains the same.
     */
    moveAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor based on the given gravity, adjusting the
     * actor postion so that its relative position within its parent remains
     * unchanged.
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    moveAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Moves an actor by the specified distance relative to its current
     * position in pixels.
     * 
     * This function modifies the fixed position of an actor and thus removes
     * it from any layout management. Another way to move an actor is with an
     * anchor point, see clutter_actor_set_anchor_point(), or with an additional
     * translation, using clutter_actor_set_translation().
     */
    moveBy(dx: number, dy: number): void
    /**
     * Checks whether an actor, or any of its children, is set to expand
     * horizontally or vertically.
     * 
     * This function should only be called by layout managers that can
     * assign extra space to their children.
     * 
     * If you want to know whether the actor was explicitly set to expand,
     * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
     */
    needsExpand(orientation: Orientation): boolean
    /**
     * Renders the actor to display.
     * 
     * This function should not be called directly by applications.
     * Call clutter_actor_queue_redraw() to queue paints, instead.
     * 
     * This function is context-aware, and will either cause a
     * regular paint or a pick paint.
     * 
     * This function will emit the #ClutterActor::paint signal or
     * the #ClutterActor::pick signal, depending on the context.
     * 
     * This function does not paint the actor if the actor is set to 0,
     * unless it is performing a pick paint.
     */
    paint(): void
    /**
     * Disables the effects of clutter_actor_push_internal().
     */
    popInternal(): void
    /**
     * Should be used by actors implementing the #ClutterContainer and with
     * internal children added through clutter_actor_set_parent(), for instance:
     * 
     * 
     * ```c
     *   static void
     *   my_actor_init (MyActor *self)
     *   {
     *     self->priv = my_actor_get_instance_private (self);
     * 
     *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will result in
     *     // the internal flag being set on a child of MyActor
     * 
     *     // internal child - a background texture
     *     self->priv->background_tex = clutter_texture_new ();
     *     clutter_actor_set_parent (self->priv->background_tex,
     *                               CLUTTER_ACTOR (self));
     * 
     *     // internal child - a label
     *     self->priv->label = clutter_text_new ();
     *     clutter_actor_set_parent (self->priv->label,
     *                               CLUTTER_ACTOR (self));
     * 
     *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
     * 
     *     // calling clutter_actor_set_parent() now will not result in
     *     // the internal flag being set on a child of MyActor
     *   }
     * ```
     * 
     * 
     * This function will be used by Clutter to toggle an "internal child"
     * flag whenever clutter_actor_set_parent() is called; internal children
     * are handled differently by Clutter, specifically when destroying their
     * parent.
     * 
     * Call clutter_actor_pop_internal() when you finished adding internal
     * children.
     * 
     * Nested calls to clutter_actor_push_internal() are allowed, but each
     * one must by followed by a clutter_actor_pop_internal() call.
     */
    pushInternal(): void
    /**
     * Queues up a redraw of an actor and any children. The redraw occurs
     * once the main loop becomes idle (after the current batch of events
     * has been processed, roughly).
     * 
     * Applications rarely need to call this, as redraws are handled
     * automatically by modification functions.
     * 
     * This function will not do anything if `self` is not visible, or
     * if the actor is inside an invisible part of the scenegraph.
     * 
     * Also be aware that painting is a NOP for actors with an opacity of
     * 0
     * 
     * When you are implementing a custom actor you must queue a redraw
     * whenever some private state changes that will affect painting or
     * picking of your actor.
     */
    queueRedraw(): void
    /**
     * Queues a redraw on `self` limited to a specific, actor-relative
     * rectangular area.
     * 
     * If `clip` is %NULL this function is equivalent to
     * clutter_actor_queue_redraw().
     */
    queueRedrawWithClip(clip?: cairo.RectangleInt | null): void
    /**
     * Indicates that the actor's size request or other layout-affecting
     * properties may have changed. This function is used inside #ClutterActor
     * subclass implementations, not by applications directly.
     * 
     * Queueing a new layout automatically queues a redraw as well.
     */
    queueRelayout(): void
    /**
     * Puts `self` above `below`.
     * 
     * Both actors must have the same parent, and the parent must implement
     * the #ClutterContainer interface
     * 
     * This function calls clutter_container_raise_child() internally.
     */
    raise(below?: Actor | null): void
    /**
     * Raises `self` to the top.
     * 
     * This function calls clutter_actor_raise() internally.
     */
    raiseTop(): void
    /**
     * Realization informs the actor that it is attached to a stage. It
     * can use this to allocate resources if it wanted to delay allocation
     * until it would be rendered. However it is perfectly acceptable for
     * an actor to create resources before being realized because Clutter
     * only ever has a single rendering context so that actor is free to
     * be moved from one stage to another.
     * 
     * This function does nothing if the actor is already realized.
     * 
     * Because a realized actor must have realized parent actors, calling
     * clutter_actor_realize() will also realize all parents of the actor.
     * 
     * This function does not realize child actors, except in the special
     * case that realizing the stage, when the stage is visible, will
     * suddenly map (and thus realize) the children of the stage.
     */
    realize(): void
    /**
     * Removes `action` from the list of actions applied to `self`
     * 
     * The reference held by `self` on the #ClutterAction will be released
     */
    removeAction(action: Action): void
    /**
     * Removes the #ClutterAction with the given name from the list
     * of actions applied to `self`
     */
    removeActionByName(name: string): void
    /**
     * Removes all children of `self`.
     * 
     * This function releases the reference added by inserting a child actor
     * in the list of children of `self`.
     * 
     * If the reference count of a child drops to zero, the child will be
     * destroyed. If you want to ensure the destruction of all the children
     * of `self,` use clutter_actor_destroy_all_children().
     */
    removeAllChildren(): void
    /**
     * Removes all transitions associated to `self`.
     */
    removeAllTransitions(): void
    /**
     * Removes `child` from the children of `self`.
     * 
     * This function will release the reference added by
     * clutter_actor_add_child(), so if you want to keep using `child`
     * you will have to acquire a referenced on it before calling this
     * function.
     * 
     * This function will emit the #ClutterContainer::actor-removed
     * signal on `self`.
     */
    removeChild(child: Actor): void
    /**
     * Removes clip area from `self`.
     */
    removeClip(): void
    /**
     * Removes `constraint` from the list of constraints applied to `self`
     * 
     * The reference held by `self` on the #ClutterConstraint will be released
     */
    removeConstraint(constraint: Constraint): void
    /**
     * Removes the #ClutterConstraint with the given name from the list
     * of constraints applied to `self`
     */
    removeConstraintByName(name: string): void
    /**
     * Removes `effect` from the list of effects applied to `self`
     * 
     * The reference held by `self` on the #ClutterEffect will be released
     */
    removeEffect(effect: Effect): void
    /**
     * Removes the #ClutterEffect with the given name from the list
     * of effects applied to `self`
     */
    removeEffectByName(name: string): void
    /**
     * Removes the transition stored inside a #ClutterActor using `name`
     * identifier.
     * 
     * If the transition is currently in progress, it will be stopped.
     * 
     * This function releases the reference acquired when the transition
     * was added to the #ClutterActor.
     */
    removeTransition(name: string): void
    /**
     * Resets the parent actor of `self`.
     * 
     * This function is logically equivalent to calling clutter_actor_unparent()
     * and clutter_actor_set_parent(), but more efficiently implemented, as it
     * ensures the child is not finalized when unparented, and emits the
     * #ClutterActor::parent-set signal only once.
     * 
     * In reality, calling this function is less useful than it sounds, as some
     * application code may rely on changes in the intermediate state between
     * removal and addition of the actor from its old parent to the `new_parent`.
     * Thus, it is strongly encouraged to avoid using this function in application
     * code.
     */
    reparent(newParent: Actor): void
    /**
     * Replaces `old_child` with `new_child` in the list of children of `self`.
     */
    replaceChild(oldChild: Actor, newChild: Actor): void
    /**
     * Restores the easing state as it was prior to a call to
     * clutter_actor_save_easing_state().
     */
    restoreEasingState(): void
    /**
     * Saves the current easing state for animatable properties, and creates
     * a new state with the default values for easing mode and duration.
     * 
     * New transitions created after calling this function will inherit the
     * duration, easing mode, and delay of the new easing state; this also
     * applies to transitions modified in flight.
     */
    saveEasingState(): void
    /**
     * Stores the allocation of `self` as defined by `box`.
     * 
     * This function can only be called from within the implementation of
     * the #ClutterActorClass.allocate() virtual function.
     * 
     * The allocation should have been adjusted to take into account constraints,
     * alignment, and margin properties. If you are implementing a #ClutterActor
     * subclass that provides its own layout management policy for its children
     * instead of using a #ClutterLayoutManager delegate, you should not call
     * this function on the children of `self;` instead, you should call
     * clutter_actor_allocate(), which will adjust the allocation box for
     * you.
     * 
     * This function should only be used by subclasses of #ClutterActor
     * that wish to store their allocation but cannot chain up to the
     * parent's implementation; the default implementation of the
     * #ClutterActorClass.allocate() virtual function will call this
     * function.
     * 
     * It is important to note that, while chaining up was the recommended
     * behaviour for #ClutterActor subclasses prior to the introduction of
     * this function, it is recommended to call clutter_actor_set_allocation()
     * instead.
     * 
     * If the #ClutterActor is using a #ClutterLayoutManager delegate object
     * to handle the allocation of its children, this function will call
     * the clutter_layout_manager_allocate() function only if the
     * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
     * expected that the subclass will call clutter_layout_manager_allocate()
     * by itself. For instance, the following code:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterActorBox new_alloc;
     *   ClutterAllocationFlags new_flags;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
     * 
     *   // this will use the layout manager set on the actor
     *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
     * }
     * ```
     * 
     * 
     * is equivalent to this:
     * 
     * 
     * ```c
     * static void
     * my_actor_allocate (ClutterActor *actor,
     *                    const ClutterActorBox *allocation,
     *                    ClutterAllocationFlags flags)
     * {
     *   ClutterLayoutManager *layout;
     *   ClutterActorBox new_alloc;
     * 
     *   adjust_allocation (allocation, &new_alloc);
     * 
     *   clutter_actor_set_allocation (actor, &new_alloc, flags);
     * 
     *   layout = clutter_actor_get_layout_manager (actor);
     *   clutter_layout_manager_allocate (layout,
     *                                    CLUTTER_CONTAINER (actor),
     *                                    &new_alloc,
     *                                    flags);
     * }
     * ```
     * 
     */
    setAllocation(box: ActorBox, flags: AllocationFlags): void
    /**
     * Sets an anchor point for `self`. The anchor point is a point in the
     * coordinate space of an actor to which the actor position within its
     * parent is relative; the default is (0, 0), i.e. the top-left corner
     * of the actor.
     */
    setAnchorPoint(anchorX: number, anchorY: number): void
    /**
     * Sets an anchor point on the actor, based on the given gravity (this is a
     * convenience function wrapping clutter_actor_set_anchor_point()).
     * 
     * Since version 1.0 the anchor point will be stored as a gravity so
     * that if the actor changes size then the anchor point will move. For
     * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
     * and later double the size of the actor, the anchor point will move
     * to the bottom right.
     */
    setAnchorPointFromGravity(gravity: Gravity): void
    /**
     * Sets the background color of a #ClutterActor.
     * 
     * The background color will be used to cover the whole allocation of the
     * actor. The default background color of an actor is transparent.
     * 
     * To check whether an actor has a background color, you can use the
     * #ClutterActor:background-color-set actor property.
     * 
     * The #ClutterActor:background-color property is animatable.
     */
    setBackgroundColor(color?: Color | null): void
    /**
     * Sets `child` to be above `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new last child of `self`.
     * 
     * This function is logically equivalent to removing `child` and using
     * clutter_actor_insert_child_above(), but it will not emit signals
     * or change state on `child`.
     */
    setChildAboveSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Changes the index of `child` in the list of children of `self`.
     * 
     * This function is logically equivalent to removing `child` and
     * calling clutter_actor_insert_child_at_index(), but it will not
     * emit signals or change state on `child`.
     */
    setChildAtIndex(child: Actor, index: number): void
    /**
     * Sets `child` to be below `sibling` in the list of children of `self`.
     * 
     * If `sibling` is %NULL, `child` will be the new first child of `self`.
     * 
     * This function is logically equivalent to removing `self` and using
     * clutter_actor_insert_child_below(), but it will not emit signals
     * or change state on `child`.
     */
    setChildBelowSibling(child: Actor, sibling?: Actor | null): void
    /**
     * Sets the transformation matrix to be applied to all the children
     * of `self` prior to their own transformations. The default child
     * transformation is the identity matrix.
     * 
     * If `transform` is %NULL, the child transform will be unset.
     * 
     * The #ClutterActor:child-transform property is animatable.
     */
    setChildTransform(transform?: Matrix | null): void
    /**
     * Sets clip area for `self`. The clip area is always computed from the
     * upper left corner of the actor, even if the anchor point is set
     * otherwise.
     */
    setClip(xoff: number, yoff: number, width: number, height: number): void
    /**
     * Sets whether `self` should be clipped to the same size as its
     * allocation
     */
    setClipToAllocation(clipSet: boolean): void
    /**
     * Sets the contents of a #ClutterActor.
     */
    setContent(content?: Content | null): void
    /**
     * Sets the gravity of the #ClutterContent used by `self`.
     * 
     * See the description of the #ClutterActor:content-gravity property for
     * more information.
     * 
     * The #ClutterActor:content-gravity property is animatable.
     */
    setContentGravity(gravity: ContentGravity): void
    /**
     * Sets the policy for repeating the #ClutterActor:content of a
     * #ClutterActor. The behaviour is deferred to the #ClutterContent
     * implementation.
     */
    setContentRepeat(repeat: ContentRepeat): void
    /**
     * Sets the minification and magnification filter to be applied when
     * scaling the #ClutterActor:content of a #ClutterActor.
     * 
     * The #ClutterActor:minification-filter will be used when reducing
     * the size of the content; the #ClutterActor:magnification-filter
     * will be used when increasing the size of the content.
     */
    setContentScalingFilters(minFilter: ScalingFilter, magFilter: ScalingFilter): void
    /**
     * Sets the Z coordinate of `self` to `depth`.
     * 
     * The unit used by `depth` is dependant on the perspective setup. See
     * also clutter_stage_set_perspective().
     */
    setDepth(depth: number): void
    /**
     * Sets the delay that should be applied before tweening animatable
     * properties.
     */
    setEasingDelay(msecs: number): void
    /**
     * Sets the duration of the tweening for animatable properties
     * of `self` for the current easing state.
     */
    setEasingDuration(msecs: number): void
    /**
     * Sets the easing mode for the tweening of animatable properties
     * of `self`.
     */
    setEasingMode(mode: AnimationMode): void
    /**
     * Sets whether an actor has a fixed position set (and will thus be
     * unaffected by any layout manager).
     */
    setFixedPositionSet(isSet: boolean): void
    /**
     * Sets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    setFlags(flags: ActorFlags): void
    /**
     * Sets the actor's fixed position and forces its minimum and natural
     * size, in pixels. This means the untransformed actor will have the
     * given geometry. This is the same as calling clutter_actor_set_position()
     * and clutter_actor_set_size().
     */
    setGeometry(geometry: Geometry): void
    /**
     * Forces a height on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `height` is -1 the actor will use its preferred height instead of
     * overriding it, i.e. you can "unset" the height with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setHeight(height: number): void
    /**
     * Sets the #ClutterLayoutManager delegate object that will be used to
     * lay out the children of `self`.
     * 
     * The #ClutterActor will take a reference on the passed `manager` which
     * will be released either when the layout manager is removed, or when
     * the actor is destroyed.
     */
    setLayoutManager(manager?: LayoutManager | null): void
    /**
     * Sets all the components of the margin of a #ClutterActor.
     */
    setMargin(margin: Margin): void
    /**
     * Sets the margin from the bottom of a #ClutterActor.
     * 
     * The #ClutterActor:margin-bottom property is animatable.
     */
    setMarginBottom(margin: number): void
    /**
     * Sets the margin from the left of a #ClutterActor.
     * 
     * The #ClutterActor:margin-left property is animatable.
     */
    setMarginLeft(margin: number): void
    /**
     * Sets the margin from the right of a #ClutterActor.
     * 
     * The #ClutterActor:margin-right property is animatable.
     */
    setMarginRight(margin: number): void
    /**
     * Sets the margin from the top of a #ClutterActor.
     * 
     * The #ClutterActor:margin-top property is animatable.
     */
    setMarginTop(margin: number): void
    /**
     * Sets the given name to `self`. The name can be used to identify
     * a #ClutterActor.
     */
    setName(name: string): void
    /**
     * Defines the circumstances where the actor should be redirected into
     * an offscreen image. The offscreen image is used to flatten the
     * actor into a single image while painting for two main reasons.
     * Firstly, when the actor is painted a second time without any of its
     * contents changing it can simply repaint the cached image without
     * descending further down the actor hierarchy. Secondly, it will make
     * the opacity look correct even if there are overlapping primitives
     * in the actor.
     * 
     * Caching the actor could in some cases be a performance win and in
     * some cases be a performance lose so it is important to determine
     * which value is right for an actor before modifying this value. For
     * example, there is never any reason to flatten an actor that is just
     * a single texture (such as a #ClutterTexture) because it is
     * effectively already cached in an image so the offscreen would be
     * redundant. Also if the actor contains primitives that are far apart
     * with a large transparent area in the middle (such as a large
     * CluterGroup with a small actor in the top left and a small actor in
     * the bottom right) then the cached image will contain the entire
     * image of the large area and the paint will waste time blending all
     * of the transparent pixels in the middle.
     * 
     * The default method of implementing opacity on a container simply
     * forwards on the opacity to all of the children. If the children are
     * overlapping then it will appear as if they are two separate glassy
     * objects and there will be a break in the color where they
     * overlap. By redirecting to an offscreen buffer it will be as if the
     * two opaque objects are combined into one and then made transparent
     * which is usually what is expected.
     * 
     * The image below demonstrates the difference between redirecting and
     * not. The image shows two Clutter groups, each containing a red and
     * a green rectangle which overlap. The opacity on the group is set to
     * 128 (which is 50%). When the offscreen redirect is not used, the
     * red rectangle can be seen through the blue rectangle as if the two
     * rectangles were separately transparent. When the redirect is used
     * the group as a whole is transparent instead so the red rectangle is
     * not visible where they overlap.
     * 
     * <figure id="offscreen-redirect">
     *   <title>Sample of using an offscreen redirect for transparency</title>
     *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
     * </figure>
     * 
     * The default value for this property is 0, so we effectively will
     * never redirect an actor offscreen by default. This means that there
     * are times that transparent actors may look glassy as described
     * above. The reason this is the default is because there is a
     * performance trade off between quality and performance here. In many
     * cases the default form of glassy opacity looks good enough, but if
     * it's not you will need to set the
     * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
     * redirection for opacity.
     * 
     * Custom actors that don't contain any overlapping primitives are
     * recommended to override the has_overlaps() virtual to return %FALSE
     * for maximum efficiency.
     */
    setOffscreenRedirect(redirect: OffscreenRedirect): void
    /**
     * Sets the actor's opacity, with zero being completely transparent and
     * 255 (0xff) being fully opaque.
     * 
     * The #ClutterActor:opacity property is animatable.
     */
    setOpacity(opacity: number): void
    /**
     * Sets the parent of `self` to `parent`.
     * 
     * This function will result in `parent` acquiring a reference on `self,`
     * eventually by sinking its floating reference first. The reference
     * will be released by clutter_actor_unparent().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    setParent(parent: Actor): void
    /**
     * Sets the position of the #ClutterActor:pivot-point around which the
     * scaling and rotation transformations occur.
     * 
     * The pivot point's coordinates are in normalized space, with the (0, 0)
     * point being the top left corner of the actor, and the (1, 1) point being
     * the bottom right corner.
     */
    setPivotPoint(pivotX: number, pivotY: number): void
    /**
     * Sets the component on the Z axis of the #ClutterActor:pivot-point around
     * which the scaling and rotation transformations occur.
     * 
     * The `pivot_z` value is expressed as a distance along the Z axis.
     */
    setPivotPointZ(pivotZ: number): void
    /**
     * Sets the actor's fixed position in pixels relative to any parent
     * actor.
     * 
     * If a layout manager is in use, this position will override the
     * layout manager and force a fixed position.
     */
    setPosition(x: number, y: number): void
    /**
     * Sets `actor` as reactive. Reactive actors will receive events.
     */
    setReactive(reactive: boolean): void
    /**
     * Sets the geometry request mode of `self`.
     * 
     * The `mode` determines the order for invoking
     * clutter_actor_get_preferred_width() and
     * clutter_actor_get_preferred_height()
     */
    setRequestMode(mode: RequestMode): void
    /**
     * Sets the rotation angle of `self` around the given axis.
     * 
     * The rotation center coordinates used depend on the value of `axis:`
     * 
     *  - %CLUTTER_X_AXIS requires `y` and `z`
     *  - %CLUTTER_Y_AXIS requires `x` and `z`
     *  - %CLUTTER_Z_AXIS requires `x` and `y`
     * 
     * The rotation coordinates are relative to the anchor point of the
     * actor, set using clutter_actor_set_anchor_point(). If no anchor
     * point is set, the upper left corner is assumed as the origin.
     */
    setRotation(axis: RotateAxis, angle: number, x: number, y: number, z: number): void
    /**
     * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
     * 
     * This function is a convenience for setting the rotation properties
     * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
     * and #ClutterActor:rotation-angle-z.
     * 
     * The center of rotation is established by the #ClutterActor:pivot-point
     * property.
     */
    setRotationAngle(axis: RotateAxis, angle: number): void
    /**
     * Scales an actor with the given factors.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScale(scaleX: number, scaleY: number): void
    /**
     * Scales an actor with the given factors around the given center
     * point. The center point is specified in pixels relative to the
     * anchor point (usually the top left corner of the actor).
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
     * are animatable.
     */
    setScaleFull(scaleX: number, scaleY: number, centerX: number, centerY: number): void
    /**
     * Scales an actor with the given factors around the given
     * center point. The center point is specified as one of the compass
     * directions in #ClutterGravity. For example, setting it to north
     * will cause the top of the actor to remain unchanged and the rest of
     * the actor to expand left, right and downwards.
     * 
     * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
     * animatable.
     */
    setScaleWithGravity(scaleX: number, scaleY: number, gravity: Gravity): void
    /**
     * Scales an actor on the Z axis by the given `scale_z` factor.
     * 
     * The scale transformation is relative the the #ClutterActor:pivot-point.
     * 
     * The #ClutterActor:scale-z property is animatable.
     */
    setScaleZ(scaleZ: number): void
    /**
     * Sets the #ClutterShader to be used when rendering `self`.
     * 
     * If `shader` is %NULL this function will unset any currently set shader
     * for the actor.
     * 
     * Any #ClutterEffect applied to `self` will take the precedence
     * over the #ClutterShader set using this function.
     */
    setShader(shader?: Shader | null): boolean
    /**
     * Sets the value for a named parameter of the shader applied
     * to `actor`.
     */
    setShaderParam(param: string, value: any): void
    /**
     * Sets the value for a named float parameter of the shader applied
     * to `actor`.
     */
    setShaderParamFloat(param: string, value: number): void
    /**
     * Sets the value for a named int parameter of the shader applied to
     * `actor`.
     */
    setShaderParamInt(param: string, value: number): void
    /**
     * Sets the actor's size request in pixels. This overrides any
     * "normal" size request the actor would have. For example
     * a text actor might normally request the size of the text;
     * this function would force a specific size instead.
     * 
     * If `width` and/or `height` are -1 the actor will use its
     * "normal" size request instead of overriding it, i.e.
     * you can "unset" the size with -1.
     * 
     * This function sets or unsets both the minimum and natural size.
     */
    setSize(width: number, height: number): void
    /**
     * Sets the #ClutterTextDirection for an actor
     * 
     * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
     * 
     * If `self` implements #ClutterContainer then this function will recurse
     * inside all the children of `self` (including the internal ones).
     * 
     * Composite actors not implementing #ClutterContainer, or actors requiring
     * special handling when the text direction changes, should connect to
     * the #GObject::notify signal for the #ClutterActor:text-direction property
     */
    setTextDirection(textDir: TextDirection): void
    /**
     * Overrides the transformations of a #ClutterActor with a custom
     * matrix, which will be applied relative to the origin of the
     * actor's allocation and to the actor's pivot point.
     * 
     * The #ClutterActor:transform property is animatable.
     */
    setTransform(transform?: Matrix | null): void
    /**
     * Sets an additional translation transformation on a #ClutterActor,
     * relative to the #ClutterActor:pivot-point.
     */
    setTranslation(translateX: number, translateY: number, translateZ: number): void
    /**
     * Forces a width on an actor, causing the actor's preferred width
     * and height (if any) to be ignored.
     * 
     * If `width` is -1 the actor will use its preferred width request
     * instead of overriding it, i.e. you can "unset" the width with -1.
     * 
     * This function sets both the minimum and natural size of the actor.
     */
    setWidth(width: number): void
    /**
     * Sets the actor's X coordinate, relative to its parent, in pixels.
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:x property is animatable.
     */
    setX(x: number): void
    /**
     * Sets the horizontal alignment policy of a #ClutterActor, in case the
     * actor received extra horizontal space.
     * 
     * See also the #ClutterActor:x-align property.
     */
    setXAlign(xAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setXExpand(expand: boolean): void
    /**
     * Sets the actor's Y coordinate, relative to its parent, in pixels.#
     * 
     * Overrides any layout manager and forces a fixed position for
     * the actor.
     * 
     * The #ClutterActor:y property is animatable.
     */
    setY(y: number): void
    /**
     * Sets the vertical alignment policy of a #ClutterActor, in case the
     * actor received extra vertical space.
     * 
     * See also the #ClutterActor:y-align property.
     */
    setYAlign(yAlign: ActorAlign): void
    /**
     * Sets whether a #ClutterActor should expand horizontally; this means
     * that layout manager should allocate extra space for the actor, if
     * possible.
     * 
     * Setting an actor to expand will also make all its parent expand, so
     * that it's possible to build an actor tree and only set this flag on
     * its leaves and not on every single actor.
     */
    setYExpand(expand: boolean): void
    /**
     * Sets the actor's position on the Z axis.
     * 
     * See #ClutterActor:z-position.
     */
    setZPosition(zPosition: number): void
    /**
     * Sets the rotation angle of `self` around the Z axis using the center
     * point specified as a compass point. For example to rotate such that
     * the center of the actor remains static you can use
     * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
     * will move accordingly.
     */
    setZRotationFromGravity(angle: number, gravity: Gravity): void
    /**
     * Should be called inside the implementation of the
     * #ClutterActor::pick virtual function in order to check whether
     * the actor should paint itself in pick mode or not.
     * 
     * This function should never be called directly by applications.
     */
    shouldPickPaint(): boolean
    /**
     * Flags an actor to be displayed. An actor that isn't shown will not
     * be rendered on the stage.
     * 
     * Actors are visible by default.
     * 
     * If this function is called on an actor without a parent, the
     * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
     * effect.
     */
    show(): void
    /**
     * Calls clutter_actor_show() on all children of an actor (if any).
     */
    showAll(): void
    /**
     * This function translates screen coordinates (`x,` `y)` to
     * coordinates relative to the actor. For example, it can be used to translate
     * screen events from global screen coordinates into actor-local coordinates.
     * 
     * The conversion can fail, notably if the transform stack results in the
     * actor being projected on the screen as a mere line.
     * 
     * The conversion should not be expected to be pixel-perfect due to the
     * nature of the operation. In general the error grows when the skewing
     * of the actor rectangle on screen increases.
     * 
     * This function can be computationally intensive.
     * 
     * This function only works when the allocation is up-to-date, i.e. inside of
     * the #ClutterActorClass.paint() implementation
     */
    transformStagePoint(x: number, y: number): [ /* returnType */ boolean, /* xOut */ number, /* yOut */ number ]
    /**
     * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
     * unmaps its children if they were mapped.
     * 
     * Calling this function is not encouraged: the default #ClutterActor
     * implementation of #ClutterActorClass.unmap() will also unmap any
     * eventual children by default when their parent is unmapped.
     * 
     * When overriding #ClutterActorClass.unmap(), it is mandatory to
     * chain up to the parent implementation.
     * 
     * It is important to note that the implementation of the
     * #ClutterActorClass.unmap() virtual function may be called after
     * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
     * implementation, but it is guaranteed to be called before the
     * #GObjectClass.finalize() implementation.
     */
    unmap(): void
    /**
     * Removes the parent of `self`.
     * 
     * This will cause the parent of `self` to release the reference
     * acquired when calling clutter_actor_set_parent(), so if you
     * want to keep `self` you will have to acquire a reference of
     * your own, through g_object_ref().
     * 
     * This function should only be called by legacy #ClutterActor<!-- -->s
     * implementing the #ClutterContainer interface.
     */
    unparent(): void
    /**
     * Unrealization informs the actor that it may be being destroyed or
     * moved to another stage. The actor may want to destroy any
     * underlying graphics resources at this point. However it is
     * perfectly acceptable for it to retain the resources until the actor
     * is destroyed because Clutter only ever uses a single rendering
     * context and all of the graphics resources are valid on any stage.
     * 
     * Because mapped actors must be realized, actors may not be
     * unrealized if they are mapped. This function hides the actor to be
     * sure it isn't mapped, an application-visible side effect that you
     * may not be expecting.
     * 
     * This function should not be called by application code.
     * 
     * This function should not really be in the public API, because
     * there isn't a good reason to call it. ClutterActor will already
     * unrealize things for you when it's important to do so.
     * 
     * If you were using clutter_actor_unrealize() in a dispose
     * implementation, then don't, just chain up to ClutterActor's
     * dispose.
     * 
     * If you were using clutter_actor_unrealize() to implement
     * unrealizing children of your container, then don't, ClutterActor
     * will already take care of that.
     */
    unrealize(): void
    /**
     * Unsets `flags` on `self`
     * 
     * This function will emit notifications for the changed properties
     */
    unsetFlags(flags: ActorFlags): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Animatable */
    /**
     * Calls the animate_property() virtual function for `animatable`.
     * 
     * The `initial_value` and `final_value` #GValue<!-- -->s must contain
     * the same type; `value` must have been initialized to the same
     * type of `initial_value` and `final_value`.
     * 
     * All implementation of the #ClutterAnimatable interface must
     * implement this function.
     */
    animateProperty(animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any): boolean
    /**
     * Finds the #GParamSpec for `property_name`
     */
    findProperty(propertyName: string): GObject.ParamSpec
    /**
     * Retrieves the current state of `property_name` and sets `value` with it
     */
    getInitialState(propertyName: string, value: any): void
    /**
     * Asks a #ClutterAnimatable implementation to interpolate a
     * a named property between the initial and final values of
     * a #ClutterInterval, using `progress` as the interpolation
     * value, and store the result inside `value`.
     * 
     * This function should be used for every property animation
     * involving #ClutterAnimatable<!-- -->s.
     * 
     * This function replaces clutter_animatable_animate_property().
     */
    interpolateValue(propertyName: string, interval: Interval, progress: number): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets the current state of `property_name` to `value`
     */
    setFinalState(propertyName: string, value: any): void
    /* Methods of Clutter-1.0.Clutter.Container */
    /**
     * Adds a #ClutterActor to `container`. This function will emit the
     * "actor-added" signal. The actor should be parented to
     * `container`. You cannot add a #ClutterActor to more than one
     * #ClutterContainer.
     * 
     * This function will call #ClutterContainerIface.add(), which is a
     * deprecated virtual function. The default implementation will
     * call clutter_actor_add_child().
     */
    addActor(actor: Actor): void
    /**
     * Gets a container specific property of a child of `container,` In general,
     * a copy is made of the property contents and the caller is responsible for
     * freeing the memory by calling g_value_unset().
     * 
     * Note that clutter_container_child_set_property() is really intended for
     * language bindings, clutter_container_child_set() is much more convenient
     * for C programming.
     */
    childGetProperty(child: Actor, property: string, value: any): void
    /**
     * Calls the #ClutterContainerIface.child_notify() virtual function
     * of #ClutterContainer. The default implementation will emit the
     * #ClutterContainer::child-notify signal.
     */
    childNotify(child: Actor, pspec: GObject.ParamSpec): void
    /**
     * Sets a container-specific property on a child of `container`.
     */
    childSetProperty(child: Actor, property: string, value: any): void
    /**
     * Creates the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if the #ClutterContainerIface::child_meta_type
     * class member is not set to %G_TYPE_INVALID.
     * 
     * This function is only useful when adding a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    createChildMeta(actor: Actor): void
    /**
     * Destroys the #ClutterChildMeta wrapping `actor` inside the
     * `container,` if any.
     * 
     * This function is only useful when removing a #ClutterActor to
     * a #ClutterContainer implementation outside of the
     * #ClutterContainer::add() virtual function implementation.
     * 
     * Applications should not call this function.
     */
    destroyChildMeta(actor: Actor): void
    /**
     * Finds a child actor of a container by its name. Search recurses
     * into any child container.
     */
    findChildByName(childName: string): Actor
    /**
     * Calls `callback` for each child of `container` that was added
     * by the application (with clutter_container_add_actor()). Does
     * not iterate over "internal" children that are part of the
     * container's own implementation, if any.
     * 
     * This function calls the #ClutterContainerIface.foreach()
     * virtual function, which has been deprecated.
     */
    foreach(callback: Callback): void
    /**
     * Calls `callback` for each child of `container,` including "internal"
     * children built in to the container itself that were never added
     * by the application.
     * 
     * This function calls the #ClutterContainerIface.foreach_with_internals()
     * virtual function, which has been deprecated.
     */
    foreachWithInternals(callback: Callback): void
    /**
     * Retrieves the #ClutterChildMeta which contains the data about the
     * `container` specific state for `actor`.
     */
    getChildMeta(actor: Actor): ChildMeta
    /**
     * Lowers `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.lower() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_below_sibling().
     */
    lowerChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Raises `actor` to `sibling` level, in the depth ordering.
     * 
     * This function calls the #ClutterContainerIface.raise() virtual function,
     * which has been deprecated. The default implementation will call
     * clutter_actor_set_child_above_sibling().
     */
    raiseChild(actor: Actor, sibling?: Actor | null): void
    /**
     * Removes `actor` from `container`. The actor should be unparented, so
     * if you want to keep it around you must hold a reference to it
     * yourself, using g_object_ref(). When the actor has been removed,
     * the "actor-removed" signal is emitted by `container`.
     * 
     * This function will call #ClutterContainerIface.remove(), which is a
     * deprecated virtual function. The default implementation will call
     * clutter_actor_remove_child().
     */
    removeActor(actor: Actor): void
    /**
     * Sorts a container's children using their depth. This function should not
     * be normally used by applications.
     */
    sortDepthOrder(): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Texture */
    /**
     * The ::load-finished signal is emitted when a texture load has
     * completed. If there was an error during loading, `error` will
     * be set, otherwise it will be %NULL
     */
    connect(sigName: "load-finished", callback: ((error: GLib.Error) => void)): number
    on(sigName: "load-finished", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "load-finished", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "load-finished", callback: (error: GLib.Error) => void): NodeJS.EventEmitter
    emit(sigName: "load-finished", error: GLib.Error): void
    /**
     * The ::pixbuf-change signal is emitted each time the pixbuf
     * used by `texture` changes.
     */
    connect(sigName: "pixbuf-change", callback: (() => void)): number
    on(sigName: "pixbuf-change", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pixbuf-change", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pixbuf-change", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "pixbuf-change"): void
    /**
     * The ::size-change signal is emitted each time the size of the
     * pixbuf used by `texture` changes.  The new size is given as
     * argument to the callback.
     */
    connect(sigName: "size-change", callback: ((width: number, height: number) => void)): number
    on(sigName: "size-change", callback: (width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "size-change", callback: (width: number, height: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "size-change", callback: (width: number, height: number) => void): NodeJS.EventEmitter
    emit(sigName: "size-change", width: number, height: number): void
    /* Signals of Clutter-1.0.Clutter.Actor */
    /**
     * The ::allocation-changed signal is emitted when the
     * #ClutterActor:allocation property changes. Usually, application
     * code should just use the notifications for the :allocation property
     * but if you want to track the allocation flags as well, for instance
     * to know whether the absolute origin of `actor` changed, then you might
     * want use this signal instead.
     */
    connect(sigName: "allocation-changed", callback: ((box: ActorBox, flags: AllocationFlags) => void)): number
    on(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "allocation-changed", callback: (box: ActorBox, flags: AllocationFlags) => void): NodeJS.EventEmitter
    emit(sigName: "allocation-changed", box: ActorBox, flags: AllocationFlags): void
    /**
     * The ::button-press-event signal is emitted each time a mouse button
     * is pressed on `actor`.
     */
    connect(sigName: "button-press-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-press-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-press-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-press-event", event: ButtonEvent): void
    /**
     * The ::button-release-event signal is emitted each time a mouse button
     * is released on `actor`.
     */
    connect(sigName: "button-release-event", callback: ((event: ButtonEvent) => boolean)): number
    on(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "button-release-event", callback: (event: ButtonEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "button-release-event", callback: (event: ButtonEvent) => void): NodeJS.EventEmitter
    emit(sigName: "button-release-event", event: ButtonEvent): void
    /**
     * The ::captured-event signal is emitted when an event is captured
     * by Clutter. This signal will be emitted starting from the top-level
     * container (the #ClutterStage) to the actor which received the event
     * going down the hierarchy. This signal can be used to intercept every
     * event before the specialized events (like
     * ClutterActor::button-press-event or ::key-released-event) are
     * emitted.
     */
    connect(sigName: "captured-event", callback: ((event: Event) => boolean)): number
    on(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "captured-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "captured-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "captured-event", event: Event): void
    /**
     * The ::destroy signal notifies that all references held on the
     * actor which emitted it should be released.
     * 
     * The ::destroy signal should be used by all holders of a reference
     * on `actor`.
     * 
     * This signal might result in the finalization of the #ClutterActor
     * if all references are released.
     * 
     * Composite actors and actors implementing the #ClutterContainer
     * interface should override the default implementation of the
     * class handler of this signal and call clutter_actor_destroy() on
     * their children. When overriding the default class handler, it is
     * required to chain up to the parent's implementation.
     */
    connect(sigName: "destroy", callback: (() => void)): number
    on(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "destroy", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "destroy", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "destroy"): void
    /**
     * The ::enter-event signal is emitted when the pointer enters the `actor`
     */
    connect(sigName: "enter-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "enter-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "enter-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "enter-event", event: CrossingEvent): void
    /**
     * The ::event signal is emitted each time an event is received
     * by the `actor`. This signal will be emitted on every actor,
     * following the hierarchy chain, until it reaches the top-level
     * container (the #ClutterStage).
     */
    connect(sigName: "event", callback: ((event: Event) => boolean)): number
    on(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "event", event: Event): void
    /**
     * The ::hide signal is emitted when an actor is no longer rendered
     * on the stage.
     */
    connect(sigName: "hide", callback: (() => void)): number
    on(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "hide", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "hide", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "hide"): void
    /**
     * The ::key-focus-in signal is emitted when `actor` receives key focus.
     */
    connect(sigName: "key-focus-in", callback: (() => void)): number
    on(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-in", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-in", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-in"): void
    /**
     * The ::key-focus-out signal is emitted when `actor` loses key focus.
     */
    connect(sigName: "key-focus-out", callback: (() => void)): number
    on(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-focus-out", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-focus-out", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "key-focus-out"): void
    /**
     * The ::key-press-event signal is emitted each time a keyboard button
     * is pressed while `actor` has key focus (see clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-press-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-press-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-press-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-press-event", event: KeyEvent): void
    /**
     * The ::key-release-event signal is emitted each time a keyboard button
     * is released while `actor` has key focus (see
     * clutter_stage_set_key_focus()).
     */
    connect(sigName: "key-release-event", callback: ((event: KeyEvent) => boolean)): number
    on(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "key-release-event", callback: (event: KeyEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "key-release-event", callback: (event: KeyEvent) => void): NodeJS.EventEmitter
    emit(sigName: "key-release-event", event: KeyEvent): void
    /**
     * The ::leave-event signal is emitted when the pointer leaves the `actor`.
     */
    connect(sigName: "leave-event", callback: ((event: CrossingEvent) => boolean)): number
    on(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "leave-event", callback: (event: CrossingEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "leave-event", callback: (event: CrossingEvent) => void): NodeJS.EventEmitter
    emit(sigName: "leave-event", event: CrossingEvent): void
    /**
     * The ::motion-event signal is emitted each time the mouse pointer is
     * moved over `actor`.
     */
    connect(sigName: "motion-event", callback: ((event: MotionEvent) => boolean)): number
    on(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "motion-event", callback: (event: MotionEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "motion-event", callback: (event: MotionEvent) => void): NodeJS.EventEmitter
    emit(sigName: "motion-event", event: MotionEvent): void
    /**
     * The ::paint signal is emitted each time an actor is being painted.
     * 
     * Subclasses of #ClutterActor should override the #ClutterActorClass.paint
     * virtual function paint themselves in that function.
     * 
     * It is strongly discouraged to connect a signal handler to
     * the #ClutterActor::paint signal; if you want to change the paint
     * sequence of an existing #ClutterActor instance, either create a new
     * #ClutterActor class and override the #ClutterActorClass.paint virtual
     * function, or use a #ClutterEffect. The #ClutterActor::paint signal
     * will be removed in a future version of Clutter.
     */
    connect(sigName: "paint", callback: (() => void)): number
    on(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paint", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paint", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paint"): void
    /**
     * This signal is emitted when the parent of the actor changes.
     */
    connect(sigName: "parent-set", callback: ((oldParent?: Actor | null) => void)): number
    on(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parent-set", callback: (oldParent?: Actor | null) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parent-set", callback: (oldParent?: Actor | null) => void): NodeJS.EventEmitter
    emit(sigName: "parent-set", oldParent?: Actor | null): void
    /**
     * The ::pick signal is emitted each time an actor is being painted
     * in "pick mode". The pick mode is used to identify the actor during
     * the event handling phase, or by clutter_stage_get_actor_at_pos().
     * The actor should paint its shape using the passed `pick_color`.
     * 
     * Subclasses of #ClutterActor should override the class signal handler
     * and paint themselves in that function.
     * 
     * It is possible to connect a handler to the ::pick signal in order
     * to set up some custom aspect of a paint in pick mode.
     */
    connect(sigName: "pick", callback: ((color: Color) => void)): number
    on(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pick", callback: (color: Color) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pick", callback: (color: Color) => void): NodeJS.EventEmitter
    emit(sigName: "pick", color: Color): void
    /**
     * The ::queue_redraw signal is emitted when clutter_actor_queue_redraw()
     * is called on `origin`.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a redraw on the parent, thus "bubbling"
     * the redraw queue up through the actor graph. The default
     * implementation for #ClutterStage queues a clutter_stage_ensure_redraw()
     * in a main loop idle handler.
     * 
     * Note that the `origin` actor may be the stage, or a container; it
     * does not have to be a leaf node in the actor graph.
     * 
     * Toolkits embedding a #ClutterStage which require a redraw and
     * relayout cycle can stop the emission of this signal using the
     * GSignal API, redraw the UI and then call clutter_stage_ensure_redraw()
     * themselves, like:
     * 
     * 
     * ```c
     *   static void
     *   on_redraw_complete (gpointer data)
     *   {
     *     ClutterStage *stage = data;
     * 
     *     // execute the Clutter drawing pipeline
     *     clutter_stage_ensure_redraw (stage);
     *   }
     * 
     *   static void
     *   on_stage_queue_redraw (ClutterStage *stage)
     *   {
     *     // this prevents the default handler to run
     *     g_signal_stop_emission_by_name (stage, "queue-redraw");
     * 
     *     // queue a redraw with the host toolkit and call
     *     // a function when the redraw has been completed
     *     queue_a_redraw (G_CALLBACK (on_redraw_complete), stage);
     *   }
     * ```
     * 
     * 
     * Note: This signal is emitted before the Clutter paint
     * pipeline is executed. If you want to know when the pipeline has
     * been completed you should use clutter_threads_add_repaint_func()
     * or clutter_threads_add_repaint_func_full().
     */
    connect(sigName: "queue-redraw", callback: ((origin: Actor) => void)): number
    on(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-redraw", callback: (origin: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-redraw", callback: (origin: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "queue-redraw", origin: Actor): void
    /**
     * The ::queue_layout signal is emitted when clutter_actor_queue_relayout()
     * is called on an actor.
     * 
     * The default implementation for #ClutterActor chains up to the
     * parent actor and queues a relayout on the parent, thus "bubbling"
     * the relayout queue up through the actor graph.
     * 
     * The main purpose of this signal is to allow relayout to be propagated
     * properly in the presence of #ClutterClone actors. Applications will
     * not normally need to connect to this signal.
     */
    connect(sigName: "queue-relayout", callback: (() => void)): number
    on(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "queue-relayout", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "queue-relayout", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "queue-relayout"): void
    /**
     * The ::realize signal is emitted each time an actor is being
     * realized.
     */
    connect(sigName: "realize", callback: (() => void)): number
    on(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "realize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "realize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "realize"): void
    /**
     * The ::scroll-event signal is emitted each time the mouse is
     * scrolled on `actor`
     */
    connect(sigName: "scroll-event", callback: ((event: ScrollEvent) => boolean)): number
    on(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "scroll-event", callback: (event: ScrollEvent) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "scroll-event", callback: (event: ScrollEvent) => void): NodeJS.EventEmitter
    emit(sigName: "scroll-event", event: ScrollEvent): void
    /**
     * The ::show signal is emitted when an actor is visible and
     * rendered on the stage.
     */
    connect(sigName: "show", callback: (() => void)): number
    on(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "show", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "show", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "show"): void
    /**
     * The ::touch-event signal is emitted each time a touch
     * begin/end/update/cancel event.
     */
    connect(sigName: "touch-event", callback: ((event: Event) => boolean)): number
    on(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "touch-event", callback: (event: Event) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "touch-event", callback: (event: Event) => void): NodeJS.EventEmitter
    emit(sigName: "touch-event", event: Event): void
    /**
     * The ::transition-stopped signal is emitted once a transition
     * is stopped; a transition is stopped once it reached its total
     * duration (including eventual repeats), it has been stopped
     * using clutter_timeline_stop(), or it has been removed from the
     * transitions applied on `actor,` using clutter_actor_remove_transition().
     */
    connect(sigName: "transition-stopped", callback: ((name: string, isFinished: boolean) => void)): number
    on(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transition-stopped", callback: (name: string, isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "transition-stopped", name: string, isFinished: boolean): void
    /**
     * The ::transitions-completed signal is emitted once all transitions
     * involving `actor` are complete.
     */
    connect(sigName: "transitions-completed", callback: (() => void)): number
    on(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "transitions-completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "transitions-completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "transitions-completed"): void
    /**
     * The ::unrealize signal is emitted each time an actor is being
     * unrealized.
     */
    connect(sigName: "unrealize", callback: (() => void)): number
    on(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "unrealize", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "unrealize", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "unrealize"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Clutter-1.0.Clutter.Container */
    /**
     * The ::actor-added signal is emitted each time an actor
     * has been added to `container`.
     */
    connect(sigName: "actor-added", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-added", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-added", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-added", actor: Actor): void
    /**
     * The ::actor-removed signal is emitted each time an actor
     * is removed from `container`.
     */
    connect(sigName: "actor-removed", callback: ((actor: Actor) => void)): number
    on(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "actor-removed", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "actor-removed", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "actor-removed", actor: Actor): void
    /**
     * The ::child-notify signal is emitted each time a property is
     * being set through the clutter_container_child_set() and
     * clutter_container_child_set_property() calls.
     */
    connect(sigName: "child-notify", callback: ((actor: Actor, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "child-notify", callback: (actor: Actor, pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "child-notify", actor: Actor, pspec: GObject.ParamSpec): void
    connect(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filter-quality", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filter-quality", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filter-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filter-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filter-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::keep-aspect-ratio", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::keep-aspect-ratio", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::keep-aspect-ratio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::keep-aspect-ratio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::keep-aspect-ratio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::load-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::load-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::load-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::load-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::load-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::load-data-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::load-data-async", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::load-data-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::load-data-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::load-data-async", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pick-with-alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pick-with-alpha", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pick-with-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pick-with-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pick-with-alpha", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pixel-format", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pixel-format", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pixel-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pixel-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pixel-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::sync-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sync-size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::sync-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::sync-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::sync-size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::tile-waste", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tile-waste", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::tile-waste", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::tile-waste", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::tile-waste", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchor-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::anchor-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::background-color-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::background-color-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::child-transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::child-transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-rect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-rect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clip-to-allocation", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::clip-to-allocation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::constraints", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::constraints", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-box", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-box", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::content-repeat", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::content-repeat", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::depth", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::depth", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::effect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::effect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::first-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::first-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-position-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-position-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fixed-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::fixed-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-clip", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-clip", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-pointer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-pointer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-child", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::last-child", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::layout-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::layout-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::magnification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::magnification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mapped", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mapped", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-bottom", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-bottom", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-left", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-left", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-right", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-right", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::margin-top", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::margin-top", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::min-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::min-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::minification-filter", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::minification-filter", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-height-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-height-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::natural-width-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::natural-width-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offscreen-redirect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::offscreen-redirect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::opacity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::opacity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pivot-point-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::pivot-point-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::reactive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::reactive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::realized", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::realized", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-angle-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-angle-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rotation-center-z-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::rotation-center-z-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-center-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-center-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-gravity", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-gravity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scale-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::scale-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-on-set-parent", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::show-on-set-parent", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::text-direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::text-direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transform-set", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transform-set", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::translation-z", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::translation-z", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::visible", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::width", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::width", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::x-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::x-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-align", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-align", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::y-expand", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::y-expand", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::z-position", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::z-position", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Texture_ConstructProps)
    _init (config?: Texture_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Texture
    static newFromActor(actor: Actor): Texture
    static newFromFile(filename: string): Texture
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     */
    static classFindChildProperty(klass: GObject.ObjectClass, propertyName: string): GObject.ParamSpec
    /**
     * Returns an array of #GParamSpec for all child properties.
     */
    static classListChildProperties(klass: GObject.ObjectClass): GObject.ParamSpec[]
    static $gtype: GObject.Type
}
class TextureNode {
    /* Methods of Clutter-1.0.Clutter.PaintNode */
    /**
     * Adds `child` to the list of children of `node`.
     * 
     * This function will acquire a reference on `child`.
     */
    addChild(child: PaintNode): void
    /**
     * Adds a rectangle region to the `node,` as described by the
     * passed `rect`.
     */
    addRectangle(rect: ActorBox): void
    /**
     * Adds a rectangle region to the `node,` with texture coordinates.
     */
    addTextureRectangle(rect: ActorBox, x1: number, y1: number, x2: number, y2: number): void
    /**
     * Acquires a reference on `node`.
     */
    ref(): PaintNode
    /**
     * Sets a user-readable `name` for `node`.
     * 
     * The `name` will be used for debugging purposes.
     * 
     * The `node` will copy the passed string.
     */
    setName(name: string): void
    /**
     * Releases a reference on `node`.
     */
    unref(): void
    static name: string
    static new(texture: Cogl.Texture, color: Color | null, minFilter: ScalingFilter, magFilter: ScalingFilter): TextureNode
    constructor(texture: Cogl.Texture, color: Color | null, minFilter: ScalingFilter, magFilter: ScalingFilter)
    /* Static methods and pseudo-constructors */
    static new(texture: Cogl.Texture, color: Color | null, minFilter: ScalingFilter, magFilter: ScalingFilter): TextureNode
}
interface Timeline_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Timeline */
    /**
     * If the direction of the timeline should be automatically reversed
     * when reaching the end.
     */
    autoReverse?: boolean
    /**
     * A delay, in milliseconds, that should be observed by the
     * timeline before actually starting.
     */
    delay?: number
    /**
     * The direction of the timeline, either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    direction?: TimelineDirection
    /**
     * Duration of the timeline in milliseconds, depending on the
     * ClutterTimeline:fps value.
     */
    duration?: number
    /**
     * Whether the timeline should automatically rewind and restart.
     * 
     * As a side effect, setting this property to %TRUE will set the
     * #ClutterTimeline:repeat-count property to -1, while setting this
     * property to %FALSE will set the #ClutterTimeline:repeat-count
     * property to 0.
     */
    loop?: boolean
    /**
     * Controls the way a #ClutterTimeline computes the normalized progress.
     */
    progressMode?: AnimationMode
    /**
     * Defines how many times the timeline should repeat.
     * 
     * If the repeat count is 0, the timeline does not repeat.
     * 
     * If the repeat count is set to -1, the timeline will repeat until it is
     * stopped.
     */
    repeatCount?: number
}
class Timeline {
    /* Properties of Clutter-1.0.Clutter.Timeline */
    /**
     * If the direction of the timeline should be automatically reversed
     * when reaching the end.
     */
    autoReverse: boolean
    /**
     * A delay, in milliseconds, that should be observed by the
     * timeline before actually starting.
     */
    delay: number
    /**
     * The direction of the timeline, either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    direction: TimelineDirection
    /**
     * Duration of the timeline in milliseconds, depending on the
     * ClutterTimeline:fps value.
     */
    duration: number
    /**
     * Whether the timeline should automatically rewind and restart.
     * 
     * As a side effect, setting this property to %TRUE will set the
     * #ClutterTimeline:repeat-count property to -1, while setting this
     * property to %FALSE will set the #ClutterTimeline:repeat-count
     * property to 0.
     */
    loop: boolean
    /**
     * Controls the way a #ClutterTimeline computes the normalized progress.
     */
    progressMode: AnimationMode
    /**
     * Defines how many times the timeline should repeat.
     * 
     * If the repeat count is 0, the timeline does not repeat.
     * 
     * If the repeat count is set to -1, the timeline will repeat until it is
     * stopped.
     */
    repeatCount: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Timeline */
    /**
     * Adds a named marker that will be hit when the timeline has reached
     * the specified `progress`.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `progress` of its duration,
     * if will emit a ::marker-reached signal for each marker attached to
     * that particular point.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker_at_time()
     */
    addMarker(markerName: string, progress: number): void
    /**
     * Adds a named marker that will be hit when the timeline has been
     * running for `msecs` milliseconds.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `msecs,` it will emit
     * a ::marker-reached signal for each marker attached to that position.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker()
     */
    addMarkerAtTime(markerName: string, msecs: number): void
    /**
     * Advance timeline to the requested point. The point is given as a
     * time in milliseconds since the timeline started.
     * 
     * The `timeline` will not emit the #ClutterTimeline::new-frame
     * signal for the given time. The first ::new-frame signal after the call to
     * clutter_timeline_advance() will be emit the skipped markers.
     */
    advance(msecs: number): void
    /**
     * Advances `timeline` to the time of the given `marker_name`.
     * 
     * Like clutter_timeline_advance(), this function will not
     * emit the #ClutterTimeline::new-frame for the time where `marker_name`
     * is set, nor it will emit #ClutterTimeline::marker-reached for
     * `marker_name`.
     */
    advanceToMarker(markerName: string): void
    /**
     * Create a new #ClutterTimeline instance which has property values
     * matching that of supplied timeline. The cloned timeline will not
     * be started and will not be positioned to the current position of
     * the original `timeline:` you will have to start it with
     * clutter_timeline_start().
     * 
     * The only cloned properties are:
     * 
     *  - #ClutterTimeline:duration
     *  - #ClutterTimeline:loop
     *  - #ClutterTimeline:delay
     *  - #ClutterTimeline:direction
     */
    clone(): Timeline
    /**
     * Retrieves the value set by clutter_timeline_set_auto_reverse().
     */
    getAutoReverse(): boolean
    /**
     * Retrieves the control points for the cubic bezier progress mode.
     */
    getCubicBezierProgress(): [ /* returnType */ boolean, /* c1 */ Point, /* c2 */ Point ]
    /**
     * Retrieves the current repeat for a timeline.
     * 
     * Repeats start at 0.
     */
    getCurrentRepeat(): number
    /**
     * Retrieves the delay set using clutter_timeline_set_delay().
     */
    getDelay(): number
    /**
     * Retrieves the amount of time elapsed since the last
     * ClutterTimeline::new-frame signal.
     * 
     * This function is only useful inside handlers for the ::new-frame
     * signal, and its behaviour is undefined if the timeline is not
     * playing.
     */
    getDelta(): number
    /**
     * Retrieves the direction of the timeline set with
     * clutter_timeline_set_direction().
     */
    getDirection(): TimelineDirection
    /**
     * Retrieves the duration of a #ClutterTimeline in milliseconds.
     * See clutter_timeline_set_duration().
     */
    getDuration(): number
    /**
     * Retrieves the full duration of the `timeline,` taking into account the
     * current value of the #ClutterTimeline:repeat-count property.
     * 
     * If the #ClutterTimeline:repeat-count property is set to -1, this function
     * will return %G_MAXINT64.
     * 
     * The returned value is to be considered a hint, and it's only valid
     * as long as the `timeline` hasn't been changed.
     */
    getDurationHint(): number
    /**
     * Request the current time position of the timeline.
     */
    getElapsedTime(): number
    /**
     * Gets whether `timeline` is looping
     */
    getLoop(): boolean
    /**
     * The position of the timeline in a normalized [-1, 2] interval.
     * 
     * The return value of this function is determined by the progress
     * mode set using clutter_timeline_set_progress_mode(), or by the
     * progress function set using clutter_timeline_set_progress_func().
     */
    getProgress(): number
    /**
     * Retrieves the progress mode set using clutter_timeline_set_progress_mode()
     * or clutter_timeline_set_progress_func().
     */
    getProgressMode(): AnimationMode
    /**
     * Retrieves the number set using clutter_timeline_set_repeat_count().
     */
    getRepeatCount(): number
    /**
     * Retrieves the parameters of the step progress mode used by `timeline`.
     */
    getStepProgress(): [ /* returnType */ boolean, /* nSteps */ number, /* stepMode */ StepMode ]
    /**
     * Checks whether `timeline` has a marker set with the given name.
     */
    hasMarker(markerName: string): boolean
    /**
     * Queries state of a #ClutterTimeline.
     */
    isPlaying(): boolean
    /**
     * Retrieves the list of markers at time `msecs`. If `msecs` is a
     * negative integer, all the markers attached to `timeline` will be
     * returned.
     */
    listMarkers(msecs: number): string[]
    /**
     * Pauses the #ClutterTimeline on current frame
     */
    pause(): void
    /**
     * Removes `marker_name,` if found, from `timeline`.
     */
    removeMarker(markerName: string): void
    /**
     * Rewinds #ClutterTimeline to the first frame if its direction is
     * %CLUTTER_TIMELINE_FORWARD and the last frame if it is
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    rewind(): void
    /**
     * Sets whether `timeline` should reverse the direction after the
     * emission of the #ClutterTimeline::completed signal.
     * 
     * Setting the #ClutterTimeline:auto-reverse property to %TRUE is the
     * equivalent of connecting a callback to the #ClutterTimeline::completed
     * signal and changing the direction of the timeline from that callback;
     * for instance, this code:
     * 
     * |[
     * static void
     * reverse_timeline (ClutterTimeline *timeline)
     * {
     *   ClutterTimelineDirection dir = clutter_timeline_get_direction (timeline);
     * 
     *   if (dir == CLUTTER_TIMELINE_FORWARD)
     *     dir = CLUTTER_TIMELINE_BACKWARD;
     *   else
     *     dir = CLUTTER_TIMELINE_FORWARD;
     * 
     *   clutter_timeline_set_direction (timeline, dir);
     * }
     * ...
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   g_signal_connect (timeline, "completed",
     *                     G_CALLBACK (reverse_timeline),
     *                     NULL);
     * ```
     * 
     * 
     * can be effectively replaced by:
     * 
     * |[
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   clutter_timeline_set_auto_reverse (timeline);
     * ```
     * 
     */
    setAutoReverse(reverse: boolean): void
    /**
     * Sets the #ClutterTimeline:progress-mode of `timeline`
     * to %CLUTTER_CUBIC_BEZIER, and sets the two control
     * points for the cubic bezier.
     * 
     * The cubic bezier curve is between (0, 0) and (1, 1). The X coordinate
     * of the two control points must be in the [ 0, 1 ] range, while the
     * Y coordinate of the two control points can exceed this range.
     */
    setCubicBezierProgress(c1: Point, c2: Point): void
    /**
     * Sets the delay, in milliseconds, before `timeline` should start.
     */
    setDelay(msecs: number): void
    /**
     * Sets the direction of `timeline,` either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    setDirection(direction: TimelineDirection): void
    /**
     * Sets the duration of the timeline, in milliseconds. The speed
     * of the timeline depends on the ClutterTimeline:fps setting.
     */
    setDuration(msecs: number): void
    /**
     * Sets whether `timeline` should loop.
     * 
     * This function is equivalent to calling clutter_timeline_set_repeat_count()
     * with -1 if `loop` is %TRUE, and with 0 if `loop` is %FALSE.
     */
    setLoop(loop: boolean): void
    /**
     * Sets a custom progress function for `timeline`. The progress function will
     * be called by clutter_timeline_get_progress() and will be used to compute
     * the progress value based on the elapsed time and the total duration of the
     * timeline.
     * 
     * If `func` is not %NULL, the #ClutterTimeline:progress-mode property will
     * be set to %CLUTTER_CUSTOM_MODE.
     * 
     * If `func` is %NULL, any previously set progress function will be unset, and
     * the #ClutterTimeline:progress-mode property will be set to %CLUTTER_LINEAR.
     */
    setProgressFunc(func: TimelineProgressFunc | null): void
    /**
     * Sets the progress function using a value from the #ClutterAnimationMode
     * enumeration. The `mode` cannot be %CLUTTER_CUSTOM_MODE or bigger than
     * %CLUTTER_ANIMATION_LAST.
     */
    setProgressMode(mode: AnimationMode): void
    /**
     * Sets the number of times the `timeline` should repeat.
     * 
     * If `count` is 0, the timeline never repeats.
     * 
     * If `count` is -1, the timeline will always repeat until
     * it's stopped.
     */
    setRepeatCount(count: number): void
    /**
     * Sets the #ClutterTimeline:progress-mode of the `timeline` to %CLUTTER_STEPS
     * and provides the parameters of the step function.
     */
    setStepProgress(nSteps: number, stepMode: StepMode): void
    /**
     * Advance timeline by the requested time in milliseconds
     */
    skip(msecs: number): void
    /**
     * Starts the #ClutterTimeline playing.
     */
    start(): void
    /**
     * Stops the #ClutterTimeline and moves to frame 0
     */
    stop(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Timeline */
    /**
     * The #ClutterTimeline::completed signal is emitted when the timeline's
     * elapsed time reaches the value of the #ClutterTimeline:duration
     * property.
     * 
     * This signal will be emitted even if the #ClutterTimeline is set to be
     * repeating.
     * 
     * If you want to get notification on whether the #ClutterTimeline has
     * been stopped or has finished its run, including its eventual repeats,
     * you should use the #ClutterTimeline::stopped signal instead.
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /**
     * The ::marker-reached signal is emitted each time a timeline
     * reaches a marker set with
     * clutter_timeline_add_marker_at_time(). This signal is detailed
     * with the name of the marker as well, so it is possible to connect
     * a callback to the ::marker-reached signal for a specific marker
     * with:
     * 
     * <informalexample><programlisting>
     *   clutter_timeline_add_marker_at_time (timeline, "foo", 500);
     *   clutter_timeline_add_marker_at_time (timeline, "bar", 750);
     * 
     *   g_signal_connect (timeline, "marker-reached",
     *                     G_CALLBACK (each_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::foo",
     *                     G_CALLBACK (foo_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::bar",
     *                     G_CALLBACK (bar_marker_reached), NULL);
     * </programlisting></informalexample>
     * 
     * In the example, the first callback will be invoked for both
     * the "foo" and "bar" marker, while the second and third callbacks
     * will be invoked for the "foo" or "bar" markers, respectively.
     */
    connect(sigName: "marker-reached", callback: ((markerName: string, msecs: number) => void)): number
    on(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "marker-reached", markerName: string, msecs: number): void
    /**
     * The ::new-frame signal is emitted for each timeline running
     * timeline before a new frame is drawn to give animations a chance
     * to update the scene.
     */
    connect(sigName: "new-frame", callback: ((msecs: number) => void)): number
    on(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-frame", callback: (msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "new-frame", msecs: number): void
    /**
     * The ::paused signal is emitted when clutter_timeline_pause() is invoked.
     */
    connect(sigName: "paused", callback: (() => void)): number
    on(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paused", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paused"): void
    /**
     * The ::started signal is emitted when the timeline starts its run.
     * This might be as soon as clutter_timeline_start() is invoked or
     * after the delay set in the ClutterTimeline:delay property has
     * expired.
     */
    connect(sigName: "started", callback: (() => void)): number
    on(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "started", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "started"): void
    /**
     * The #ClutterTimeline::stopped signal is emitted when the timeline
     * has been stopped, either because clutter_timeline_stop() has been
     * called, or because it has been exhausted.
     * 
     * This is different from the #ClutterTimeline::completed signal,
     * which gets emitted after every repeat finishes.
     * 
     * If the #ClutterTimeline has is marked as infinitely repeating,
     * this signal will never be emitted.
     */
    connect(sigName: "stopped", callback: ((isFinished: boolean) => void)): number
    on(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "stopped", callback: (isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "stopped", isFinished: boolean): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Timeline_ConstructProps)
    _init (config?: Timeline_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(msecs: number): Timeline
    static $gtype: GObject.Type
}
interface Transition_ConstructProps extends Timeline_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.Transition */
    /**
     * The #ClutterAnimatable instance currently being animated.
     */
    animatable?: Animatable
    /**
     * The #ClutterInterval used to describe the initial and final states
     * of the transition.
     */
    interval?: Interval
    /**
     * Whether the #ClutterTransition should be automatically detached
     * from the #ClutterTransition:animatable instance whenever the
     * #ClutterTimeline::stopped signal is emitted.
     * 
     * The #ClutterTransition:remove-on-complete property takes into
     * account the value of the #ClutterTimeline:repeat-count property,
     * and it only detaches the transition if the transition is not
     * repeating.
     */
    removeOnComplete?: boolean
}
class Transition {
    /* Properties of Clutter-1.0.Clutter.Transition */
    /**
     * The #ClutterAnimatable instance currently being animated.
     */
    animatable: Animatable
    /**
     * The #ClutterInterval used to describe the initial and final states
     * of the transition.
     */
    interval: Interval
    /**
     * Whether the #ClutterTransition should be automatically detached
     * from the #ClutterTransition:animatable instance whenever the
     * #ClutterTimeline::stopped signal is emitted.
     * 
     * The #ClutterTransition:remove-on-complete property takes into
     * account the value of the #ClutterTimeline:repeat-count property,
     * and it only detaches the transition if the transition is not
     * repeating.
     */
    removeOnComplete: boolean
    /* Properties of Clutter-1.0.Clutter.Timeline */
    /**
     * If the direction of the timeline should be automatically reversed
     * when reaching the end.
     */
    autoReverse: boolean
    /**
     * A delay, in milliseconds, that should be observed by the
     * timeline before actually starting.
     */
    delay: number
    /**
     * The direction of the timeline, either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    direction: TimelineDirection
    /**
     * Duration of the timeline in milliseconds, depending on the
     * ClutterTimeline:fps value.
     */
    duration: number
    /**
     * Whether the timeline should automatically rewind and restart.
     * 
     * As a side effect, setting this property to %TRUE will set the
     * #ClutterTimeline:repeat-count property to -1, while setting this
     * property to %FALSE will set the #ClutterTimeline:repeat-count
     * property to 0.
     */
    loop: boolean
    /**
     * Controls the way a #ClutterTimeline computes the normalized progress.
     */
    progressMode: AnimationMode
    /**
     * Defines how many times the timeline should repeat.
     * 
     * If the repeat count is 0, the timeline does not repeat.
     * 
     * If the repeat count is set to -1, the timeline will repeat until it is
     * stopped.
     */
    repeatCount: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.Transition */
    /**
     * Retrieves the #ClutterAnimatable set using clutter_transition_set_animatable().
     */
    getAnimatable(): Animatable
    /**
     * Retrieves the interval set using clutter_transition_set_interval()
     */
    getInterval(): Interval
    /**
     * Retrieves the value of the #ClutterTransition:remove-on-complete property.
     */
    getRemoveOnComplete(): boolean
    /**
     * Sets the #ClutterTransition:animatable property.
     * 
     * The `transition` will acquire a reference to the `animatable` instance,
     * and will call the #ClutterTransitionClass.attached() virtual function.
     * 
     * If an existing #ClutterAnimatable is attached to `transition,` the
     * reference will be released, and the #ClutterTransitionClass.detached()
     * virtual function will be called.
     */
    setAnimatable(animatable?: Animatable | null): void
    /**
     * Sets the initial value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setFrom(value: any): void
    /**
     * Sets the #ClutterTransition:interval property using `interval`.
     * 
     * The `transition` will acquire a reference on the `interval,` sinking
     * the floating flag on it if necessary.
     */
    setInterval(interval?: Interval | null): void
    /**
     * Sets whether `transition` should be detached from the #ClutterAnimatable
     * set using clutter_transition_set_animatable() when the
     * #ClutterTimeline::completed signal is emitted.
     */
    setRemoveOnComplete(removeComplete: boolean): void
    /**
     * Sets the final value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setTo(value: any): void
    /* Methods of Clutter-1.0.Clutter.Timeline */
    /**
     * Adds a named marker that will be hit when the timeline has reached
     * the specified `progress`.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `progress` of its duration,
     * if will emit a ::marker-reached signal for each marker attached to
     * that particular point.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker_at_time()
     */
    addMarker(markerName: string, progress: number): void
    /**
     * Adds a named marker that will be hit when the timeline has been
     * running for `msecs` milliseconds.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `msecs,` it will emit
     * a ::marker-reached signal for each marker attached to that position.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker()
     */
    addMarkerAtTime(markerName: string, msecs: number): void
    /**
     * Advance timeline to the requested point. The point is given as a
     * time in milliseconds since the timeline started.
     * 
     * The `timeline` will not emit the #ClutterTimeline::new-frame
     * signal for the given time. The first ::new-frame signal after the call to
     * clutter_timeline_advance() will be emit the skipped markers.
     */
    advance(msecs: number): void
    /**
     * Advances `timeline` to the time of the given `marker_name`.
     * 
     * Like clutter_timeline_advance(), this function will not
     * emit the #ClutterTimeline::new-frame for the time where `marker_name`
     * is set, nor it will emit #ClutterTimeline::marker-reached for
     * `marker_name`.
     */
    advanceToMarker(markerName: string): void
    /**
     * Create a new #ClutterTimeline instance which has property values
     * matching that of supplied timeline. The cloned timeline will not
     * be started and will not be positioned to the current position of
     * the original `timeline:` you will have to start it with
     * clutter_timeline_start().
     * 
     * The only cloned properties are:
     * 
     *  - #ClutterTimeline:duration
     *  - #ClutterTimeline:loop
     *  - #ClutterTimeline:delay
     *  - #ClutterTimeline:direction
     */
    clone(): Timeline
    /**
     * Retrieves the value set by clutter_timeline_set_auto_reverse().
     */
    getAutoReverse(): boolean
    /**
     * Retrieves the control points for the cubic bezier progress mode.
     */
    getCubicBezierProgress(): [ /* returnType */ boolean, /* c1 */ Point, /* c2 */ Point ]
    /**
     * Retrieves the current repeat for a timeline.
     * 
     * Repeats start at 0.
     */
    getCurrentRepeat(): number
    /**
     * Retrieves the delay set using clutter_timeline_set_delay().
     */
    getDelay(): number
    /**
     * Retrieves the amount of time elapsed since the last
     * ClutterTimeline::new-frame signal.
     * 
     * This function is only useful inside handlers for the ::new-frame
     * signal, and its behaviour is undefined if the timeline is not
     * playing.
     */
    getDelta(): number
    /**
     * Retrieves the direction of the timeline set with
     * clutter_timeline_set_direction().
     */
    getDirection(): TimelineDirection
    /**
     * Retrieves the duration of a #ClutterTimeline in milliseconds.
     * See clutter_timeline_set_duration().
     */
    getDuration(): number
    /**
     * Retrieves the full duration of the `timeline,` taking into account the
     * current value of the #ClutterTimeline:repeat-count property.
     * 
     * If the #ClutterTimeline:repeat-count property is set to -1, this function
     * will return %G_MAXINT64.
     * 
     * The returned value is to be considered a hint, and it's only valid
     * as long as the `timeline` hasn't been changed.
     */
    getDurationHint(): number
    /**
     * Request the current time position of the timeline.
     */
    getElapsedTime(): number
    /**
     * Gets whether `timeline` is looping
     */
    getLoop(): boolean
    /**
     * The position of the timeline in a normalized [-1, 2] interval.
     * 
     * The return value of this function is determined by the progress
     * mode set using clutter_timeline_set_progress_mode(), or by the
     * progress function set using clutter_timeline_set_progress_func().
     */
    getProgress(): number
    /**
     * Retrieves the progress mode set using clutter_timeline_set_progress_mode()
     * or clutter_timeline_set_progress_func().
     */
    getProgressMode(): AnimationMode
    /**
     * Retrieves the number set using clutter_timeline_set_repeat_count().
     */
    getRepeatCount(): number
    /**
     * Retrieves the parameters of the step progress mode used by `timeline`.
     */
    getStepProgress(): [ /* returnType */ boolean, /* nSteps */ number, /* stepMode */ StepMode ]
    /**
     * Checks whether `timeline` has a marker set with the given name.
     */
    hasMarker(markerName: string): boolean
    /**
     * Queries state of a #ClutterTimeline.
     */
    isPlaying(): boolean
    /**
     * Retrieves the list of markers at time `msecs`. If `msecs` is a
     * negative integer, all the markers attached to `timeline` will be
     * returned.
     */
    listMarkers(msecs: number): string[]
    /**
     * Pauses the #ClutterTimeline on current frame
     */
    pause(): void
    /**
     * Removes `marker_name,` if found, from `timeline`.
     */
    removeMarker(markerName: string): void
    /**
     * Rewinds #ClutterTimeline to the first frame if its direction is
     * %CLUTTER_TIMELINE_FORWARD and the last frame if it is
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    rewind(): void
    /**
     * Sets whether `timeline` should reverse the direction after the
     * emission of the #ClutterTimeline::completed signal.
     * 
     * Setting the #ClutterTimeline:auto-reverse property to %TRUE is the
     * equivalent of connecting a callback to the #ClutterTimeline::completed
     * signal and changing the direction of the timeline from that callback;
     * for instance, this code:
     * 
     * |[
     * static void
     * reverse_timeline (ClutterTimeline *timeline)
     * {
     *   ClutterTimelineDirection dir = clutter_timeline_get_direction (timeline);
     * 
     *   if (dir == CLUTTER_TIMELINE_FORWARD)
     *     dir = CLUTTER_TIMELINE_BACKWARD;
     *   else
     *     dir = CLUTTER_TIMELINE_FORWARD;
     * 
     *   clutter_timeline_set_direction (timeline, dir);
     * }
     * ...
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   g_signal_connect (timeline, "completed",
     *                     G_CALLBACK (reverse_timeline),
     *                     NULL);
     * ```
     * 
     * 
     * can be effectively replaced by:
     * 
     * |[
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   clutter_timeline_set_auto_reverse (timeline);
     * ```
     * 
     */
    setAutoReverse(reverse: boolean): void
    /**
     * Sets the #ClutterTimeline:progress-mode of `timeline`
     * to %CLUTTER_CUBIC_BEZIER, and sets the two control
     * points for the cubic bezier.
     * 
     * The cubic bezier curve is between (0, 0) and (1, 1). The X coordinate
     * of the two control points must be in the [ 0, 1 ] range, while the
     * Y coordinate of the two control points can exceed this range.
     */
    setCubicBezierProgress(c1: Point, c2: Point): void
    /**
     * Sets the delay, in milliseconds, before `timeline` should start.
     */
    setDelay(msecs: number): void
    /**
     * Sets the direction of `timeline,` either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    setDirection(direction: TimelineDirection): void
    /**
     * Sets the duration of the timeline, in milliseconds. The speed
     * of the timeline depends on the ClutterTimeline:fps setting.
     */
    setDuration(msecs: number): void
    /**
     * Sets whether `timeline` should loop.
     * 
     * This function is equivalent to calling clutter_timeline_set_repeat_count()
     * with -1 if `loop` is %TRUE, and with 0 if `loop` is %FALSE.
     */
    setLoop(loop: boolean): void
    /**
     * Sets a custom progress function for `timeline`. The progress function will
     * be called by clutter_timeline_get_progress() and will be used to compute
     * the progress value based on the elapsed time and the total duration of the
     * timeline.
     * 
     * If `func` is not %NULL, the #ClutterTimeline:progress-mode property will
     * be set to %CLUTTER_CUSTOM_MODE.
     * 
     * If `func` is %NULL, any previously set progress function will be unset, and
     * the #ClutterTimeline:progress-mode property will be set to %CLUTTER_LINEAR.
     */
    setProgressFunc(func: TimelineProgressFunc | null): void
    /**
     * Sets the progress function using a value from the #ClutterAnimationMode
     * enumeration. The `mode` cannot be %CLUTTER_CUSTOM_MODE or bigger than
     * %CLUTTER_ANIMATION_LAST.
     */
    setProgressMode(mode: AnimationMode): void
    /**
     * Sets the number of times the `timeline` should repeat.
     * 
     * If `count` is 0, the timeline never repeats.
     * 
     * If `count` is -1, the timeline will always repeat until
     * it's stopped.
     */
    setRepeatCount(count: number): void
    /**
     * Sets the #ClutterTimeline:progress-mode of the `timeline` to %CLUTTER_STEPS
     * and provides the parameters of the step function.
     */
    setStepProgress(nSteps: number, stepMode: StepMode): void
    /**
     * Advance timeline by the requested time in milliseconds
     */
    skip(msecs: number): void
    /**
     * Starts the #ClutterTimeline playing.
     */
    start(): void
    /**
     * Stops the #ClutterTimeline and moves to frame 0
     */
    stop(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Timeline */
    /**
     * The #ClutterTimeline::completed signal is emitted when the timeline's
     * elapsed time reaches the value of the #ClutterTimeline:duration
     * property.
     * 
     * This signal will be emitted even if the #ClutterTimeline is set to be
     * repeating.
     * 
     * If you want to get notification on whether the #ClutterTimeline has
     * been stopped or has finished its run, including its eventual repeats,
     * you should use the #ClutterTimeline::stopped signal instead.
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /**
     * The ::marker-reached signal is emitted each time a timeline
     * reaches a marker set with
     * clutter_timeline_add_marker_at_time(). This signal is detailed
     * with the name of the marker as well, so it is possible to connect
     * a callback to the ::marker-reached signal for a specific marker
     * with:
     * 
     * <informalexample><programlisting>
     *   clutter_timeline_add_marker_at_time (timeline, "foo", 500);
     *   clutter_timeline_add_marker_at_time (timeline, "bar", 750);
     * 
     *   g_signal_connect (timeline, "marker-reached",
     *                     G_CALLBACK (each_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::foo",
     *                     G_CALLBACK (foo_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::bar",
     *                     G_CALLBACK (bar_marker_reached), NULL);
     * </programlisting></informalexample>
     * 
     * In the example, the first callback will be invoked for both
     * the "foo" and "bar" marker, while the second and third callbacks
     * will be invoked for the "foo" or "bar" markers, respectively.
     */
    connect(sigName: "marker-reached", callback: ((markerName: string, msecs: number) => void)): number
    on(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "marker-reached", markerName: string, msecs: number): void
    /**
     * The ::new-frame signal is emitted for each timeline running
     * timeline before a new frame is drawn to give animations a chance
     * to update the scene.
     */
    connect(sigName: "new-frame", callback: ((msecs: number) => void)): number
    on(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-frame", callback: (msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "new-frame", msecs: number): void
    /**
     * The ::paused signal is emitted when clutter_timeline_pause() is invoked.
     */
    connect(sigName: "paused", callback: (() => void)): number
    on(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paused", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paused"): void
    /**
     * The ::started signal is emitted when the timeline starts its run.
     * This might be as soon as clutter_timeline_start() is invoked or
     * after the delay set in the ClutterTimeline:delay property has
     * expired.
     */
    connect(sigName: "started", callback: (() => void)): number
    on(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "started", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "started"): void
    /**
     * The #ClutterTimeline::stopped signal is emitted when the timeline
     * has been stopped, either because clutter_timeline_stop() has been
     * called, or because it has been exhausted.
     * 
     * This is different from the #ClutterTimeline::completed signal,
     * which gets emitted after every repeat finishes.
     * 
     * If the #ClutterTimeline has is marked as infinitely repeating,
     * this signal will never be emitted.
     */
    connect(sigName: "stopped", callback: ((isFinished: boolean) => void)): number
    on(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "stopped", callback: (isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "stopped", isFinished: boolean): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Transition_ConstructProps)
    _init (config?: Transition_ConstructProps): void
    static $gtype: GObject.Type
}
interface TransitionGroup_ConstructProps extends Transition_ConstructProps {
}
class TransitionGroup {
    /* Properties of Clutter-1.0.Clutter.Transition */
    /**
     * The #ClutterAnimatable instance currently being animated.
     */
    animatable: Animatable
    /**
     * The #ClutterInterval used to describe the initial and final states
     * of the transition.
     */
    interval: Interval
    /**
     * Whether the #ClutterTransition should be automatically detached
     * from the #ClutterTransition:animatable instance whenever the
     * #ClutterTimeline::stopped signal is emitted.
     * 
     * The #ClutterTransition:remove-on-complete property takes into
     * account the value of the #ClutterTimeline:repeat-count property,
     * and it only detaches the transition if the transition is not
     * repeating.
     */
    removeOnComplete: boolean
    /* Properties of Clutter-1.0.Clutter.Timeline */
    /**
     * If the direction of the timeline should be automatically reversed
     * when reaching the end.
     */
    autoReverse: boolean
    /**
     * A delay, in milliseconds, that should be observed by the
     * timeline before actually starting.
     */
    delay: number
    /**
     * The direction of the timeline, either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    direction: TimelineDirection
    /**
     * Duration of the timeline in milliseconds, depending on the
     * ClutterTimeline:fps value.
     */
    duration: number
    /**
     * Whether the timeline should automatically rewind and restart.
     * 
     * As a side effect, setting this property to %TRUE will set the
     * #ClutterTimeline:repeat-count property to -1, while setting this
     * property to %FALSE will set the #ClutterTimeline:repeat-count
     * property to 0.
     */
    loop: boolean
    /**
     * Controls the way a #ClutterTimeline computes the normalized progress.
     */
    progressMode: AnimationMode
    /**
     * Defines how many times the timeline should repeat.
     * 
     * If the repeat count is 0, the timeline does not repeat.
     * 
     * If the repeat count is set to -1, the timeline will repeat until it is
     * stopped.
     */
    repeatCount: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.TransitionGroup */
    /**
     * Adds `transition` to `group`.
     * 
     * This function acquires a reference on `transition` that will be released
     * when calling clutter_transition_group_remove_transition().
     */
    addTransition(transition: Transition): void
    /**
     * Removes all transitions from `group`.
     * 
     * This function releases the reference acquired when calling
     * clutter_transition_group_add_transition().
     */
    removeAll(): void
    /**
     * Removes `transition` from `group`.
     * 
     * This function releases the reference acquired on `transition` when
     * calling clutter_transition_group_add_transition().
     */
    removeTransition(transition: Transition): void
    /* Methods of Clutter-1.0.Clutter.Transition */
    /**
     * Retrieves the #ClutterAnimatable set using clutter_transition_set_animatable().
     */
    getAnimatable(): Animatable
    /**
     * Retrieves the interval set using clutter_transition_set_interval()
     */
    getInterval(): Interval
    /**
     * Retrieves the value of the #ClutterTransition:remove-on-complete property.
     */
    getRemoveOnComplete(): boolean
    /**
     * Sets the #ClutterTransition:animatable property.
     * 
     * The `transition` will acquire a reference to the `animatable` instance,
     * and will call the #ClutterTransitionClass.attached() virtual function.
     * 
     * If an existing #ClutterAnimatable is attached to `transition,` the
     * reference will be released, and the #ClutterTransitionClass.detached()
     * virtual function will be called.
     */
    setAnimatable(animatable?: Animatable | null): void
    /**
     * Sets the initial value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setFrom(value: any): void
    /**
     * Sets the #ClutterTransition:interval property using `interval`.
     * 
     * The `transition` will acquire a reference on the `interval,` sinking
     * the floating flag on it if necessary.
     */
    setInterval(interval?: Interval | null): void
    /**
     * Sets whether `transition` should be detached from the #ClutterAnimatable
     * set using clutter_transition_set_animatable() when the
     * #ClutterTimeline::completed signal is emitted.
     */
    setRemoveOnComplete(removeComplete: boolean): void
    /**
     * Sets the final value of the transition.
     * 
     * This is a convenience function that will either create the
     * #ClutterInterval used by `transition,` or will update it if
     * the #ClutterTransition:interval is already set.
     * 
     * This function will copy the contents of `value,` so it is
     * safe to call g_value_unset() after it returns.
     * 
     * If `transition` already has a #ClutterTransition:interval set,
     * then `value` must hold the same type, or a transformable type,
     * as the interval's #ClutterInterval:value-type property.
     * 
     * This function is meant to be used by language bindings.
     */
    setTo(value: any): void
    /* Methods of Clutter-1.0.Clutter.Timeline */
    /**
     * Adds a named marker that will be hit when the timeline has reached
     * the specified `progress`.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `progress` of its duration,
     * if will emit a ::marker-reached signal for each marker attached to
     * that particular point.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker_at_time()
     */
    addMarker(markerName: string, progress: number): void
    /**
     * Adds a named marker that will be hit when the timeline has been
     * running for `msecs` milliseconds.
     * 
     * Markers are unique string identifiers for a given position on the
     * timeline. Once `timeline` reaches the given `msecs,` it will emit
     * a ::marker-reached signal for each marker attached to that position.
     * 
     * A marker can be removed with clutter_timeline_remove_marker(). The
     * timeline can be advanced to a marker using
     * clutter_timeline_advance_to_marker().
     * 
     * See also: clutter_timeline_add_marker()
     */
    addMarkerAtTime(markerName: string, msecs: number): void
    /**
     * Advance timeline to the requested point. The point is given as a
     * time in milliseconds since the timeline started.
     * 
     * The `timeline` will not emit the #ClutterTimeline::new-frame
     * signal for the given time. The first ::new-frame signal after the call to
     * clutter_timeline_advance() will be emit the skipped markers.
     */
    advance(msecs: number): void
    /**
     * Advances `timeline` to the time of the given `marker_name`.
     * 
     * Like clutter_timeline_advance(), this function will not
     * emit the #ClutterTimeline::new-frame for the time where `marker_name`
     * is set, nor it will emit #ClutterTimeline::marker-reached for
     * `marker_name`.
     */
    advanceToMarker(markerName: string): void
    /**
     * Create a new #ClutterTimeline instance which has property values
     * matching that of supplied timeline. The cloned timeline will not
     * be started and will not be positioned to the current position of
     * the original `timeline:` you will have to start it with
     * clutter_timeline_start().
     * 
     * The only cloned properties are:
     * 
     *  - #ClutterTimeline:duration
     *  - #ClutterTimeline:loop
     *  - #ClutterTimeline:delay
     *  - #ClutterTimeline:direction
     */
    clone(): Timeline
    /**
     * Retrieves the value set by clutter_timeline_set_auto_reverse().
     */
    getAutoReverse(): boolean
    /**
     * Retrieves the control points for the cubic bezier progress mode.
     */
    getCubicBezierProgress(): [ /* returnType */ boolean, /* c1 */ Point, /* c2 */ Point ]
    /**
     * Retrieves the current repeat for a timeline.
     * 
     * Repeats start at 0.
     */
    getCurrentRepeat(): number
    /**
     * Retrieves the delay set using clutter_timeline_set_delay().
     */
    getDelay(): number
    /**
     * Retrieves the amount of time elapsed since the last
     * ClutterTimeline::new-frame signal.
     * 
     * This function is only useful inside handlers for the ::new-frame
     * signal, and its behaviour is undefined if the timeline is not
     * playing.
     */
    getDelta(): number
    /**
     * Retrieves the direction of the timeline set with
     * clutter_timeline_set_direction().
     */
    getDirection(): TimelineDirection
    /**
     * Retrieves the duration of a #ClutterTimeline in milliseconds.
     * See clutter_timeline_set_duration().
     */
    getDuration(): number
    /**
     * Retrieves the full duration of the `timeline,` taking into account the
     * current value of the #ClutterTimeline:repeat-count property.
     * 
     * If the #ClutterTimeline:repeat-count property is set to -1, this function
     * will return %G_MAXINT64.
     * 
     * The returned value is to be considered a hint, and it's only valid
     * as long as the `timeline` hasn't been changed.
     */
    getDurationHint(): number
    /**
     * Request the current time position of the timeline.
     */
    getElapsedTime(): number
    /**
     * Gets whether `timeline` is looping
     */
    getLoop(): boolean
    /**
     * The position of the timeline in a normalized [-1, 2] interval.
     * 
     * The return value of this function is determined by the progress
     * mode set using clutter_timeline_set_progress_mode(), or by the
     * progress function set using clutter_timeline_set_progress_func().
     */
    getProgress(): number
    /**
     * Retrieves the progress mode set using clutter_timeline_set_progress_mode()
     * or clutter_timeline_set_progress_func().
     */
    getProgressMode(): AnimationMode
    /**
     * Retrieves the number set using clutter_timeline_set_repeat_count().
     */
    getRepeatCount(): number
    /**
     * Retrieves the parameters of the step progress mode used by `timeline`.
     */
    getStepProgress(): [ /* returnType */ boolean, /* nSteps */ number, /* stepMode */ StepMode ]
    /**
     * Checks whether `timeline` has a marker set with the given name.
     */
    hasMarker(markerName: string): boolean
    /**
     * Queries state of a #ClutterTimeline.
     */
    isPlaying(): boolean
    /**
     * Retrieves the list of markers at time `msecs`. If `msecs` is a
     * negative integer, all the markers attached to `timeline` will be
     * returned.
     */
    listMarkers(msecs: number): string[]
    /**
     * Pauses the #ClutterTimeline on current frame
     */
    pause(): void
    /**
     * Removes `marker_name,` if found, from `timeline`.
     */
    removeMarker(markerName: string): void
    /**
     * Rewinds #ClutterTimeline to the first frame if its direction is
     * %CLUTTER_TIMELINE_FORWARD and the last frame if it is
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    rewind(): void
    /**
     * Sets whether `timeline` should reverse the direction after the
     * emission of the #ClutterTimeline::completed signal.
     * 
     * Setting the #ClutterTimeline:auto-reverse property to %TRUE is the
     * equivalent of connecting a callback to the #ClutterTimeline::completed
     * signal and changing the direction of the timeline from that callback;
     * for instance, this code:
     * 
     * |[
     * static void
     * reverse_timeline (ClutterTimeline *timeline)
     * {
     *   ClutterTimelineDirection dir = clutter_timeline_get_direction (timeline);
     * 
     *   if (dir == CLUTTER_TIMELINE_FORWARD)
     *     dir = CLUTTER_TIMELINE_BACKWARD;
     *   else
     *     dir = CLUTTER_TIMELINE_FORWARD;
     * 
     *   clutter_timeline_set_direction (timeline, dir);
     * }
     * ...
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   g_signal_connect (timeline, "completed",
     *                     G_CALLBACK (reverse_timeline),
     *                     NULL);
     * ```
     * 
     * 
     * can be effectively replaced by:
     * 
     * |[
     *   timeline = clutter_timeline_new (1000);
     *   clutter_timeline_set_repeat_count (timeline, -1);
     *   clutter_timeline_set_auto_reverse (timeline);
     * ```
     * 
     */
    setAutoReverse(reverse: boolean): void
    /**
     * Sets the #ClutterTimeline:progress-mode of `timeline`
     * to %CLUTTER_CUBIC_BEZIER, and sets the two control
     * points for the cubic bezier.
     * 
     * The cubic bezier curve is between (0, 0) and (1, 1). The X coordinate
     * of the two control points must be in the [ 0, 1 ] range, while the
     * Y coordinate of the two control points can exceed this range.
     */
    setCubicBezierProgress(c1: Point, c2: Point): void
    /**
     * Sets the delay, in milliseconds, before `timeline` should start.
     */
    setDelay(msecs: number): void
    /**
     * Sets the direction of `timeline,` either %CLUTTER_TIMELINE_FORWARD or
     * %CLUTTER_TIMELINE_BACKWARD.
     */
    setDirection(direction: TimelineDirection): void
    /**
     * Sets the duration of the timeline, in milliseconds. The speed
     * of the timeline depends on the ClutterTimeline:fps setting.
     */
    setDuration(msecs: number): void
    /**
     * Sets whether `timeline` should loop.
     * 
     * This function is equivalent to calling clutter_timeline_set_repeat_count()
     * with -1 if `loop` is %TRUE, and with 0 if `loop` is %FALSE.
     */
    setLoop(loop: boolean): void
    /**
     * Sets a custom progress function for `timeline`. The progress function will
     * be called by clutter_timeline_get_progress() and will be used to compute
     * the progress value based on the elapsed time and the total duration of the
     * timeline.
     * 
     * If `func` is not %NULL, the #ClutterTimeline:progress-mode property will
     * be set to %CLUTTER_CUSTOM_MODE.
     * 
     * If `func` is %NULL, any previously set progress function will be unset, and
     * the #ClutterTimeline:progress-mode property will be set to %CLUTTER_LINEAR.
     */
    setProgressFunc(func: TimelineProgressFunc | null): void
    /**
     * Sets the progress function using a value from the #ClutterAnimationMode
     * enumeration. The `mode` cannot be %CLUTTER_CUSTOM_MODE or bigger than
     * %CLUTTER_ANIMATION_LAST.
     */
    setProgressMode(mode: AnimationMode): void
    /**
     * Sets the number of times the `timeline` should repeat.
     * 
     * If `count` is 0, the timeline never repeats.
     * 
     * If `count` is -1, the timeline will always repeat until
     * it's stopped.
     */
    setRepeatCount(count: number): void
    /**
     * Sets the #ClutterTimeline:progress-mode of the `timeline` to %CLUTTER_STEPS
     * and provides the parameters of the step function.
     */
    setStepProgress(nSteps: number, stepMode: StepMode): void
    /**
     * Advance timeline by the requested time in milliseconds
     */
    skip(msecs: number): void
    /**
     * Starts the #ClutterTimeline playing.
     */
    start(): void
    /**
     * Stops the #ClutterTimeline and moves to frame 0
     */
    stop(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Clutter-1.0.Clutter.Scriptable */
    /**
     * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
     */
    getId(): string
    /**
     * Parses the passed JSON node. The implementation must set the type
     * of the passed #GValue pointer using g_value_init().
     */
    parseCustomNode(script: Script, value: any, name: string, node: Json.Node): boolean
    /**
     * Overrides the common properties setting. The underlying virtual
     * function should be used when implementing custom properties.
     */
    setCustomProperty(script: Script, name: string, value: any): void
    /**
     * Sets `id_` as the unique Clutter script it for this instance of
     * #ClutterScriptableIface.
     * 
     * This name can be used by user interface designer applications to
     * define a unique name for an object constructable using the UI
     * definition language parsed by #ClutterScript.
     */
    setId(id: string): void
    /* Signals of Clutter-1.0.Clutter.Timeline */
    /**
     * The #ClutterTimeline::completed signal is emitted when the timeline's
     * elapsed time reaches the value of the #ClutterTimeline:duration
     * property.
     * 
     * This signal will be emitted even if the #ClutterTimeline is set to be
     * repeating.
     * 
     * If you want to get notification on whether the #ClutterTimeline has
     * been stopped or has finished its run, including its eventual repeats,
     * you should use the #ClutterTimeline::stopped signal instead.
     */
    connect(sigName: "completed", callback: (() => void)): number
    on(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "completed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "completed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "completed"): void
    /**
     * The ::marker-reached signal is emitted each time a timeline
     * reaches a marker set with
     * clutter_timeline_add_marker_at_time(). This signal is detailed
     * with the name of the marker as well, so it is possible to connect
     * a callback to the ::marker-reached signal for a specific marker
     * with:
     * 
     * <informalexample><programlisting>
     *   clutter_timeline_add_marker_at_time (timeline, "foo", 500);
     *   clutter_timeline_add_marker_at_time (timeline, "bar", 750);
     * 
     *   g_signal_connect (timeline, "marker-reached",
     *                     G_CALLBACK (each_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::foo",
     *                     G_CALLBACK (foo_marker_reached), NULL);
     *   g_signal_connect (timeline, "marker-reached::bar",
     *                     G_CALLBACK (bar_marker_reached), NULL);
     * </programlisting></informalexample>
     * 
     * In the example, the first callback will be invoked for both
     * the "foo" and "bar" marker, while the second and third callbacks
     * will be invoked for the "foo" or "bar" markers, respectively.
     */
    connect(sigName: "marker-reached", callback: ((markerName: string, msecs: number) => void)): number
    on(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "marker-reached", callback: (markerName: string, msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "marker-reached", markerName: string, msecs: number): void
    /**
     * The ::new-frame signal is emitted for each timeline running
     * timeline before a new frame is drawn to give animations a chance
     * to update the scene.
     */
    connect(sigName: "new-frame", callback: ((msecs: number) => void)): number
    on(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-frame", callback: (msecs: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-frame", callback: (msecs: number) => void): NodeJS.EventEmitter
    emit(sigName: "new-frame", msecs: number): void
    /**
     * The ::paused signal is emitted when clutter_timeline_pause() is invoked.
     */
    connect(sigName: "paused", callback: (() => void)): number
    on(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "paused", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "paused", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "paused"): void
    /**
     * The ::started signal is emitted when the timeline starts its run.
     * This might be as soon as clutter_timeline_start() is invoked or
     * after the delay set in the ClutterTimeline:delay property has
     * expired.
     */
    connect(sigName: "started", callback: (() => void)): number
    on(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "started", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "started", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "started"): void
    /**
     * The #ClutterTimeline::stopped signal is emitted when the timeline
     * has been stopped, either because clutter_timeline_stop() has been
     * called, or because it has been exhausted.
     * 
     * This is different from the #ClutterTimeline::completed signal,
     * which gets emitted after every repeat finishes.
     * 
     * If the #ClutterTimeline has is marked as infinitely repeating,
     * this signal will never be emitted.
     */
    connect(sigName: "stopped", callback: ((isFinished: boolean) => void)): number
    on(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "stopped", callback: (isFinished: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "stopped", callback: (isFinished: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "stopped", isFinished: boolean): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::animatable", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::animatable", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interval", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interval", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remove-on-complete", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::remove-on-complete", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-reverse", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::auto-reverse", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delay", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delay", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duration", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::duration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::loop", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::loop", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::progress-mode", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::progress-mode", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::repeat-count", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::repeat-count", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TransitionGroup_ConstructProps)
    _init (config?: TransitionGroup_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TransitionGroup
    /* Function overloads */
    static new(msecs: number): TransitionGroup
    static $gtype: GObject.Type
}
interface ZoomAction_ConstructProps extends GestureAction_ConstructProps {
    /* Constructor properties of Clutter-1.0.Clutter.ZoomAction */
    /**
     * Constraints the zooming action to the specified axis
     */
    zoomAxis?: ZoomAxis
}
class ZoomAction {
    /* Properties of Clutter-1.0.Clutter.ZoomAction */
    /**
     * Constraints the zooming action to the specified axis
     */
    zoomAxis: ZoomAxis
    /* Properties of Clutter-1.0.Clutter.GestureAction */
    /**
     * Number of touch points to trigger a gesture action.
     */
    nTouchPoints: number
    /* Properties of Clutter-1.0.Clutter.ActorMeta */
    /**
     * The #ClutterActor attached to the #ClutterActorMeta instance
     */
    readonly actor: Actor
    /**
     * Whether or not the #ClutterActorMeta is enabled
     */
    enabled: boolean
    /**
     * The unique name to access the #ClutterActorMeta
     */
    name: string
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Clutter-1.0.Clutter.ZoomAction */
    /**
     * Retrieves the focal point of the current zoom
     */
    getFocalPoint(): /* point */ Point
    /**
     * Retrieves the focal point relative to the actor's coordinates of
     * the current zoom
     */
    getTransformedFocalPoint(): /* point */ Point
    /**
     * Retrieves the axis constraint set by clutter_zoom_action_set_zoom_axis()
     */
    getZoomAxis(): ZoomAxis
    /**
     * Restricts the zooming action to a specific axis
     */
    setZoomAxis(axis: ZoomAxis): void
    /* Methods of Clutter-1.0.Clutter.GestureAction */
    /**
     * Cancel a #ClutterGestureAction before it begins
     */
    cancel(): void
    /**
     * Retrieves the #ClutterInputDevice of a touch point.
     */
    getDevice(point: number): InputDevice
    /**
     * Retrieves a reference to the last #ClutterEvent for a touch point. Call
     * clutter_event_copy() if you need to store the reference somewhere.
     */
    getLastEvent(point: number): Event
    /**
     * Retrieves the coordinates, in stage space, of the latest motion
     * event during the dragging.
     */
    getMotionCoords(point: number): [ /* motionX */ number | null, /* motionY */ number | null ]
    /**
     * Retrieves the incremental delta since the last motion event
     * during the dragging.
     */
    getMotionDelta(point: number): [ /* returnType */ number, /* deltaX */ number | null, /* deltaY */ number | null ]
    /**
     * Retrieves the number of points currently active.
     */
    getNCurrentPoints(): number
    /**
     * Retrieves the number of requested points to trigger the gesture.
     */
    getNTouchPoints(): number
    /**
     * Retrieves the coordinates, in stage space, of the press event
     * that started the dragging for a specific touch point.
     */
    getPressCoords(point: number): [ /* pressX */ number | null, /* pressY */ number | null ]
    /**
     * Retrieves the coordinates, in stage space, where the touch point was
     * last released.
     */
    getReleaseCoords(point: number): [ /* releaseX */ number | null, /* releaseY */ number | null ]
    /**
     * Retrieves the #ClutterEventSequence of a touch point.
     */
    getSequence(point: number): EventSequence
    /**
     * Retrieves the threshold trigger distance of the gesture `action,`
     * as set using clutter_gesture_action_set_threshold_trigger_distance().
     */
    getThresholdTriggerDistance(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEdge(): GestureTriggerEdge
    /**
     * Retrieves the edge trigger of the gesture `action,` as set using
     * clutter_gesture_action_set_threshold_trigger_edge().
     */
    getThresholdTriggerEgde(): GestureTriggerEdge
    /**
     * Retrieves the velocity, in stage pixels per millisecond, of the
     * latest motion event during the dragging.
     */
    getVelocity(point: number): [ /* returnType */ number, /* velocityX */ number | null, /* velocityY */ number | null ]
    /**
     * Sets the number of points needed to trigger the gesture.
     */
    setNTouchPoints(nbPoints: number): void
    /**
     * Sets the threshold trigger distance for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerDistance(x: number, y: number): void
    /**
     * Sets the edge trigger for the gesture drag threshold, if any.
     * 
     * This function should only be called by sub-classes of
     * #ClutterGestureAction during their construction phase.
     */
    setThresholdTriggerEdge(edge: GestureTriggerEdge): void
    /* Methods of Clutter-1.0.Clutter.ActorMeta */
    /**
     * Retrieves a pointer to the #ClutterActor that owns `meta`
     */
    getActor(): Actor
    /**
     * Retrieves whether `meta` is enabled
     */
    getEnabled(): boolean
    /**
     * Retrieves the name set using clutter_actor_meta_set_name()
     */
    getName(): string
    /**
     * Sets whether `meta` should be enabled or not
     */
    setEnabled(isEnabled: boolean): void
    /**
     * Sets the name of `meta`
     * 
     * The name can be used to identify the #ClutterActorMeta instance
     */
    setName(name: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Clutter-1.0.Clutter.ZoomAction */
    /**
     * The ::zoom signal is emitted for each series of touch events that
     * change the distance and focal point between the touch points.
     * 
     * The default handler of the signal will call
     * clutter_actor_set_scale() on `actor` using the ratio of the first
     * distance between the touch points and the current distance. To
     * override the default behaviour, connect to this signal and return
     * %FALSE.
     */
    connect(sigName: "zoom", callback: ((actor: Actor, focalPoint: Point, factor: number) => boolean)): number
    on(sigName: "zoom", callback: (actor: Actor, focalPoint: Point, factor: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "zoom", callback: (actor: Actor, focalPoint: Point, factor: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "zoom", callback: (actor: Actor, focalPoint: Point, factor: number) => void): NodeJS.EventEmitter
    emit(sigName: "zoom", actor: Actor, focalPoint: Point, factor: number): void
    /* Signals of Clutter-1.0.Clutter.GestureAction */
    /**
     * The ::gesture_begin signal is emitted when the #ClutterActor to which
     * a #ClutterGestureAction has been applied starts receiving a gesture.
     */
    connect(sigName: "gesture-begin", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-begin", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-begin", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-begin", actor: Actor): void
    /**
     * The ::gesture-cancel signal is emitted when the ongoing gesture gets
     * cancelled from the #ClutterGestureAction::gesture-progress signal handler.
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-cancel", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-cancel", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-cancel", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-cancel", actor: Actor): void
    /**
     * The ::gesture-end signal is emitted at the end of the gesture gesture,
     * when the pointer's button is released
     * 
     * This signal is emitted if and only if the #ClutterGestureAction::gesture-begin
     * signal has been emitted first.
     */
    connect(sigName: "gesture-end", callback: ((actor: Actor) => void)): number
    on(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-end", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-end", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-end", actor: Actor): void
    /**
     * The ::gesture-progress signal is emitted for each motion event after
     * the #ClutterGestureAction::gesture-begin signal has been emitted.
     */
    connect(sigName: "gesture-progress", callback: ((actor: Actor) => boolean)): number
    on(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "gesture-progress", callback: (actor: Actor) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "gesture-progress", callback: (actor: Actor) => void): NodeJS.EventEmitter
    emit(sigName: "gesture-progress", actor: Actor): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::zoom-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::zoom-axis", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::zoom-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::zoom-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::zoom-axis", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-touch-points", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::n-touch-points", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::actor", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::actor", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ZoomAction_ConstructProps)
    _init (config?: ZoomAction_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): ZoomAction
    static $gtype: GObject.Type
}
abstract class ActionClass {
    static name: string
}
class ActorBox {
    /* Fields of Clutter-1.0.Clutter.ActorBox */
    /**
     * X coordinate of the top left corner
     */
    readonly x1: number
    /**
     * Y coordinate of the top left corner
     */
    readonly y1: number
    /**
     * X coordinate of the bottom right corner
     */
    readonly x2: number
    /**
     * Y coordinate of the bottom right corner
     */
    readonly y2: number
    /* Methods of Clutter-1.0.Clutter.ActorBox */
    /**
     * Clamps the components of `box` to the nearest integer
     */
    clampToPixel(): void
    /**
     * Checks whether a point with `x,` `y` coordinates is contained
     * withing `box`
     */
    contains(x: number, y: number): boolean
    /**
     * Copies `box`
     */
    copy(): ActorBox
    /**
     * Checks `box_a` and `box_b` for equality
     */
    equal(boxB: ActorBox): boolean
    /**
     * Frees a #ClutterActorBox allocated using clutter_actor_box_new()
     * or clutter_actor_box_copy()
     */
    free(): void
    /**
     * Calculates the bounding box represented by the four vertices; for details
     * of the vertex array see clutter_actor_get_abs_allocation_vertices().
     */
    fromVertices(verts: Vertex[]): void
    /**
     * Retrieves the area of `box`
     */
    getArea(): number
    /**
     * Retrieves the height of the `box`
     */
    getHeight(): number
    /**
     * Retrieves the origin of `box`
     */
    getOrigin(): [ /* x */ number | null, /* y */ number | null ]
    /**
     * Retrieves the size of `box`
     */
    getSize(): [ /* width */ number | null, /* height */ number | null ]
    /**
     * Retrieves the width of the `box`
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of the origin of `box`
     */
    getX(): number
    /**
     * Retrieves the Y coordinate of the origin of `box`
     */
    getY(): number
    /**
     * Initializes `box` with the given coordinates.
     */
    init(x1: number, y1: number, x2: number, y2: number): ActorBox
    /**
     * Initializes `box` with the given origin and size.
     */
    initRect(x: number, y: number, width: number, height: number): void
    /**
     * Interpolates between `initial` and `final` #ClutterActorBox<!-- -->es
     * using `progress`
     */
    interpolate(final: ActorBox, progress: number): /* result */ ActorBox
    /**
     * Changes the origin of `box,` maintaining the size of the #ClutterActorBox.
     */
    setOrigin(x: number, y: number): void
    /**
     * Sets the size of `box,` maintaining the origin of the #ClutterActorBox.
     */
    setSize(width: number, height: number): void
    /**
     * Unions the two boxes `a` and `b` and stores the result in `result`.
     */
    union(b: ActorBox): /* result */ ActorBox
    static name: string
    static new(x1: number, y1: number, x2: number, y2: number): ActorBox
    constructor(x1: number, y1: number, x2: number, y2: number)
    /* Static methods and pseudo-constructors */
    static new(x1: number, y1: number, x2: number, y2: number): ActorBox
    /**
     * Allocates a new #ClutterActorBox.
     */
    static alloc(): ActorBox
}
abstract class ActorClass {
    /* Fields of Clutter-1.0.Clutter.ActorClass */
    readonly show: (self: Actor) => void
    readonly showAll: (self: Actor) => void
    readonly hide: (self: Actor) => void
    readonly hideAll: (self: Actor) => void
    readonly realize: (self: Actor) => void
    readonly unrealize: (self: Actor) => void
    readonly map: (self: Actor) => void
    readonly unmap: (self: Actor) => void
    readonly paint: (self: Actor) => void
    readonly parentSet: (actor: Actor, oldParent: Actor) => void
    readonly destroy: (self: Actor) => void
    readonly pick: (actor: Actor, color: Color) => void
    readonly queueRedraw: (actor: Actor, leafThatQueued: Actor) => void
    readonly getPreferredWidth: (self: Actor, forHeight: number) => [ /* minWidthP */ number | null, /* naturalWidthP */ number | null ]
    readonly getPreferredHeight: (self: Actor, forWidth: number) => [ /* minHeightP */ number | null, /* naturalHeightP */ number | null ]
    readonly allocate: (self: Actor, box: ActorBox, flags: AllocationFlags) => void
    readonly applyTransform: (actor: Actor, matrix: Matrix) => void
    readonly event: (actor: Actor, event: Event) => boolean
    readonly buttonPressEvent: (actor: Actor, event: ButtonEvent) => boolean
    readonly buttonReleaseEvent: (actor: Actor, event: ButtonEvent) => boolean
    readonly scrollEvent: (actor: Actor, event: ScrollEvent) => boolean
    readonly keyPressEvent: (actor: Actor, event: KeyEvent) => boolean
    readonly keyReleaseEvent: (actor: Actor, event: KeyEvent) => boolean
    readonly motionEvent: (actor: Actor, event: MotionEvent) => boolean
    readonly enterEvent: (actor: Actor, event: CrossingEvent) => boolean
    readonly leaveEvent: (actor: Actor, event: CrossingEvent) => boolean
    readonly capturedEvent: (actor: Actor, event: Event) => boolean
    readonly keyFocusIn: (actor: Actor) => void
    readonly keyFocusOut: (actor: Actor) => void
    readonly queueRelayout: (self: Actor) => void
    readonly getAccessible: (self: Actor) => Atk.Object
    readonly getPaintVolume: (actor: Actor, volume: PaintVolume) => boolean
    readonly hasOverlaps: (self: Actor) => boolean
    readonly paintNode: (self: Actor, root: PaintNode) => void
    readonly touchEvent: (self: Actor, event: TouchEvent) => boolean
    static name: string
}
class ActorIter {
    /* Methods of Clutter-1.0.Clutter.ActorIter */
    /**
     * Safely destroys the #ClutterActor currently pointer to by the iterator
     * from its parent.
     * 
     * This function can only be called after clutter_actor_iter_next() or
     * clutter_actor_iter_prev() returned %TRUE, and cannot be called more
     * than once for the same actor.
     * 
     * This function will call clutter_actor_destroy() internally.
     */
    destroy(): void
    /**
     * Initializes a #ClutterActorIter, which can then be used to iterate
     * efficiently over a section of the scene graph, and associates it
     * with `root`.
     * 
     * Modifying the scene graph section that contains `root` will invalidate
     * the iterator.
     * 
     * 
     * ```c
     *   ClutterActorIter iter;
     *   ClutterActor *child;
     * 
     *   clutter_actor_iter_init (&iter, container);
     *   while (clutter_actor_iter_next (&iter, &child))
     *     {
     *       // do something with child
     *     }
     * ```
     * 
     */
    init(root: Actor): void
    /**
     * Checks whether a #ClutterActorIter is still valid.
     * 
     * An iterator is considered valid if it has been initialized, and
     * if the #ClutterActor that it refers to hasn't been modified after
     * the initialization.
     */
    isValid(): boolean
    /**
     * Advances the `iter` and retrieves the next child of the root #ClutterActor
     * that was used to initialize the #ClutterActorIterator.
     * 
     * If the iterator can advance, this function returns %TRUE and sets the
     * `child` argument.
     * 
     * If the iterator cannot advance, this function returns %FALSE, and
     * the contents of `child` are undefined.
     */
    next(): [ /* returnType */ boolean, /* child */ Actor ]
    /**
     * Advances the `iter` and retrieves the previous child of the root
     * #ClutterActor that was used to initialize the #ClutterActorIterator.
     * 
     * If the iterator can advance, this function returns %TRUE and sets the
     * `child` argument.
     * 
     * If the iterator cannot advance, this function returns %FALSE, and
     * the contents of `child` are undefined.
     */
    prev(): [ /* returnType */ boolean, /* child */ Actor ]
    /**
     * Safely removes the #ClutterActor currently pointer to by the iterator
     * from its parent.
     * 
     * This function can only be called after clutter_actor_iter_next() or
     * clutter_actor_iter_prev() returned %TRUE, and cannot be called more
     * than once for the same actor.
     * 
     * This function will call clutter_actor_remove_child() internally.
     */
    remove(): void
    static name: string
}
abstract class ActorMetaClass {
    /* Fields of Clutter-1.0.Clutter.ActorMetaClass */
    readonly setActor: (meta: ActorMeta, actor?: Actor | null) => void
    static name: string
}
class ActorMetaPrivate {
    static name: string
}
class ActorPrivate {
    static name: string
}
abstract class AlignConstraintClass {
    static name: string
}
abstract class AlphaClass {
    static name: string
}
class AlphaPrivate {
    static name: string
}
abstract class AnimatableIface {
    /* Fields of Clutter-1.0.Clutter.AnimatableIface */
    readonly animateProperty: (animatable: Animatable, animation: Animation, propertyName: string, initialValue: any, finalValue: any, progress: number, value: any) => boolean
    readonly findProperty: (animatable: Animatable, propertyName: string) => GObject.ParamSpec
    readonly getInitialState: (animatable: Animatable, propertyName: string, value: any) => void
    readonly setFinalState: (animatable: Animatable, propertyName: string, value: any) => void
    readonly interpolateValue: (animatable: Animatable, propertyName: string, interval: Interval, progress: number) => [ /* returnType */ boolean, /* value */ any ]
    static name: string
}
abstract class AnimationClass {
    /* Fields of Clutter-1.0.Clutter.AnimationClass */
    readonly started: (animation: Animation) => void
    readonly completed: (animation: Animation) => void
    static name: string
}
class AnimationPrivate {
    static name: string
}
abstract class AnimatorClass {
    static name: string
}
class AnimatorKey {
    /* Methods of Clutter-1.0.Clutter.AnimatorKey */
    /**
     * Retrieves the mode of a #ClutterAnimator key, for the first key of a
     * property for an object this represents the whether the animation is
     * open ended and or curved for the remainding keys for the property it
     * represents the easing mode.
     */
    getMode(): number
    /**
     * Retrieves the object a key applies to.
     */
    getObject(): GObject.Object
    /**
     * Retrieves the progress of an clutter_animator_key
     */
    getProgress(): number
    /**
     * Retrieves the name of the property a key applies to.
     */
    getPropertyName(): string
    /**
     * Retrieves the #GType of the property a key applies to
     * 
     * You can use this type to initialize the #GValue to pass to
     * clutter_animator_key_get_value()
     */
    getPropertyType(): GObject.Type
    /**
     * Retrieves a copy of the value for a #ClutterAnimatorKey.
     * 
     * The passed in #GValue needs to be already initialized for the value
     * type of the key or to a type that allow transformation from the value
     * type of the key.
     * 
     * Use g_value_unset() when done.
     */
    getValue(value: any): boolean
    static name: string
}
class AnimatorPrivate {
    static name: string
}
class AnyEvent {
    /* Fields of Clutter-1.0.Clutter.AnyEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    readonly stage: Stage
    /**
     * event source actor
     */
    readonly source: Actor
    static name: string
}
abstract class BackendClass {
    static name: string
}
abstract class BehaviourClass {
    /* Fields of Clutter-1.0.Clutter.BehaviourClass */
    readonly alphaNotify: (behave: Behaviour, alphaValue: number) => void
    readonly applied: (behave: Behaviour, actor: Actor) => void
    readonly removed: (behave: Behaviour, actor: Actor) => void
    static name: string
}
abstract class BehaviourDepthClass {
    static name: string
}
class BehaviourDepthPrivate {
    static name: string
}
abstract class BehaviourEllipseClass {
    static name: string
}
class BehaviourEllipsePrivate {
    static name: string
}
abstract class BehaviourOpacityClass {
    static name: string
}
class BehaviourOpacityPrivate {
    static name: string
}
abstract class BehaviourPathClass {
    /* Fields of Clutter-1.0.Clutter.BehaviourPathClass */
    readonly knotReached: (pathb: BehaviourPath, knotNum: number) => void
    static name: string
}
class BehaviourPathPrivate {
    static name: string
}
class BehaviourPrivate {
    static name: string
}
abstract class BehaviourRotateClass {
    static name: string
}
class BehaviourRotatePrivate {
    static name: string
}
abstract class BehaviourScaleClass {
    static name: string
}
class BehaviourScalePrivate {
    static name: string
}
abstract class BinLayoutClass {
    static name: string
}
class BinLayoutPrivate {
    static name: string
}
abstract class BindConstraintClass {
    static name: string
}
abstract class BindingPoolClass {
    static name: string
}
abstract class BlurEffectClass {
    static name: string
}
abstract class BoxClass {
    /* Fields of Clutter-1.0.Clutter.BoxClass */
    readonly clutterPadding1: () => void
    readonly clutterPadding2: () => void
    readonly clutterPadding3: () => void
    readonly clutterPadding4: () => void
    readonly clutterPadding5: () => void
    readonly clutterPadding6: () => void
    static name: string
}
abstract class BoxLayoutClass {
    static name: string
}
class BoxLayoutPrivate {
    static name: string
}
class BoxPrivate {
    static name: string
}
abstract class BrightnessContrastEffectClass {
    static name: string
}
class ButtonEvent {
    /* Fields of Clutter-1.0.Clutter.ButtonEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor
     */
    readonly source: Actor
    /**
     * event X coordinate, relative to the stage
     */
    readonly x: number
    /**
     * event Y coordinate, relative to the stage
     */
    readonly y: number
    /**
     * button modifiers
     */
    readonly modifierState: ModifierType
    /**
     * event button
     */
    readonly button: number
    /**
     * number of button presses within the default time
     *   and radius
     */
    readonly clickCount: number
    /**
     * reserved for future use
     */
    readonly axes: number
    /**
     * the device that originated the event. If you want the physical
     * device the event originated from, use clutter_event_get_source_device()
     */
    readonly device: InputDevice
    static name: string
}
abstract class CairoTextureClass {
    /* Fields of Clutter-1.0.Clutter.CairoTextureClass */
    readonly createSurface: (texture: CairoTexture, width: number, height: number) => cairo.Surface
    readonly draw: (texture: CairoTexture, cr: cairo.Context) => boolean
    static name: string
}
class CairoTexturePrivate {
    static name: string
}
abstract class CanvasClass {
    /* Fields of Clutter-1.0.Clutter.CanvasClass */
    readonly draw: (canvas: Canvas, cr: cairo.Context, width: number, height: number) => boolean
    static name: string
}
class CanvasPrivate {
    static name: string
}
abstract class ChildMetaClass {
    static name: string
}
abstract class ClickActionClass {
    /* Fields of Clutter-1.0.Clutter.ClickActionClass */
    readonly clicked: (action: ClickAction, actor: Actor) => void
    readonly longPress: (action: ClickAction, actor: Actor, state: LongPressState) => boolean
    static name: string
}
class ClickActionPrivate {
    static name: string
}
abstract class ClipNodeClass {
    static name: string
}
abstract class CloneClass {
    static name: string
}
class ClonePrivate {
    static name: string
}
class Color {
    /* Fields of Clutter-1.0.Clutter.Color */
    /**
     * red component, between 0 and 255
     */
    readonly red: number
    /**
     * green component, between 0 and 255
     */
    readonly green: number
    /**
     * blue component, between 0 and 255
     */
    readonly blue: number
    /**
     * alpha component, between 0 and 255
     */
    readonly alpha: number
    /* Methods of Clutter-1.0.Clutter.Color */
    /**
     * Adds `a` to `b` and saves the resulting color inside `result`.
     * 
     * The alpha channel of `result` is set as as the maximum value
     * between the alpha channels of `a` and `b`.
     */
    add(b: Color): /* result */ Color
    /**
     * Makes a copy of the color structure.  The result must be
     * freed using clutter_color_free().
     */
    copy(): Color
    /**
     * Darkens `color` by a fixed amount, and saves the changed color
     * in `result`.
     */
    darken(): /* result */ Color
    /**
     * Compares two #ClutterColor<!-- -->s and checks if they are the same.
     * 
     * This function can be passed to g_hash_table_new() as the `key_equal_func`
     * parameter, when using #ClutterColor<!-- -->s as keys in a #GHashTable.
     */
    equal(v2: Color): boolean
    /**
     * Frees a color structure created with clutter_color_copy().
     */
    free(): void
    /**
     * Converts a #ClutterColor to a hash value.
     * 
     * This function can be passed to g_hash_table_new() as the `hash_func`
     * parameter, when using #ClutterColor<!-- -->s as keys in a #GHashTable.
     */
    hash(): number
    /**
     * Initializes `color` with the given values.
     */
    init(red: number, green: number, blue: number, alpha: number): Color
    /**
     * Interpolates between `initial` and `final` #ClutterColor<!-- -->s
     * using `progress`
     */
    interpolate(final: Color, progress: number): /* result */ Color
    /**
     * Lightens `color` by a fixed amount, and saves the changed color
     * in `result`.
     */
    lighten(): /* result */ Color
    /**
     * Shades `color` by `factor` and saves the modified color into `result`.
     */
    shade(factor: number): /* result */ Color
    /**
     * Subtracts `b` from `a` and saves the resulting color inside `result`.
     * 
     * This function assumes that the components of `a` are greater than the
     * components of `b;` the result is, otherwise, undefined.
     * 
     * The alpha channel of `result` is set as the minimum value
     * between the alpha channels of `a` and `b`.
     */
    subtract(b: Color): /* result */ Color
    /**
     * Converts `color` to the HLS format.
     * 
     * The `hue` value is in the 0 .. 360 range. The `luminance` and
     * `saturation` values are in the 0 .. 1 range.
     */
    toHls(): [ /* hue */ number, /* luminance */ number, /* saturation */ number ]
    /**
     * Converts `color` into a packed 32 bit integer, containing
     * all the four 8 bit channels used by #ClutterColor.
     */
    toPixel(): number
    /**
     * Returns a textual specification of `color` in the hexadecimal form
     * <literal>&num;rrggbbaa</literal>, where <literal>r</literal>,
     * <literal>g</literal>, <literal>b</literal> and <literal>a</literal> are
     * hexadecimal digits representing the red, green, blue and alpha components
     * respectively.
     */
    toString(): string
    static name: string
    static new(red: number, green: number, blue: number, alpha: number): Color
    constructor(red: number, green: number, blue: number, alpha: number)
    /* Static methods and pseudo-constructors */
    static alloc(): Color
    static new(red: number, green: number, blue: number, alpha: number): Color
    /**
     * Converts a color expressed in HLS (hue, luminance and saturation)
     * values into a #ClutterColor.
     */
    static fromHls(hue: number, luminance: number, saturation: number): /* color */ Color
    /**
     * Converts `pixel` from the packed representation of a four 8 bit channel
     * color to a #ClutterColor.
     */
    static fromPixel(pixel: number): /* color */ Color
    /**
     * Parses a string definition of a color, filling the #ClutterColor.red,
     * #ClutterColor.green, #ClutterColor.blue and #ClutterColor.alpha fields
     * of `color`.
     * 
     * The `color` is not allocated.
     * 
     * The format of `str` can be either one of:
     * 
     *   - a standard name (as taken from the X11 rgb.txt file)
     *   - an hexadecimal value in the form: `#rgb`, `#rrggbb`, `#rgba`, or `#rrggbbaa`
     *   - a RGB color in the form: `rgb(r, g, b)`
     *   - a RGB color in the form: `rgba(r, g, b, a)`
     *   - a HSL color in the form: `hsl(h, s, l)`
     *    -a HSL color in the form: `hsla(h, s, l, a)`
     * 
     * where 'r', 'g', 'b' and 'a' are (respectively) the red, green, blue color
     * intensities and the opacity. The 'h', 's' and 'l' are (respectively) the
     * hue, saturation and luminance values.
     * 
     * In the rgb() and rgba() formats, the 'r', 'g', and 'b' values are either
     * integers between 0 and 255, or percentage values in the range between 0%
     * and 100%; the percentages require the '%' character. The 'a' value, if
     * specified, can only be a floating point value between 0.0 and 1.0.
     * 
     * In the hls() and hlsa() formats, the 'h' value (hue) is an angle between
     * 0 and 360.0 degrees; the 'l' and 's' values (luminance and saturation) are
     * percentage values in the range between 0% and 100%. The 'a' value, if specified,
     * can only be a floating point value between 0.0 and 1.0.
     * 
     * Whitespace inside the definitions is ignored; no leading whitespace
     * is allowed.
     * 
     * If the alpha component is not specified then it is assumed to be set to
     * be fully opaque.
     */
    static fromString(str: string): [ /* returnType */ boolean, /* color */ Color ]
    /**
     * Retrieves a static color for the given `color` name
     * 
     * Static colors are created by Clutter and are guaranteed to always be
     * available and valid
     */
    static getStatic(color: StaticColor): Color
}
abstract class ColorNodeClass {
    static name: string
}
abstract class ColorizeEffectClass {
    static name: string
}
abstract class ConstraintClass {
    /* Fields of Clutter-1.0.Clutter.ConstraintClass */
    readonly updateAllocation: (constraint: Constraint, actor: Actor, allocation: ActorBox) => void
    readonly updatePreferredSize: (constraint: Constraint, actor: Actor, direction: Orientation, forSize: number, minimumSize: number, naturalSize: number) => void
    static name: string
}
abstract class ContainerIface {
    /* Fields of Clutter-1.0.Clutter.ContainerIface */
    readonly add: (container: Container, actor: Actor) => void
    readonly remove: (container: Container, actor: Actor) => void
    readonly foreach: (container: Container, callback: Callback) => void
    readonly foreachWithInternals: (container: Container, callback: Callback) => void
    readonly raise: (container: Container, actor: Actor, sibling?: Actor | null) => void
    readonly lower: (container: Container, actor: Actor, sibling?: Actor | null) => void
    readonly sortDepthOrder: (container: Container) => void
    /**
     * The GType used for storing auxiliary information about
     *   each of the containers children.
     */
    readonly childMetaType: GObject.Type
    readonly createChildMeta: (container: Container, actor: Actor) => void
    readonly destroyChildMeta: (container: Container, actor: Actor) => void
    readonly getChildMeta: (container: Container, actor: Actor) => ChildMeta
    readonly actorAdded: (container: Container, actor: Actor) => void
    readonly actorRemoved: (container: Container, actor: Actor) => void
    readonly childNotify: (container: Container, child: Actor, pspec: GObject.ParamSpec) => void
    static name: string
}
abstract class ContentIface {
    /* Fields of Clutter-1.0.Clutter.ContentIface */
    readonly getPreferredSize: (content: Content) => [ /* returnType */ boolean, /* width */ number, /* height */ number ]
    readonly paintContent: (content: Content, actor: Actor, node: PaintNode) => void
    readonly attached: (content: Content, actor: Actor) => void
    readonly detached: (content: Content, actor: Actor) => void
    readonly invalidate: (content: Content) => void
    static name: string
}
class CrossingEvent {
    /* Fields of Clutter-1.0.Clutter.CrossingEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor
     */
    readonly source: Actor
    /**
     * event X coordinate
     */
    readonly x: number
    /**
     * event Y coordinate
     */
    readonly y: number
    /**
     * the device that originated the event. If you want the physical
     * device the event originated from, use clutter_event_get_source_device()
     */
    readonly device: InputDevice
    /**
     * actor related to the crossing
     */
    readonly related: Actor
    static name: string
}
abstract class DeformEffectClass {
    /* Fields of Clutter-1.0.Clutter.DeformEffectClass */
    readonly deformVertex: (effect: DeformEffect, width: number, height: number, vertex: Cogl.TextureVertex) => void
    static name: string
}
class DeformEffectPrivate {
    static name: string
}
abstract class DesaturateEffectClass {
    static name: string
}
abstract class DeviceManagerClass {
    /* Fields of Clutter-1.0.Clutter.DeviceManagerClass */
    readonly getCoreDevice: (deviceManager: DeviceManager, deviceType: InputDeviceType) => InputDevice
    readonly getDevice: (deviceManager: DeviceManager, deviceId: number) => InputDevice
    readonly addDevice: (manager: DeviceManager, device: InputDevice) => void
    readonly removeDevice: (manager: DeviceManager, device: InputDevice) => void
    readonly selectStageEvents: (manager: DeviceManager, stage: Stage) => void
    static name: string
}
class DeviceManagerPrivate {
    static name: string
}
abstract class DragActionClass {
    /* Fields of Clutter-1.0.Clutter.DragActionClass */
    readonly dragBegin: (action: DragAction, actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void
    readonly dragMotion: (action: DragAction, actor: Actor, deltaX: number, deltaY: number) => void
    readonly dragEnd: (action: DragAction, actor: Actor, eventX: number, eventY: number, modifiers: ModifierType) => void
    readonly dragProgress: (action: DragAction, actor: Actor, deltaX: number, deltaY: number) => boolean
    static name: string
}
class DragActionPrivate {
    static name: string
}
abstract class DropActionClass {
    /* Fields of Clutter-1.0.Clutter.DropActionClass */
    readonly canDrop: (action: DropAction, actor: Actor, eventX: number, eventY: number) => boolean
    readonly overIn: (action: DropAction, actor: Actor) => void
    readonly overOut: (action: DropAction, actor: Actor) => void
    readonly drop: (action: DropAction, actor: Actor, eventX: number, eventY: number) => void
    static name: string
}
class DropActionPrivate {
    static name: string
}
abstract class EffectClass {
    /* Fields of Clutter-1.0.Clutter.EffectClass */
    readonly prePaint: (effect: Effect) => boolean
    readonly postPaint: (effect: Effect) => void
    readonly getPaintVolume: (effect: Effect, volume: PaintVolume) => boolean
    readonly paint: (effect: Effect, flags: EffectPaintFlags) => void
    readonly pick: (effect: Effect, flags: EffectPaintFlags) => void
    static name: string
}
class EventSequence {
    static name: string
}
abstract class FixedLayoutClass {
    static name: string
}
abstract class FlowLayoutClass {
    static name: string
}
class FlowLayoutPrivate {
    static name: string
}
class Fog {
    /* Fields of Clutter-1.0.Clutter.Fog */
    /**
     * starting distance from the viewer to the near clipping
     *   plane (always positive)
     */
    readonly zNear: number
    /**
     * final distance from the viewer to the far clipping
     *   plane (always positive)
     */
    readonly zFar: number
    static name: string
}
class Geometry {
    /* Fields of Clutter-1.0.Clutter.Geometry */
    /**
     * X coordinate of the top left corner of an actor
     */
    readonly x: number
    /**
     * Y coordinate of the top left corner of an actor
     */
    readonly y: number
    /**
     * width of an actor
     */
    readonly width: number
    /**
     * height of an actor
     */
    readonly height: number
    /* Methods of Clutter-1.0.Clutter.Geometry */
    /**
     * Determines if `geometry0` and geometry1 intersect returning %TRUE if
     * they do else %FALSE.
     */
    intersects(geometry1: Geometry): boolean
    /**
     * Find the union of two rectangles represented as #ClutterGeometry.
     */
    union(geometryB: Geometry): /* result */ Geometry
    static name: string
}
abstract class GestureActionClass {
    /* Fields of Clutter-1.0.Clutter.GestureActionClass */
    readonly gestureBegin: (action: GestureAction, actor: Actor) => boolean
    readonly gestureProgress: (action: GestureAction, actor: Actor) => boolean
    readonly gestureEnd: (action: GestureAction, actor: Actor) => void
    readonly gestureCancel: (action: GestureAction, actor: Actor) => void
    readonly gesturePrepare: (action: GestureAction, actor: Actor) => boolean
    static name: string
}
class GestureActionPrivate {
    static name: string
}
abstract class GridLayoutClass {
    static name: string
}
class GridLayoutPrivate {
    static name: string
}
abstract class GroupClass {
    static name: string
}
class GroupPrivate {
    static name: string
}
abstract class ImageClass {
    static name: string
}
class ImagePrivate {
    static name: string
}
abstract class InputDeviceClass {
    static name: string
}
abstract class IntervalClass {
    /* Fields of Clutter-1.0.Clutter.IntervalClass */
    readonly validate: (interval: Interval, pspec: GObject.ParamSpec) => boolean
    readonly computeValue: (interval: Interval, factor: number) => [ /* returnType */ boolean, /* value */ any ]
    static name: string
}
class IntervalPrivate {
    static name: string
}
class KeyEvent {
    /* Fields of Clutter-1.0.Clutter.KeyEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor
     */
    readonly source: Actor
    /**
     * key modifiers
     */
    readonly modifierState: ModifierType
    /**
     * raw key value
     */
    readonly keyval: number
    /**
     * raw hardware key value
     */
    readonly hardwareKeycode: number
    /**
     * Unicode representation
     */
    readonly unicodeValue: number
    /**
     * the device that originated the event. If you want the physical
     * device the event originated from, use clutter_event_get_source_device()
     */
    readonly device: InputDevice
    static name: string
}
abstract class KeyframeTransitionClass {
    static name: string
}
class KeyframeTransitionPrivate {
    static name: string
}
class Knot {
    /* Fields of Clutter-1.0.Clutter.Knot */
    /**
     * X coordinate of the knot
     */
    readonly x: number
    /**
     * Y coordinate of the knot
     */
    readonly y: number
    /* Methods of Clutter-1.0.Clutter.Knot */
    /**
     * Makes an allocated copy of a knot.
     */
    copy(): Knot
    /**
     * Compares to knot and checks if the point to the same location.
     */
    equal(knotB: Knot): boolean
    /**
     * Frees the memory of an allocated knot.
     */
    free(): void
    static name: string
}
abstract class LayoutManagerClass {
    /* Fields of Clutter-1.0.Clutter.LayoutManagerClass */
    readonly getPreferredWidth: (manager: LayoutManager, container: Container, forHeight: number) => [ /* minWidthP */ number | null, /* natWidthP */ number | null ]
    readonly getPreferredHeight: (manager: LayoutManager, container: Container, forWidth: number) => [ /* minHeightP */ number | null, /* natHeightP */ number | null ]
    readonly allocate: (manager: LayoutManager, container: Container, allocation: ActorBox, flags: AllocationFlags) => void
    readonly setContainer: (manager: LayoutManager, container?: Container | null) => void
    readonly getChildMetaType: (manager: LayoutManager) => GObject.Type
    readonly beginAnimation: (manager: LayoutManager, duration: number, mode: number) => Alpha
    readonly getAnimationProgress: (manager: LayoutManager) => number
    readonly endAnimation: (manager: LayoutManager) => void
    readonly layoutChanged: (manager: LayoutManager) => void
    static name: string
}
abstract class LayoutMetaClass {
    static name: string
}
abstract class ListModelClass {
    static name: string
}
class ListModelPrivate {
    static name: string
}
class Margin {
    /* Fields of Clutter-1.0.Clutter.Margin */
    /**
     * the margin from the left
     */
    readonly left: number
    /**
     * the margin from the right
     */
    readonly right: number
    /**
     * the margin from the top
     */
    readonly top: number
    /**
     * the margin from the bottom
     */
    readonly bottom: number
    /* Methods of Clutter-1.0.Clutter.Margin */
    /**
     * Creates a new #ClutterMargin and copies the contents of `margin_` into
     * the newly created structure.
     */
    copy(): Margin
    /**
     * Frees the resources allocated by clutter_margin_new() and
     * clutter_margin_copy().
     */
    free(): void
    static name: string
    static new(): Margin
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): Margin
}
class Matrix {
    /* Methods of Clutter-1.0.Clutter.Matrix */
    /**
     * Frees the memory allocated by clutter_matrix_alloc().
     */
    free(): void
    /**
     * Initializes `matrix` with the contents of a C array of floating point
     * values.
     */
    initFromArray(values: number[]): Matrix
    /**
     * Initializes the #ClutterMatrix `a` with the contents of the
     * #ClutterMatrix `b`.
     */
    initFromMatrix(b: Matrix): Matrix
    /**
     * Initializes `matrix` with the identity matrix, i.e.:
     * 
     * |[
     *   .xx = 1.0, .xy = 0.0, .xz = 0.0, .xw = 0.0
     *   .yx = 0.0, .yy = 1.0, .yz = 0.0, .yw = 0.0
     *   .zx = 0.0, .zy = 0.0, .zz = 1.0, .zw = 0.0
     *   .wx = 0.0, .wy = 0.0, .wz = 0.0, .ww = 1.0
     * ```
     * 
     */
    initIdentity(): Matrix
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Allocates enough memory to hold a #ClutterMatrix.
     */
    static alloc(): Matrix
}
abstract class MediaIface {
    /* Fields of Clutter-1.0.Clutter.MediaIface */
    readonly eos: (media: Media) => void
    readonly error: (media: Media, error: GLib.Error) => void
    static name: string
}
abstract class ModelClass {
    /* Fields of Clutter-1.0.Clutter.ModelClass */
    readonly getNRows: (model: Model) => number
    readonly getNColumns: (model: Model) => number
    readonly getColumnName: (model: Model, column: number) => string
    readonly getColumnType: (model: Model, column: number) => GObject.Type
    readonly removeRow: (model: Model, row: number) => void
    readonly getIterAtRow: (model: Model, row: number) => ModelIter
    readonly rowAdded: (model: Model, iter: ModelIter) => void
    readonly rowRemoved: (model: Model, iter: ModelIter) => void
    readonly rowChanged: (model: Model, iter: ModelIter) => void
    readonly sortChanged: (model: Model) => void
    readonly filterChanged: (model: Model) => void
    static name: string
}
abstract class ModelIterClass {
    /* Fields of Clutter-1.0.Clutter.ModelIterClass */
    readonly getValue: (iter: ModelIter, column: number) => /* value */ any
    readonly setValue: (iter: ModelIter, column: number, value: any) => void
    readonly isFirst: (iter: ModelIter) => boolean
    readonly isLast: (iter: ModelIter) => boolean
    readonly next: (iter: ModelIter) => ModelIter
    readonly prev: (iter: ModelIter) => ModelIter
    readonly getModel: (iter: ModelIter) => Model
    readonly getRow: (iter: ModelIter) => number
    readonly copy: (iter: ModelIter) => ModelIter
    static name: string
}
class ModelIterPrivate {
    static name: string
}
class ModelPrivate {
    static name: string
}
class MotionEvent {
    /* Fields of Clutter-1.0.Clutter.MotionEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor
     */
    readonly source: Actor
    /**
     * event X coordinate
     */
    readonly x: number
    /**
     * event Y coordinate
     */
    readonly y: number
    /**
     * button modifiers
     */
    readonly modifierState: ModifierType
    /**
     * reserved for future use
     */
    readonly axes: number
    /**
     * the device that originated the event. If you want the physical
     * device the event originated from, use clutter_event_get_source_device()
     */
    readonly device: InputDevice
    static name: string
}
abstract class OffscreenEffectClass {
    /* Fields of Clutter-1.0.Clutter.OffscreenEffectClass */
    readonly createTexture: (effect: OffscreenEffect, width: number, height: number) => Cogl.Handle
    readonly paintTarget: (effect: OffscreenEffect) => void
    static name: string
}
class OffscreenEffectPrivate {
    static name: string
}
abstract class PageTurnEffectClass {
    static name: string
}
abstract class PaintNodeClass {
    static name: string
}
class PaintNodePrivate {
    static name: string
}
class PaintVolume {
    /* Methods of Clutter-1.0.Clutter.PaintVolume */
    /**
     * Copies `pv` into a new #ClutterPaintVolume
     */
    copy(): PaintVolume
    /**
     * Frees the resources allocated by `pv`
     */
    free(): void
    /**
     * Retrieves the depth of the volume's, axis aligned, bounding box.
     * 
     * In other words; this takes into account what actor's coordinate
     * space `pv` belongs too and conceptually fits an axis aligned box
     * around the volume. It returns the size of that bounding box as
     * measured along the z-axis.
     * 
     * If, for example, clutter_actor_get_transformed_paint_volume()
     * is used to transform a 2D child actor that is 100px wide, 100px
     * high and 0px deep into container coordinates then the depth might
     * not simply be 0px if the child actor has a 3D rotation applied to
     * it.
     * 
     * Remember: if clutter_actor_get_transformed_paint_volume() is
     * used then the transformed volume will be defined relative to the
     * container actor and in container coordinates a 2D child actor
     * can have a 3D bounding volume.
     * 
     * There are no accuracy guarantees for the reported depth,
     * except that it must always be greater than, or equal to, the actor's
     * depth. This is because actors may report simple, loose fitting paint
     * volumes for efficiency.
     */
    getDepth(): number
    /**
     * Retrieves the height of the volume's, axis aligned, bounding box.
     * 
     * In other words; this takes into account what actor's coordinate
     * space `pv` belongs too and conceptually fits an axis aligned box
     * around the volume. It returns the size of that bounding box as
     * measured along the y-axis.
     * 
     * If, for example, clutter_actor_get_transformed_paint_volume()
     * is used to transform a 2D child actor that is 100px wide, 100px
     * high and 0px deep into container coordinates then the height might
     * not simply be 100px if the child actor has a 3D rotation applied to
     * it.
     * 
     * Remember: if clutter_actor_get_transformed_paint_volume() is
     * used then a transformed child volume will be defined relative to the
     * ancestor container actor and so a 2D child actor
     * can have a 3D bounding volume.
     * 
     * There are no accuracy guarantees for the reported height,
     * except that it must always be greater than, or equal to, the actor's
     * height. This is because actors may report simple, loose fitting paint
     * volumes for efficiency.
     */
    getHeight(): number
    /**
     * Retrieves the origin of the #ClutterPaintVolume.
     */
    getOrigin(): /* vertex */ Vertex
    /**
     * Retrieves the width of the volume's, axis aligned, bounding box.
     * 
     * In other words; this takes into account what actor's coordinate
     * space `pv` belongs too and conceptually fits an axis aligned box
     * around the volume. It returns the size of that bounding box as
     * measured along the x-axis.
     * 
     * If, for example, clutter_actor_get_transformed_paint_volume()
     * is used to transform a 2D child actor that is 100px wide, 100px
     * high and 0px deep into container coordinates then the width might
     * not simply be 100px if the child actor has a 3D rotation applied to
     * it.
     * 
     * Remember: if clutter_actor_get_transformed_paint_volume() is
     * used then a transformed child volume will be defined relative to the
     * ancestor container actor and so a 2D child actor can have a 3D
     * bounding volume.
     * 
     * There are no accuracy guarantees for the reported width,
     * except that it must always be greater than, or equal to, the
     * actor's width. This is because actors may report simple, loose
     * fitting paint volumes for efficiency.
     */
    getWidth(): number
    /**
     * Sets the depth of the paint volume. The depth is measured along
     * the z axis in the actor coordinates that `pv` is associated with.
     */
    setDepth(depth: number): void
    /**
     * Sets the #ClutterPaintVolume from the allocation of `actor`.
     * 
     * This function should be used when overriding the
     * #ClutterActorClass.get_paint_volume() by #ClutterActor sub-classes
     * that do not paint outside their allocation.
     * 
     * A typical example is:
     * 
     * |[
     * static gboolean
     * my_actor_get_paint_volume (ClutterActor       *self,
     *                            ClutterPaintVolume *volume)
     * {
     *   return clutter_paint_volume_set_from_allocation (volume, self);
     * }
     * ```
     * 
     */
    setFromAllocation(actor: Actor): boolean
    /**
     * Sets the height of the paint volume. The height is measured along
     * the y axis in the actor coordinates that `pv` is associated with.
     */
    setHeight(height: number): void
    /**
     * Sets the origin of the paint volume.
     * 
     * The origin is defined as the X, Y and Z coordinates of the top-left
     * corner of an actor's paint volume, in actor coordinates.
     * 
     * The default is origin is assumed at: (0, 0, 0)
     */
    setOrigin(origin: Vertex): void
    /**
     * Sets the width of the paint volume. The width is measured along
     * the x axis in the actor coordinates that `pv` is associated with.
     */
    setWidth(width: number): void
    /**
     * Updates the geometry of `pv` to encompass `pv` and `another_pv`.
     * 
     * There are no guarantees about how precisely the two volumes
     * will be unioned.
     */
    union(anotherPv: PaintVolume): void
    /**
     * Unions the 2D region represented by `box` to a #ClutterPaintVolume.
     * 
     * This function is similar to clutter_paint_volume_union(), but it is
     * specific for 2D regions.
     */
    unionBox(box: ActorBox): void
    static name: string
}
abstract class PanActionClass {
    /* Fields of Clutter-1.0.Clutter.PanActionClass */
    readonly pan: (action: PanAction, actor: Actor, isInterpolated: boolean) => boolean
    readonly panStopped: (action: PanAction, actor: Actor) => void
    static name: string
}
class PanActionPrivate {
    static name: string
}
class ParamSpecUnits {
    /* Fields of Clutter-1.0.Clutter.ParamSpecUnits */
    /**
     * default type
     */
    readonly defaultType: UnitType
    /**
     * default value
     */
    readonly defaultValue: number
    /**
     * lower boundary
     */
    readonly minimum: number
    /**
     * higher boundary
     */
    readonly maximum: number
    static name: string
}
abstract class PathClass {
    static name: string
}
abstract class PathConstraintClass {
    static name: string
}
class PathNode {
    /* Fields of Clutter-1.0.Clutter.PathNode */
    /**
     * the node's type
     */
    readonly type: PathNodeType
    /**
     * the coordinates of the node
     */
    readonly points: Knot[]
    /* Methods of Clutter-1.0.Clutter.PathNode */
    /**
     * Makes an allocated copy of a node.
     */
    copy(): PathNode
    /**
     * Compares two nodes and checks if they are the same type with the
     * same coordinates.
     */
    equal(nodeB: PathNode): boolean
    /**
     * Frees the memory of an allocated node.
     */
    free(): void
    static name: string
}
class PathPrivate {
    static name: string
}
class Perspective {
    /* Fields of Clutter-1.0.Clutter.Perspective */
    /**
     * the field of view angle, in degrees, in the y direction
     */
    readonly fovy: number
    /**
     * the aspect ratio that determines the field of view in the x
     *   direction. The aspect ratio is the ratio of x (width) to y (height)
     */
    readonly aspect: number
    /**
     * the distance from the viewer to the near clipping
     *   plane (always positive)
     */
    readonly zNear: number
    /**
     * the distance from the viewer to the far clipping
     *   plane (always positive)
     */
    readonly zFar: number
    static name: string
}
abstract class PipelineNodeClass {
    static name: string
}
class Point {
    /* Fields of Clutter-1.0.Clutter.Point */
    /**
     * X coordinate, in pixels
     */
    readonly x: number
    /**
     * Y coordinate, in pixels
     */
    readonly y: number
    /* Methods of Clutter-1.0.Clutter.Point */
    /**
     * Creates a new #ClutterPoint with the same coordinates of `point`.
     */
    copy(): Point
    /**
     * Computes the distance between two #ClutterPoint.
     */
    distance(b: Point): [ /* returnType */ number, /* xDistance */ number | null, /* yDistance */ number | null ]
    /**
     * Compares two #ClutterPoint for equality.
     */
    equals(b: Point): boolean
    /**
     * Frees the resources allocated for `point`.
     */
    free(): void
    /**
     * Initializes `point` with the given coordinates.
     */
    init(x: number, y: number): Point
    static name: string
    /* Static methods and pseudo-constructors */
    static alloc(): Point
    /**
     * A point centered at (0, 0).
     * 
     * The returned value can be used as a guard.
     */
    static zero(): Point
}
abstract class PropertyTransitionClass {
    static name: string
}
class PropertyTransitionPrivate {
    static name: string
}
class Rect {
    /* Fields of Clutter-1.0.Clutter.Rect */
    /**
     * the origin of the rectangle
     */
    readonly origin: Point
    /**
     * the size of the rectangle
     */
    readonly size: Size
    /* Methods of Clutter-1.0.Clutter.Rect */
    /**
     * Rounds the origin of `rect` downwards to the nearest integer, and rounds
     * the size of `rect` upwards to the nearest integer, so that `rect` is
     * updated to the smallest rectangle capable of fully containing the
     * original, fractional rectangle.
     */
    clampToPixel(): void
    /**
     * Checks whether `point` is contained by `rect,` after normalizing the
     * rectangle.
     */
    containsPoint(point: Point): boolean
    /**
     * Checks whether `a` contains `b`.
     * 
     * The first rectangle contains the second if the union of the
     * two #ClutterRect is equal to the first rectangle.
     */
    containsRect(b: Rect): boolean
    /**
     * Copies `rect` into a new #ClutterRect instance.
     */
    copy(): Rect
    /**
     * Checks whether `a` and `b` are equals.
     * 
     * This function will normalize both `a` and `b` before comparing
     * their origin and size.
     */
    equals(b: Rect): boolean
    /**
     * Frees the resources allocated by `rect`.
     */
    free(): void
    /**
     * Retrieves the center of `rect,` after normalizing the rectangle,
     * and updates `center` with the correct coordinates.
     */
    getCenter(): /* center */ Point
    /**
     * Retrieves the height of `rect`.
     */
    getHeight(): number
    /**
     * Retrieves the width of `rect`.
     */
    getWidth(): number
    /**
     * Retrieves the X coordinate of the origin of `rect`.
     */
    getX(): number
    /**
     * Retrieves the Y coordinate of the origin of `rect`.
     */
    getY(): number
    /**
     * Initializes a #ClutterRect with the given origin and size.
     */
    init(x: number, y: number, width: number, height: number): Rect
    /**
     * Normalizes the `rect` and offsets its origin by the `d_x` and `d_y` values;
     * the size is adjusted by (2 * `d_x,` 2 * `d_y)`.
     * 
     * If `d_x` and `d_y` are positive the size of the rectangle is decreased; if
     * the values are negative, the size of the rectangle is increased.
     * 
     * If the resulting rectangle has a negative width or height, the size is
     * set to 0.
     */
    inset(dX: number, dY: number): void
    /**
     * Computes the intersection of `a` and `b,` and places it in `res,` if `res`
     * is not %NULL.
     * 
     * This function will normalize both `a` and `b` prior to computing their
     * intersection.
     * 
     * This function can be used to simply check if the intersection of `a` and `b`
     * is not empty, by using %NULL for `res`.
     */
    intersection(b: Rect): [ /* returnType */ boolean, /* res */ Rect | null ]
    /**
     * Normalizes a #ClutterRect.
     * 
     * A #ClutterRect is defined by the area covered by its size; this means
     * that a #ClutterRect with #ClutterRect.origin in [ 0, 0 ] and a
     * #ClutterRect.size of [ 10, 10 ] is equivalent to a #ClutterRect with
     * #ClutterRect.origin in [ 10, 10 ] and a #ClutterRect.size of [ -10, -10 ].
     * 
     * This function is useful to ensure that a rectangle has positive width
     * and height; it will modify the passed `rect` and normalize its size.
     */
    normalize(): Rect
    /**
     * Offsets the origin of `rect` by the given values, after normalizing
     * the rectangle.
     */
    offset(dX: number, dY: number): void
    /**
     * Computes the smallest possible rectangle capable of fully containing
     * both `a` and `b,` and places it into `res`.
     * 
     * This function will normalize both `a` and `b` prior to computing their
     * union.
     */
    union(b: Rect): /* res */ Rect
    static name: string
    /* Static methods and pseudo-constructors */
    static alloc(): Rect
    /**
     * A #ClutterRect with #ClutterRect.origin set at (0, 0) and a size
     * of 0.
     * 
     * The returned value can be used as a guard.
     */
    static zero(): Rect
}
abstract class RectangleClass {
    static name: string
}
class RectanglePrivate {
    static name: string
}
abstract class RotateActionClass {
    /* Fields of Clutter-1.0.Clutter.RotateActionClass */
    readonly rotate: (action: RotateAction, actor: Actor, angle: number) => boolean
    static name: string
}
class RotateActionPrivate {
    static name: string
}
abstract class ScoreClass {
    /* Fields of Clutter-1.0.Clutter.ScoreClass */
    readonly timelineStarted: (score: Score, timeline: Timeline) => void
    readonly timelineCompleted: (score: Score, timeline: Timeline) => void
    readonly started: (score: Score) => void
    readonly completed: (score: Score) => void
    readonly paused: (score: Score) => void
    static name: string
}
class ScorePrivate {
    static name: string
}
abstract class ScriptClass {
    /* Fields of Clutter-1.0.Clutter.ScriptClass */
    readonly getTypeFromName: (script: Script, typeName: string) => GObject.Type
    static name: string
}
class ScriptPrivate {
    static name: string
}
abstract class ScriptableIface {
    /* Fields of Clutter-1.0.Clutter.ScriptableIface */
    readonly setId: (scriptable: Scriptable, id: string) => void
    readonly getId: (scriptable: Scriptable) => string
    readonly parseCustomNode: (scriptable: Scriptable, script: Script, value: any, name: string, node: Json.Node) => boolean
    readonly setCustomProperty: (scriptable: Scriptable, script: Script, name: string, value: any) => void
    static name: string
}
abstract class ScrollActorClass {
    static name: string
}
class ScrollActorPrivate {
    static name: string
}
class ScrollEvent {
    /* Fields of Clutter-1.0.Clutter.ScrollEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor
     */
    readonly source: Actor
    /**
     * event X coordinate
     */
    readonly x: number
    /**
     * event Y coordinate
     */
    readonly y: number
    /**
     * direction of the scrolling
     */
    readonly direction: ScrollDirection
    /**
     * button modifiers
     */
    readonly modifierState: ModifierType
    /**
     * reserved for future use
     */
    readonly axes: number
    /**
     * the device that originated the event. If you want the physical
     * device the event originated from, use clutter_event_get_source_device()
     */
    readonly device: InputDevice
    /**
     * the source of scroll events. This field is available since 1.26
     */
    readonly scrollSource: ScrollSource
    /**
     * the axes that were stopped in this event. This field is available since 1.26
     */
    readonly finishFlags: ScrollFinishFlags
    static name: string
}
abstract class SettingsClass {
    static name: string
}
abstract class ShaderClass {
    static name: string
}
abstract class ShaderEffectClass {
    /* Fields of Clutter-1.0.Clutter.ShaderEffectClass */
    readonly getStaticShaderSource: (effect: ShaderEffect) => string
    static name: string
}
class ShaderEffectPrivate {
    static name: string
}
class ShaderPrivate {
    static name: string
}
class Size {
    /* Fields of Clutter-1.0.Clutter.Size */
    /**
     * the width, in pixels
     */
    readonly width: number
    /**
     * the height, in pixels
     */
    readonly height: number
    /* Methods of Clutter-1.0.Clutter.Size */
    /**
     * Creates a new #ClutterSize and duplicates `size`.
     */
    copy(): Size
    /**
     * Compares two #ClutterSize for equality.
     */
    equals(b: Size): boolean
    /**
     * Frees the resources allocated for `size`.
     */
    free(): void
    /**
     * Initializes a #ClutterSize with the given dimensions.
     */
    init(width: number, height: number): Size
    static name: string
    /* Static methods and pseudo-constructors */
    static alloc(): Size
}
abstract class SnapConstraintClass {
    static name: string
}
abstract class StageClass {
    /* Fields of Clutter-1.0.Clutter.StageClass */
    readonly fullscreen: (stage: Stage) => void
    readonly unfullscreen: (stage: Stage) => void
    readonly activate: (stage: Stage) => void
    readonly deactivate: (stage: Stage) => void
    readonly deleteEvent: (stage: Stage, event: Event) => boolean
    static name: string
}
abstract class StageManagerClass {
    /* Fields of Clutter-1.0.Clutter.StageManagerClass */
    readonly stageAdded: (stageManager: StageManager, stage: Stage) => void
    readonly stageRemoved: (stageManager: StageManager, stage: Stage) => void
    static name: string
}
class StagePrivate {
    static name: string
}
class StageStateEvent {
    /* Fields of Clutter-1.0.Clutter.StageStateEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor (unused)
     */
    readonly source: Actor
    /**
     * bitwise OR of the changed flags
     */
    readonly changedMask: StageState
    /**
     * bitwise OR of the current state flags
     */
    readonly newState: StageState
    static name: string
}
abstract class StateClass {
    /* Fields of Clutter-1.0.Clutter.StateClass */
    readonly completed: (state: State) => void
    static name: string
}
class StateKey {
    /* Methods of Clutter-1.0.Clutter.StateKey */
    /**
     * Retrieves the easing mode used for `state_key`.
     */
    getMode(): number
    /**
     * Retrieves the object instance this #ClutterStateKey applies to.
     */
    getObject(): GObject.Object
    /**
     * Retrieves the duration of the pause after transitioning is complete
     * as a fraction of the total transition time.
     */
    getPostDelay(): number
    /**
     * Retrieves the pause before transitioning starts as a fraction of
     * the total transition time.
     */
    getPreDelay(): number
    /**
     * Retrieves the name of the property this #ClutterStateKey applies to
     */
    getPropertyName(): string
    /**
     * Retrieves the #GType of the property a key applies to
     * 
     * You can use this type to initialize the #GValue to pass to
     * clutter_state_key_get_value()
     */
    getPropertyType(): GObject.Type
    /**
     * Retrieves the name of the source state of the `state_key`
     */
    getSourceStateName(): string
    /**
     * Get the name of the source state this #ClutterStateKey contains,
     * or NULL if this is the generic state key for the given property
     * when transitioning to the target state.
     */
    getTargetStateName(): string
    /**
     * Retrieves a copy of the value for a #ClutterStateKey.
     * 
     * The #GValue needs to be already initialized for the value type
     * of the property or to a type that allow transformation from the value
     * type of the key.
     * 
     * Use g_value_unset() when done.
     */
    getValue(value: any): boolean
    static name: string
}
class StatePrivate {
    static name: string
}
abstract class SwipeActionClass {
    /* Fields of Clutter-1.0.Clutter.SwipeActionClass */
    readonly swept: (action: SwipeAction, actor: Actor, direction: SwipeDirection) => void
    readonly swipe: (action: SwipeAction, actor: Actor, direction: SwipeDirection) => boolean
    static name: string
}
class SwipeActionPrivate {
    static name: string
}
abstract class TableLayoutClass {
    static name: string
}
class TableLayoutPrivate {
    static name: string
}
abstract class TapActionClass {
    /* Fields of Clutter-1.0.Clutter.TapActionClass */
    readonly tap: (action: TapAction, actor: Actor) => boolean
    static name: string
}
class TapActionPrivate {
    static name: string
}
abstract class TextBufferClass {
    /* Fields of Clutter-1.0.Clutter.TextBufferClass */
    readonly insertedText: (buffer: TextBuffer, position: number, chars: string, nChars: number) => void
    readonly deletedText: (buffer: TextBuffer, position: number, nChars: number) => void
    readonly getText: (buffer: TextBuffer, nBytes: number) => string
    readonly getLength: (buffer: TextBuffer) => number
    readonly insertText: (buffer: TextBuffer, position: number, chars: string, nChars: number) => number
    readonly deleteText: (buffer: TextBuffer, position: number, nChars: number) => number
    static name: string
}
class TextBufferPrivate {
    static name: string
}
abstract class TextClass {
    /* Fields of Clutter-1.0.Clutter.TextClass */
    readonly textChanged: (self: Text) => void
    readonly activate: (self: Text) => void
    readonly cursorEvent: (self: Text, geometry: Geometry) => void
    readonly cursorChanged: (self: Text) => void
    static name: string
}
abstract class TextNodeClass {
    static name: string
}
class TextPrivate {
    static name: string
}
abstract class TextureClass {
    /* Fields of Clutter-1.0.Clutter.TextureClass */
    readonly sizeChange: (texture: Texture, width: number, height: number) => void
    readonly pixbufChange: (texture: Texture) => void
    readonly loadFinished: (texture: Texture, error: GLib.Error) => void
    static name: string
}
abstract class TextureNodeClass {
    static name: string
}
class TexturePrivate {
    static name: string
}
abstract class TimelineClass {
    /* Fields of Clutter-1.0.Clutter.TimelineClass */
    readonly started: (timeline: Timeline) => void
    readonly completed: (timeline: Timeline) => void
    readonly paused: (timeline: Timeline) => void
    readonly newFrame: (timeline: Timeline, msecs: number) => void
    readonly markerReached: (timeline: Timeline, markerName: string, msecs: number) => void
    readonly stopped: (timeline: Timeline, isFinished: boolean) => void
    static name: string
}
class TimelinePrivate {
    static name: string
}
class TimeoutPool {
    /* Methods of Clutter-1.0.Clutter.TimeoutPool */
    /**
     * Sets a function to be called at regular intervals, and puts it inside
     * the `pool`. The function is repeatedly called until it returns %FALSE,
     * at which point the timeout is automatically destroyed and the function
     * won't be called again. If `notify` is not %NULL, the `notify` function
     * will be called. The first call to `func` will be at the end of `interval`.
     * 
     * Since Clutter 0.8 this will try to compensate for delays. For
     * example, if `func` takes half the interval time to execute then the
     * function will be called again half the interval time after it
     * finished. Before version 0.8 it would not fire until a full
     * interval after the function completes so the delay between calls
     * would be `interval` * 1.5. This function does not however try to
     * invoke the function multiple times to catch up missing frames if
     * `func` takes more than `interval` ms to execute.
     */
    add(fps: number, func: GLib.SourceFunc): number
    /**
     * Removes a timeout function with `id_` from the timeout pool. The id
     * is the same returned when adding a function to the timeout pool with
     * clutter_timeout_pool_add().
     */
    remove(id: number): void
    static name: string
}
class TouchEvent {
    /* Fields of Clutter-1.0.Clutter.TouchEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor (unused)
     */
    readonly source: Actor
    /**
     * the X coordinate of the pointer, relative to the stage
     */
    readonly x: number
    /**
     * the Y coordinate of the pointer, relative to the stage
     */
    readonly y: number
    /**
     * the event sequence that this event belongs to
     */
    readonly sequence: EventSequence
    /**
     * a bit-mask representing the state
     *   of modifier keys (e.g. Control, Shift, and Alt) and the pointer
     *   buttons. See #ClutterModifierType
     */
    readonly modifierState: ModifierType
    /**
     * reserved
     */
    readonly axes: number
    /**
     * the device that originated the event. If you want the physical
     * device the event originated from, use clutter_event_get_source_device()
     */
    readonly device: InputDevice
    static name: string
}
class TouchpadPinchEvent {
    /* Fields of Clutter-1.0.Clutter.TouchpadPinchEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor (unused)
     */
    readonly source: Actor
    /**
     * the current phase of the gesture
     */
    readonly phase: TouchpadGesturePhase
    /**
     * the X coordinate of the pointer, relative to the stage
     */
    readonly x: number
    /**
     * the Y coordinate of the pointer, relative to the stage
     */
    readonly y: number
    /**
     * movement delta of the pinch focal point in the X axis
     */
    readonly dx: number
    /**
     * movement delta of the pinch focal point in the Y axis
     */
    readonly dy: number
    /**
     * angle delta in degrees, clockwise rotations are
     *   represented by positive deltas
     */
    readonly angleDelta: number
    /**
     * the current scale
     */
    readonly scale: number
    static name: string
}
class TouchpadSwipeEvent {
    /* Fields of Clutter-1.0.Clutter.TouchpadSwipeEvent */
    /**
     * event type
     */
    readonly type: EventType
    /**
     * event time
     */
    readonly time: number
    /**
     * event flags
     */
    readonly flags: EventFlags
    /**
     * event source stage
     */
    readonly stage: Stage
    /**
     * event source actor (unused)
     */
    readonly source: Actor
    /**
     * the current phase of the gesture
     */
    readonly phase: TouchpadGesturePhase
    /**
     * the number of fingers triggering the swipe
     */
    readonly nFingers: number
    /**
     * the X coordinate of the pointer, relative to the stage
     */
    readonly x: number
    /**
     * the Y coordinate of the pointer, relative to the stage
     */
    readonly y: number
    /**
     * movement delta of the pinch focal point in the X axis
     */
    readonly dx: number
    /**
     * movement delta of the pinch focal point in the Y axis
     */
    readonly dy: number
    static name: string
}
abstract class TransitionClass {
    /* Fields of Clutter-1.0.Clutter.TransitionClass */
    readonly attached: (transition: Transition, animatable: Animatable) => void
    readonly detached: (transition: Transition, animatable: Animatable) => void
    readonly computeValue: (transition: Transition, animatable: Animatable, interval: Interval, progress: number) => void
    static name: string
}
abstract class TransitionGroupClass {
    static name: string
}
class TransitionGroupPrivate {
    static name: string
}
class TransitionPrivate {
    static name: string
}
class Units {
    /* Methods of Clutter-1.0.Clutter.Units */
    /**
     * Copies `units`
     */
    copy(): Units
    /**
     * Frees the resources allocated by `units`
     * 
     * You should only call this function on a #ClutterUnits
     * created using clutter_units_copy()
     */
    free(): void
    /**
     * Retrieves the unit type of the value stored inside `units`
     */
    getUnitType(): UnitType
    /**
     * Retrieves the value stored inside `units`
     */
    getUnitValue(): number
    /**
     * Converts a value in #ClutterUnits to pixels
     */
    toPixels(): number
    /**
     * Converts `units` into a string
     * 
     * See clutter_units_from_string() for the units syntax and for
     * examples of output
     * 
     * Fractional values are truncated to the second decimal
     * position for em, mm and cm, and to the first decimal position for
     * typographic points. Pixels are integers.
     */
    toString(): string
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Stores a value in centimeters inside `units`
     */
    static fromCm(cm: number): /* units */ Units
    /**
     * Stores a value in em inside `units,` using the default font
     * name as returned by clutter_backend_get_font_name()
     */
    static fromEm(em: number): /* units */ Units
    /**
     * Stores a value in em inside `units` using `font_name`
     */
    static fromEmForFont(fontName: string | null, em: number): /* units */ Units
    /**
     * Stores a value in millimiters inside `units`
     */
    static fromMm(mm: number): /* units */ Units
    /**
     * Stores a value in pixels inside `units`
     */
    static fromPixels(px: number): /* units */ Units
    /**
     * Stores a value in typographic points inside `units`
     */
    static fromPt(pt: number): /* units */ Units
    /**
     * Parses a value and updates `units` with it
     * 
     * A #ClutterUnits expressed in string should match:
     * 
     * |[
     *   units: wsp* unit-value wsp* unit-name? wsp*
     *   unit-value: number
     *   unit-name: 'px' | 'pt' | 'mm' | 'em' | 'cm'
     *   number: digit+
     *           | digit* sep digit+
     *   sep: '.' | ','
     *   digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
     *   wsp: (#0x20 | #0x9 | #0xA | #0xB | #0xC | #0xD)+
     * ```
     * 
     * 
     * For instance, these are valid strings:
     * 
     * |[
     *   10 px
     *   5.1 em
     *   24 pt
     *   12.6 mm
     *   .3 cm
     * ```
     * 
     * 
     * While these are not:
     * 
     * |[
     *   42 cats
     *   omg!1!ponies
     * ```
     * 
     * 
     * If no unit is specified, pixels are assumed.
     */
    static fromString(str: string): [ /* returnType */ boolean, /* units */ Units ]
}
class Vertex {
    /* Fields of Clutter-1.0.Clutter.Vertex */
    /**
     * X coordinate of the vertex
     */
    readonly x: number
    /**
     * Y coordinate of the vertex
     */
    readonly y: number
    /**
     * Z coordinate of the vertex
     */
    readonly z: number
    /* Methods of Clutter-1.0.Clutter.Vertex */
    /**
     * Copies `vertex`
     */
    copy(): Vertex
    /**
     * Compares `vertex_a` and `vertex_b` for equality
     */
    equal(vertexB: Vertex): boolean
    /**
     * Frees a #ClutterVertex allocated using clutter_vertex_alloc() or
     * clutter_vertex_copy().
     */
    free(): void
    /**
     * Initializes `vertex` with the given coordinates.
     */
    init(x: number, y: number, z: number): Vertex
    static name: string
    static new(x: number, y: number, z: number): Vertex
    constructor(x: number, y: number, z: number)
    /* Static methods and pseudo-constructors */
    static alloc(): Vertex
    static new(x: number, y: number, z: number): Vertex
}
abstract class ZoomActionClass {
    /* Fields of Clutter-1.0.Clutter.ZoomActionClass */
    readonly zoom: (action: ZoomAction, actor: Actor, focalPoint: Point, factor: number) => boolean
    static name: string
}
class ZoomActionPrivate {
    static name: string
}
class Event {
    /* Methods of Clutter-1.0.Clutter.Event */
    /**
     * Copies `event`.
     */
    copy(): Event
    /**
     * Frees all resources used by `event`.
     */
    free(): void
    /**
     * Retrieves the angle relative from `source` to `target`.
     * 
     * The direction of the angle is from the position X axis towards
     * the positive Y axis.
     */
    getAngle(target: Event): number
    /**
     * Retrieves the array of axes values attached to the event.
     */
    getAxes(): [ /* returnType */ number, /* nAxes */ number ]
    /**
     * Retrieves the button number of `event`
     */
    getButton(): number
    /**
     * Retrieves the number of clicks of `event`
     */
    getClickCount(): number
    /**
     * Retrieves the coordinates of `event` and puts them into `x` and `y`.
     */
    getCoords(): [ /* x */ number, /* y */ number ]
    /**
     * Retrieves the #ClutterInputDevice for the event.
     * If you want the physical device the event originated from, use
     * clutter_event_get_source_device().
     * 
     * The #ClutterInputDevice structure is completely opaque and should
     * be cast to the platform-specific implementation.
     */
    getDevice(): InputDevice
    /**
     * Retrieves the events device id if set.
     */
    getDeviceId(): number
    /**
     * Retrieves the type of the device for `event`
     */
    getDeviceType(): InputDeviceType
    /**
     * Retrieves the distance between two events, a `source` and a `target`.
     */
    getDistance(target: Event): number
    /**
     * Retrieves the #ClutterEventSequence of `event`.
     */
    getEventSequence(): EventSequence
    /**
     * Retrieves the #ClutterEventFlags of `event`
     */
    getFlags(): EventFlags
    /**
     * Returns the gesture motion deltas relative to the current pointer
     * position.
     */
    getGestureMotionDelta(): [ /* dx */ number | null, /* dy */ number | null ]
    /**
     * Returns the phase of the event, See #ClutterTouchpadGesturePhase.
     */
    getGesturePhase(): TouchpadGesturePhase
    /**
     * Returns the angle delta reported by this specific event.
     */
    getGesturePinchAngleDelta(): number
    /**
     * Returns the current scale as reported by `event,` 1.0 being the original
     * distance at the time the corresponding event with phase
     * %CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN is received.
     * is received.
     */
    getGesturePinchScale(): number
    /**
     * Returns the number of fingers that is triggering the touchpad gesture.
     */
    getGestureSwipeFingerCount(): number
    /**
     * Retrieves the keycode of the key that caused `event`
     */
    getKeyCode(): number
    /**
     * Retrieves the key symbol of `event`
     */
    getKeySymbol(): number
    /**
     * Retrieves the unicode value for the key that caused `keyev`.
     */
    getKeyUnicode(): number
    /**
     * Retrieves the event coordinates as a #ClutterPoint.
     */
    getPosition(position: Point): void
    /**
     * Retrieves the related actor of a crossing event.
     */
    getRelated(): Actor
    /**
     * Retrieves the precise scrolling information of `event`.
     * 
     * The `event` has to have a #ClutterScrollEvent.direction value
     * of %CLUTTER_SCROLL_SMOOTH.
     */
    getScrollDelta(): [ /* dx */ number, /* dy */ number ]
    /**
     * Retrieves the direction of the scrolling of `event`
     */
    getScrollDirection(): ScrollDirection
    /**
     * Returns the #ClutterScrollFinishFlags of an scroll event. Those
     * can be used to determine whether post-scroll effects like kinetic
     * scrolling should be applied.
     */
    getScrollFinishFlags(): ScrollFinishFlags
    /**
     * Returns the #ClutterScrollSource that applies to an scroll event.
     */
    getScrollSource(): ScrollSource
    /**
     * Retrieves the source #ClutterActor the event originated from, or
     * NULL if the event has no source.
     */
    getSource(): Actor
    /**
     * Retrieves the hardware device that originated the event.
     * 
     * If you need the virtual device, use clutter_event_get_device().
     * 
     * If no hardware device originated this event, this function will
     * return the same device as clutter_event_get_device().
     */
    getSourceDevice(): InputDevice
    /**
     * Retrieves the source #ClutterStage the event originated for, or
     * %NULL if the event has no stage.
     */
    getStage(): Stage
    /**
     * Retrieves the modifier state of the event. In case the window system
     * supports reporting latched and locked modifiers, this function returns
     * the effective state.
     */
    getState(): ModifierType
    /**
     * Retrieves the decomposition of the keyboard state into button, base,
     * latched, locked and effective. This can be used to transmit to other
     * applications, for example when implementing a wayland compositor.
     */
    getStateFull(): [ /* buttonState */ ModifierType | null, /* baseState */ ModifierType | null, /* latchedState */ ModifierType | null, /* lockedState */ ModifierType | null, /* effectiveState */ ModifierType | null ]
    /**
     * Retrieves the time of the event.
     */
    getTime(): number
    /**
     * Checks whether `event` has the Control modifier mask set.
     */
    hasControlModifier(): boolean
    /**
     * Checks whether `event` has the Shift modifier mask set.
     */
    hasShiftModifier(): boolean
    /**
     * Checks whether a pointer `event` has been generated by the windowing
     * system. The returned value can be used to distinguish between events
     * synthesized by the windowing system itself (as opposed by Clutter).
     */
    isPointerEmulated(): boolean
    /**
     * Puts a copy of the event on the back of the event queue. The event will
     * have the %CLUTTER_EVENT_FLAG_SYNTHETIC flag set. If the source is set
     * event signals will be emitted for this source and capture/bubbling for
     * its ancestors. If the source is not set it will be generated by picking
     * or use the actor that currently has keyboard focus
     */
    put(): void
    /**
     * Sets the button number of `event`
     */
    setButton(button: number): void
    /**
     * Sets the coordinates of the `event`.
     */
    setCoords(x: number, y: number): void
    /**
     * Sets the device for `event`.
     */
    setDevice(device?: InputDevice | null): void
    /**
     * Sets the #ClutterEventFlags of `event`
     */
    setFlags(flags: EventFlags): void
    /**
     * Sets the keycode of the `event`.
     */
    setKeyCode(keyCode: number): void
    /**
     * Sets the key symbol of `event`.
     */
    setKeySymbol(keySym: number): void
    /**
     * Sets the Unicode value of `event`.
     */
    setKeyUnicode(keyUnicode: number): void
    /**
     * Sets the related actor of a crossing event
     */
    setRelated(actor?: Actor | null): void
    /**
     * Sets the precise scrolling information of `event`.
     */
    setScrollDelta(dx: number, dy: number): void
    /**
     * Sets the direction of the scrolling of `event`
     */
    setScrollDirection(direction: ScrollDirection): void
    /**
     * Sets the source #ClutterActor of `event`.
     */
    setSource(actor?: Actor | null): void
    /**
     * Sets the source #ClutterInputDevice for `event`.
     * 
     * The #ClutterEvent must have been created using clutter_event_new().
     */
    setSourceDevice(device?: InputDevice | null): void
    /**
     * Sets the source #ClutterStage of the event.
     */
    setStage(stage?: Stage | null): void
    /**
     * Sets the modifier state of the event.
     */
    setState(state: ModifierType): void
    /**
     * Sets the time of the event.
     */
    setTime(time: number): void
    /**
     * Retrieves the type of the event.
     */
    type(): EventType
    static name: string
    static new(type: EventType): Event
    constructor(type: EventType)
    /* Static methods and pseudo-constructors */
    static new(type: EventType): Event
    /**
     * Adds a function which will be called for all events that Clutter
     * processes. The function will be called before any signals are
     * emitted for the event and it will take precedence over any grabs.
     */
    static addFilter(stage: Stage | null, func: EventFilterFunc): number
    /**
     * Pops an event off the event queue. Applications should not need to call
     * this.
     */
    static get(): Event
    /**
     * Returns a pointer to the first event from the event queue but
     * does not remove it.
     */
    static peek(): Event
    /**
     * Removes an event filter that was previously added with
     * clutter_event_add_filter().
     */
    static removeFilter(id: number): void
}
}
export default Clutter;